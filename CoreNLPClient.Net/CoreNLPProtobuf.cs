// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: CoreNLP.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Edu.Stanford.Nlp.Pipeline {

  /// <summary>Holder for reflection information generated from CoreNLP.proto</summary>
  public static partial class CoreNLPReflection {

    #region Descriptor
    /// <summary>File descriptor for CoreNLP.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CoreNLPReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg1Db3JlTkxQLnByb3RvEhllZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5lIuEF",
            "CghEb2N1bWVudBIMCgR0ZXh0GAEgAigJEjUKCHNlbnRlbmNlGAIgAygLMiMu",
            "ZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5TZW50ZW5jZRI5Cgpjb3JlZkNo",
            "YWluGAMgAygLMiUuZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5Db3JlZkNo",
            "YWluEg0KBWRvY0lEGAQgASgJEg8KB2RvY0RhdGUYByABKAkSEAoIY2FsZW5k",
            "YXIYCCABKAQSOwoRc2VudGVuY2VsZXNzVG9rZW4YBSADKAsyIC5lZHUuc3Rh",
            "bmZvcmQubmxwLnBpcGVsaW5lLlRva2VuEjMKCWNoYXJhY3RlchgKIAMoCzIg",
            "LmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuVG9rZW4SLwoFcXVvdGUYBiAD",
            "KAsyIC5lZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5lLlF1b3RlEjcKCG1lbnRp",
            "b25zGAkgAygLMiUuZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5ORVJNZW50",
            "aW9uEiMKG2hhc0VudGl0eU1lbnRpb25zQW5ub3RhdGlvbhgNIAEoCBIOCgZ4",
            "bWxEb2MYCyABKAgSNAoIc2VjdGlvbnMYDCADKAsyIi5lZHUuc3RhbmZvcmQu",
            "bmxwLnBpcGVsaW5lLlNlY3Rpb24SPAoQbWVudGlvbnNGb3JDb3JlZhgOIAMo",
            "CzIiLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuTWVudGlvbhIhChloYXND",
            "b3JlZk1lbnRpb25Bbm5vdGF0aW9uGA8gASgIEhoKEmhhc0NvcmVmQW5ub3Rh",
            "dGlvbhgQIAEoCBIrCiNjb3JlZk1lbnRpb25Ub0VudGl0eU1lbnRpb25NYXBw",
            "aW5ncxgRIAMoBRIrCiNlbnRpdHlNZW50aW9uVG9Db3JlZk1lbnRpb25NYXBw",
            "aW5ncxgSIAMoBSoFCGQQgAIi8w8KCFNlbnRlbmNlEi8KBXRva2VuGAEgAygL",
            "MiAuZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5Ub2tlbhIYChB0b2tlbk9m",
            "ZnNldEJlZ2luGAIgAigNEhYKDnRva2VuT2Zmc2V0RW5kGAMgAigNEhUKDXNl",
            "bnRlbmNlSW5kZXgYBCABKA0SHAoUY2hhcmFjdGVyT2Zmc2V0QmVnaW4YBSAB",
            "KA0SGgoSY2hhcmFjdGVyT2Zmc2V0RW5kGAYgASgNEjcKCXBhcnNlVHJlZRgH",
            "IAEoCzIkLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuUGFyc2VUcmVlEkAK",
            "EmJpbmFyaXplZFBhcnNlVHJlZRgfIAEoCzIkLmVkdS5zdGFuZm9yZC5ubHAu",
            "cGlwZWxpbmUuUGFyc2VUcmVlEkAKEmFubm90YXRlZFBhcnNlVHJlZRggIAEo",
            "CzIkLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuUGFyc2VUcmVlEhEKCXNl",
            "bnRpbWVudBghIAEoCRI9Cg9rQmVzdFBhcnNlVHJlZXMYIiADKAsyJC5lZHUu",
            "c3RhbmZvcmQubmxwLnBpcGVsaW5lLlBhcnNlVHJlZRJFChFiYXNpY0RlcGVu",
            "ZGVuY2llcxgIIAEoCzIqLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuRGVw",
            "ZW5kZW5jeUdyYXBoEkkKFWNvbGxhcHNlZERlcGVuZGVuY2llcxgJIAEoCzIq",
            "LmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuRGVwZW5kZW5jeUdyYXBoElQK",
            "IGNvbGxhcHNlZENDUHJvY2Vzc2VkRGVwZW5kZW5jaWVzGAogASgLMiouZWR1",
            "LnN0YW5mb3JkLm5scC5waXBlbGluZS5EZXBlbmRlbmN5R3JhcGgSSwoXYWx0",
            "ZXJuYXRpdmVEZXBlbmRlbmNpZXMYDSABKAsyKi5lZHUuc3RhbmZvcmQubmxw",
            "LnBpcGVsaW5lLkRlcGVuZGVuY3lHcmFwaBI/CgxvcGVuaWVUcmlwbGUYDiAD",
            "KAsyKS5lZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5lLlJlbGF0aW9uVHJpcGxl",
            "EjwKCWticFRyaXBsZRgQIAMoCzIpLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxp",
            "bmUuUmVsYXRpb25UcmlwbGUSRQoQZW50YWlsZWRTZW50ZW5jZRgPIAMoCzIr",
            "LmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuU2VudGVuY2VGcmFnbWVudBJD",
            "Cg5lbnRhaWxlZENsYXVzZRgjIAMoCzIrLmVkdS5zdGFuZm9yZC5ubHAucGlw",
            "ZWxpbmUuU2VudGVuY2VGcmFnbWVudBJIChRlbmhhbmNlZERlcGVuZGVuY2ll",
            "cxgRIAEoCzIqLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuRGVwZW5kZW5j",
            "eUdyYXBoElAKHGVuaGFuY2VkUGx1c1BsdXNEZXBlbmRlbmNpZXMYEiABKAsy",
            "Ki5lZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5lLkRlcGVuZGVuY3lHcmFwaBIz",
            "CgljaGFyYWN0ZXIYEyADKAsyIC5lZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5l",
            "LlRva2VuEhEKCXBhcmFncmFwaBgLIAEoDRIMCgR0ZXh0GAwgASgJEhIKCmxp",
            "bmVOdW1iZXIYFCABKA0SHgoWaGFzUmVsYXRpb25Bbm5vdGF0aW9ucxgzIAEo",
            "CBIxCgZlbnRpdHkYNCADKAsyIS5lZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5l",
            "LkVudGl0eRI1CghyZWxhdGlvbhg1IAMoCzIjLmVkdS5zdGFuZm9yZC5ubHAu",
            "cGlwZWxpbmUuUmVsYXRpb24SJAocaGFzTnVtZXJpemVkVG9rZW5zQW5ub3Rh",
            "dGlvbhg2IAEoCBI3CghtZW50aW9ucxg3IAMoCzIlLmVkdS5zdGFuZm9yZC5u",
            "bHAucGlwZWxpbmUuTkVSTWVudGlvbhI8ChBtZW50aW9uc0ZvckNvcmVmGDgg",
            "AygLMiIuZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5NZW50aW9uEiIKGmhh",
            "c0NvcmVmTWVudGlvbnNBbm5vdGF0aW9uGDkgASgIEhIKCnNlbnRlbmNlSUQY",
            "OiABKAkSEwoLc2VjdGlvbkRhdGUYOyABKAkSFAoMc2VjdGlvbkluZGV4GDwg",
            "ASgNEhMKC3NlY3Rpb25OYW1lGD0gASgJEhUKDXNlY3Rpb25BdXRob3IYPiAB",
            "KAkSDQoFZG9jSUQYPyABKAkSFQoNc2VjdGlvblF1b3RlZBhAIAEoCBIjChto",
            "YXNFbnRpdHlNZW50aW9uc0Fubm90YXRpb24YQSABKAgSHwoXaGFzS0JQVHJp",
            "cGxlc0Fubm90YXRpb24YRCABKAgSIgoaaGFzT3BlbmllVHJpcGxlc0Fubm90",
            "YXRpb24YRSABKAgSFAoMY2hhcHRlckluZGV4GEIgASgNEhYKDnBhcmFncmFw",
            "aEluZGV4GEMgASgNEj0KEGVuaGFuY2VkU2VudGVuY2UYRiABKAsyIy5lZHUu",
            "c3RhbmZvcmQubmxwLnBpcGVsaW5lLlNlbnRlbmNlEg8KB3NwZWFrZXIYRyAB",
            "KAkSEwoLc3BlYWtlclR5cGUYSCABKAkqBQhkEIACIsIMCgVUb2tlbhIMCgR3",
            "b3JkGAEgASgJEgsKA3BvcxgCIAEoCRINCgV2YWx1ZRgDIAEoCRIQCghjYXRl",
            "Z29yeRgEIAEoCRIOCgZiZWZvcmUYBSABKAkSDQoFYWZ0ZXIYBiABKAkSFAoM",
            "b3JpZ2luYWxUZXh0GAcgASgJEgsKA25lchgIIAEoCRIRCgljb2Fyc2VORVIY",
            "PiABKAkSFgoOZmluZUdyYWluZWRORVIYPyABKAkSFQoNbmVyTGFiZWxQcm9i",
            "cxhCIAMoCRIVCg1ub3JtYWxpemVkTkVSGAkgASgJEg0KBWxlbW1hGAogASgJ",
            "EhEKCWJlZ2luQ2hhchgLIAEoDRIPCgdlbmRDaGFyGAwgASgNEhEKCXV0dGVy",
            "YW5jZRgNIAEoDRIPCgdzcGVha2VyGA4gASgJEhMKC3NwZWFrZXJUeXBlGE0g",
            "ASgJEhIKCmJlZ2luSW5kZXgYDyABKA0SEAoIZW5kSW5kZXgYECABKA0SFwoP",
            "dG9rZW5CZWdpbkluZGV4GBEgASgNEhUKDXRva2VuRW5kSW5kZXgYEiABKA0S",
            "NAoKdGltZXhWYWx1ZRgTIAEoCzIgLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxp",
            "bmUuVGltZXgSFQoNaGFzWG1sQ29udGV4dBgVIAEoCBISCgp4bWxDb250ZXh0",
            "GBYgAygJEhYKDmNvcmVmQ2x1c3RlcklEGBcgASgNEg4KBmFuc3dlchgYIAEo",
            "CRIVCg1oZWFkV29yZEluZGV4GBogASgNEjUKCG9wZXJhdG9yGBsgASgLMiMu",
            "ZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5PcGVyYXRvchI1Cghwb2xhcml0",
            "eRgcIAEoCzIjLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuUG9sYXJpdHkS",
            "FAoMcG9sYXJpdHlfZGlyGCcgASgJEi0KBHNwYW4YHSABKAsyHy5lZHUuc3Rh",
            "bmZvcmQubmxwLnBpcGVsaW5lLlNwYW4SEQoJc2VudGltZW50GB4gASgJEhYK",
            "DnF1b3RhdGlvbkluZGV4GB8gASgFEkIKDmNvbmxsVUZlYXR1cmVzGCAgASgL",
            "MiouZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5NYXBTdHJpbmdTdHJpbmcS",
            "EQoJY29hcnNlVGFnGCEgASgJEjgKD2NvbmxsVVRva2VuU3BhbhgiIAEoCzIf",
            "LmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuU3BhbhISCgpjb25sbFVNaXNj",
            "GCMgASgJEkcKE2NvbmxsVVNlY29uZGFyeURlcHMYJCABKAsyKi5lZHUuc3Rh",
            "bmZvcmQubmxwLnBpcGVsaW5lLk1hcFN0cmluZ1N0cmluZxIXCg93aWtpcGVk",
            "aWFFbnRpdHkYJSABKAkSEQoJaXNOZXdsaW5lGCYgASgIEg4KBmdlbmRlchgz",
            "IAEoCRIQCgh0cnVlQ2FzZRg0IAEoCRIUCgx0cnVlQ2FzZVRleHQYNSABKAkS",
            "EwoLY2hpbmVzZUNoYXIYNiABKAkSEgoKY2hpbmVzZVNlZxg3IAEoCRIWCg5j",
            "aGluZXNlWE1MQ2hhchg8IAEoCRIRCglhcmFiaWNTZWcYTCABKAkSEwoLc2Vj",
            "dGlvbk5hbWUYOCABKAkSFQoNc2VjdGlvbkF1dGhvchg5IAEoCRITCgtzZWN0",
            "aW9uRGF0ZRg6IAEoCRIXCg9zZWN0aW9uRW5kTGFiZWwYOyABKAkSDgoGcGFy",
            "ZW50GD0gASgJEhkKEWNvcmVmTWVudGlvbkluZGV4GEAgAygNEhoKEmVudGl0",
            "eU1lbnRpb25JbmRleBhBIAEoDRINCgVpc01XVBhDIAEoCBISCgppc0ZpcnN0",
            "TVdUGEQgASgIEg8KB213dFRleHQYRSABKAkSFAoMbnVtZXJpY1ZhbHVlGEYg",
            "ASgEEhMKC251bWVyaWNUeXBlGEcgASgJEh0KFW51bWVyaWNDb21wb3NpdGVW",
            "YWx1ZRhIIAEoBBIcChRudW1lcmljQ29tcG9zaXRlVHlwZRhJIAEoCRIcChRj",
            "b2RlcG9pbnRPZmZzZXRCZWdpbhhKIAEoDRIaChJjb2RlcG9pbnRPZmZzZXRF",
            "bmQYSyABKA0qBQhkEIACIuQDCgVRdW90ZRIMCgR0ZXh0GAEgASgJEg0KBWJl",
            "Z2luGAIgASgNEgsKA2VuZBgDIAEoDRIVCg1zZW50ZW5jZUJlZ2luGAUgASgN",
            "EhMKC3NlbnRlbmNlRW5kGAYgASgNEhIKCnRva2VuQmVnaW4YByABKA0SEAoI",
            "dG9rZW5FbmQYCCABKA0SDQoFZG9jaWQYCSABKAkSDQoFaW5kZXgYCiABKA0S",
            "DgoGYXV0aG9yGAsgASgJEg8KB21lbnRpb24YDCABKAkSFAoMbWVudGlvbkJl",
            "Z2luGA0gASgNEhIKCm1lbnRpb25FbmQYDiABKA0SEwoLbWVudGlvblR5cGUY",
            "DyABKAkSFAoMbWVudGlvblNpZXZlGBAgASgJEg8KB3NwZWFrZXIYESABKAkS",
            "FAoMc3BlYWtlclNpZXZlGBIgASgJEhgKEGNhbm9uaWNhbE1lbnRpb24YEyAB",
            "KAkSHQoVY2Fub25pY2FsTWVudGlvbkJlZ2luGBQgASgNEhsKE2Nhbm9uaWNh",
            "bE1lbnRpb25FbmQYFSABKA0STgoaYXR0cmlidXRpb25EZXBlbmRlbmN5R3Jh",
            "cGgYFiABKAsyKi5lZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5lLkRlcGVuZGVu",
            "Y3lHcmFwaCLHAQoJUGFyc2VUcmVlEjMKBWNoaWxkGAEgAygLMiQuZWR1LnN0",
            "YW5mb3JkLm5scC5waXBlbGluZS5QYXJzZVRyZWUSDQoFdmFsdWUYAiABKAkS",
            "FwoPeWllbGRCZWdpbkluZGV4GAMgASgNEhUKDXlpZWxkRW5kSW5kZXgYBCAB",
            "KA0SDQoFc2NvcmUYBSABKAESNwoJc2VudGltZW50GAYgASgOMiQuZWR1LnN0",
            "YW5mb3JkLm5scC5waXBlbGluZS5TZW50aW1lbnQilgMKD0RlcGVuZGVuY3lH",
            "cmFwaBI9CgRub2RlGAEgAygLMi8uZWR1LnN0YW5mb3JkLm5scC5waXBlbGlu",
            "ZS5EZXBlbmRlbmN5R3JhcGguTm9kZRI9CgRlZGdlGAIgAygLMi8uZWR1LnN0",
            "YW5mb3JkLm5scC5waXBlbGluZS5EZXBlbmRlbmN5R3JhcGguRWRnZRIQCgRy",
            "b290GAMgAygNQgIQARpECgROb2RlEhUKDXNlbnRlbmNlSW5kZXgYASACKA0S",
            "DQoFaW5kZXgYAiACKA0SFgoOY29weUFubm90YXRpb24YAyABKA0arAEKBEVk",
            "Z2USDgoGc291cmNlGAEgAigNEg4KBnRhcmdldBgCIAIoDRILCgNkZXAYAyAB",
            "KAkSDwoHaXNFeHRyYRgEIAEoCBISCgpzb3VyY2VDb3B5GAUgASgNEhIKCnRh",
            "cmdldENvcHkYBiABKA0SPgoIbGFuZ3VhZ2UYByABKA4yIy5lZHUuc3RhbmZv",
            "cmQubmxwLnBpcGVsaW5lLkxhbmd1YWdlOgdVbmtub3duIsYCCgpDb3JlZkNo",
            "YWluEg8KB2NoYWluSUQYASACKAUSQwoHbWVudGlvbhgCIAMoCzIyLmVkdS5z",
            "dGFuZm9yZC5ubHAucGlwZWxpbmUuQ29yZWZDaGFpbi5Db3JlZk1lbnRpb24S",
            "FgoOcmVwcmVzZW50YXRpdmUYAyACKA0ayQEKDENvcmVmTWVudGlvbhIRCglt",
            "ZW50aW9uSUQYASABKAUSEwoLbWVudGlvblR5cGUYAiABKAkSDgoGbnVtYmVy",
            "GAMgASgJEg4KBmdlbmRlchgEIAEoCRIPCgdhbmltYWN5GAUgASgJEhIKCmJl",
            "Z2luSW5kZXgYBiABKA0SEAoIZW5kSW5kZXgYByABKA0SEQoJaGVhZEluZGV4",
            "GAkgASgNEhUKDXNlbnRlbmNlSW5kZXgYCiABKA0SEAoIcG9zaXRpb24YCyAB",
            "KA0i7wgKB01lbnRpb24SEQoJbWVudGlvbklEGAEgASgFEhMKC21lbnRpb25U",
            "eXBlGAIgASgJEg4KBm51bWJlchgDIAEoCRIOCgZnZW5kZXIYBCABKAkSDwoH",
            "YW5pbWFjeRgFIAEoCRIOCgZwZXJzb24YBiABKAkSEgoKc3RhcnRJbmRleBgH",
            "IAEoDRIQCghlbmRJbmRleBgJIAEoDRIRCgloZWFkSW5kZXgYCiABKAUSEgoK",
            "aGVhZFN0cmluZxgLIAEoCRIRCgluZXJTdHJpbmcYDCABKAkSEwoLb3JpZ2lu",
            "YWxSZWYYDSABKAUSGgoSZ29sZENvcmVmQ2x1c3RlcklEGA4gASgFEhYKDmNv",
            "cmVmQ2x1c3RlcklEGA8gASgFEhIKCm1lbnRpb25OdW0YECABKAUSDwoHc2Vu",
            "dE51bRgRIAEoBRINCgV1dHRlchgSIAEoBRIRCglwYXJhZ3JhcGgYEyABKAUS",
            "EQoJaXNTdWJqZWN0GBQgASgIEhYKDmlzRGlyZWN0T2JqZWN0GBUgASgIEhgK",
            "EGlzSW5kaXJlY3RPYmplY3QYFiABKAgSGwoTaXNQcmVwb3NpdGlvbk9iamVj",
            "dBgXIAEoCBIPCgdoYXNUd2luGBggASgIEg8KB2dlbmVyaWMYGSABKAgSEwoL",
            "aXNTaW5nbGV0b24YGiABKAgSGgoSaGFzQmFzaWNEZXBlbmRlbmN5GBsgASgI",
            "Eh0KFWhhc0VuaGFuY2VkRGVwZW5lZG5jeRgcIAEoCBIbChNoYXNDb250ZXh0",
            "UGFyc2VUcmVlGB0gASgIEj8KD2hlYWRJbmRleGVkV29yZBgeIAEoCzImLmVk",
            "dS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuSW5kZXhlZFdvcmQSPQoNZGVwZW5k",
            "aW5nVmVyYhgfIAEoCzImLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuSW5k",
            "ZXhlZFdvcmQSOAoIaGVhZFdvcmQYICABKAsyJi5lZHUuc3RhbmZvcmQubmxw",
            "LnBpcGVsaW5lLkluZGV4ZWRXb3JkEjsKC3NwZWFrZXJJbmZvGCEgASgLMiYu",
            "ZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5TcGVha2VySW5mbxI9Cg1zZW50",
            "ZW5jZVdvcmRzGDIgAygLMiYuZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5J",
            "bmRleGVkV29yZBI8CgxvcmlnaW5hbFNwYW4YMyADKAsyJi5lZHUuc3RhbmZv",
            "cmQubmxwLnBpcGVsaW5lLkluZGV4ZWRXb3JkEhIKCmRlcGVuZGVudHMYNCAD",
            "KAkSGQoRcHJlcHJvY2Vzc2VkVGVybXMYNSADKAkSEwoLYXBwb3NpdGlvbnMY",
            "NiADKAUSHAoUcHJlZGljYXRlTm9taW5hdGl2ZXMYNyADKAUSGAoQcmVsYXRp",
            "dmVQcm9ub3Vucxg4IAMoBRITCgtsaXN0TWVtYmVycxg5IAMoBRIVCg1iZWxv",
            "bmdUb0xpc3RzGDogAygFIlgKC0luZGV4ZWRXb3JkEhMKC3NlbnRlbmNlTnVt",
            "GAEgASgFEhIKCnRva2VuSW5kZXgYAiABKAUSDQoFZG9jSUQYAyABKAUSEQoJ",
            "Y29weUNvdW50GAQgASgNIjQKC1NwZWFrZXJJbmZvEhMKC3NwZWFrZXJOYW1l",
            "GAEgASgJEhAKCG1lbnRpb25zGAIgAygFIiIKBFNwYW4SDQoFYmVnaW4YASAC",
            "KA0SCwoDZW5kGAIgAigNIncKBVRpbWV4Eg0KBXZhbHVlGAEgASgJEhAKCGFs",
            "dFZhbHVlGAIgASgJEgwKBHRleHQYAyABKAkSDAoEdHlwZRgEIAEoCRILCgN0",
            "aWQYBSABKAkSEgoKYmVnaW5Qb2ludBgGIAEoDRIQCghlbmRQb2ludBgHIAEo",
            "DSLbAQoGRW50aXR5EhEKCWhlYWRTdGFydBgGIAEoDRIPCgdoZWFkRW5kGAcg",
            "ASgNEhMKC21lbnRpb25UeXBlGAggASgJEhYKDm5vcm1hbGl6ZWROYW1lGAkg",
            "ASgJEhYKDmhlYWRUb2tlbkluZGV4GAogASgNEg8KB2NvcmVmSUQYCyABKAkS",
            "EAoIb2JqZWN0SUQYASABKAkSEwoLZXh0ZW50U3RhcnQYAiABKA0SEQoJZXh0",
            "ZW50RW5kGAMgASgNEgwKBHR5cGUYBCABKAkSDwoHc3VidHlwZRgFIAEoCSK3",
            "AQoIUmVsYXRpb24SDwoHYXJnTmFtZRgGIAMoCRIuCgNhcmcYByADKAsyIS5l",
            "ZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5lLkVudGl0eRIRCglzaWduYXR1cmUY",
            "CCABKAkSEAoIb2JqZWN0SUQYASABKAkSEwoLZXh0ZW50U3RhcnQYAiABKA0S",
            "EQoJZXh0ZW50RW5kGAMgASgNEgwKBHR5cGUYBCABKAkSDwoHc3VidHlwZRgF",
            "IAEoCSKyAQoIT3BlcmF0b3ISDAoEbmFtZRgBIAIoCRIbChNxdWFudGlmaWVy",
            "U3BhbkJlZ2luGAIgAigFEhkKEXF1YW50aWZpZXJTcGFuRW5kGAMgAigFEhgK",
            "EHN1YmplY3RTcGFuQmVnaW4YBCACKAUSFgoOc3ViamVjdFNwYW5FbmQYBSAC",
            "KAUSFwoPb2JqZWN0U3BhbkJlZ2luGAYgAigFEhUKDW9iamVjdFNwYW5FbmQY",
            "ByACKAUiqQQKCFBvbGFyaXR5EksKEnByb2plY3RFcXVpdmFsZW5jZRgBIAIo",
            "DjIvLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuTmF0dXJhbExvZ2ljUmVs",
            "YXRpb24SUQoYcHJvamVjdEZvcndhcmRFbnRhaWxtZW50GAIgAigOMi8uZWR1",
            "LnN0YW5mb3JkLm5scC5waXBlbGluZS5OYXR1cmFsTG9naWNSZWxhdGlvbhJR",
            "Chhwcm9qZWN0UmV2ZXJzZUVudGFpbG1lbnQYAyACKA4yLy5lZHUuc3RhbmZv",
            "cmQubmxwLnBpcGVsaW5lLk5hdHVyYWxMb2dpY1JlbGF0aW9uEkgKD3Byb2pl",
            "Y3ROZWdhdGlvbhgEIAIoDjIvLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUu",
            "TmF0dXJhbExvZ2ljUmVsYXRpb24SSwoScHJvamVjdEFsdGVybmF0aW9uGAUg",
            "AigOMi8uZWR1LnN0YW5mb3JkLm5scC5waXBlbGluZS5OYXR1cmFsTG9naWNS",
            "ZWxhdGlvbhJFCgxwcm9qZWN0Q292ZXIYBiACKA4yLy5lZHUuc3RhbmZvcmQu",
            "bmxwLnBpcGVsaW5lLk5hdHVyYWxMb2dpY1JlbGF0aW9uEkwKE3Byb2plY3RJ",
            "bmRlcGVuZGVuY2UYByACKA4yLy5lZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5l",
            "Lk5hdHVyYWxMb2dpY1JlbGF0aW9uIt0CCgpORVJNZW50aW9uEhUKDXNlbnRl",
            "bmNlSW5kZXgYASABKA0SJQoddG9rZW5TdGFydEluU2VudGVuY2VJbmNsdXNp",
            "dmUYAiACKA0SIwobdG9rZW5FbmRJblNlbnRlbmNlRXhjbHVzaXZlGAMgAigN",
            "EgsKA25lchgEIAIoCRIVCg1ub3JtYWxpemVkTkVSGAUgASgJEhIKCmVudGl0",
            "eVR5cGUYBiABKAkSLwoFdGltZXgYByABKAsyIC5lZHUuc3RhbmZvcmQubmxw",
            "LnBpcGVsaW5lLlRpbWV4EhcKD3dpa2lwZWRpYUVudGl0eRgIIAEoCRIOCgZn",
            "ZW5kZXIYCSABKAkSGgoSZW50aXR5TWVudGlvbkluZGV4GAogASgNEiMKG2Nh",
            "bm9uaWNhbEVudGl0eU1lbnRpb25JbmRleBgLIAEoDRIZChFlbnRpdHlNZW50",
            "aW9uVGV4dBgMIAEoCSJZChBTZW50ZW5jZUZyYWdtZW50EhIKCnRva2VuSW5k",
            "ZXgYASADKA0SDAoEcm9vdBgCIAEoDRIUCgxhc3N1bWVkVHJ1dGgYAyABKAgS",
            "DQoFc2NvcmUYBCABKAEiOgoNVG9rZW5Mb2NhdGlvbhIVCg1zZW50ZW5jZUlu",
            "ZGV4GAEgASgNEhIKCnRva2VuSW5kZXgYAiABKA0imgMKDlJlbGF0aW9uVHJp",
            "cGxlEg8KB3N1YmplY3QYASABKAkSEAoIcmVsYXRpb24YAiABKAkSDgoGb2Jq",
            "ZWN0GAMgASgJEhIKCmNvbmZpZGVuY2UYBCABKAESPwoNc3ViamVjdFRva2Vu",
            "cxgNIAMoCzIoLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuVG9rZW5Mb2Nh",
            "dGlvbhJACg5yZWxhdGlvblRva2VucxgOIAMoCzIoLmVkdS5zdGFuZm9yZC5u",
            "bHAucGlwZWxpbmUuVG9rZW5Mb2NhdGlvbhI+CgxvYmplY3RUb2tlbnMYDyAD",
            "KAsyKC5lZHUuc3RhbmZvcmQubmxwLnBpcGVsaW5lLlRva2VuTG9jYXRpb24S",
            "OAoEdHJlZRgIIAEoCzIqLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuRGVw",
            "ZW5kZW5jeUdyYXBoEg4KBmlzdG1vZBgJIAEoCBIQCghwcmVmaXhCZRgKIAEo",
            "CBIQCghzdWZmaXhCZRgLIAEoCBIQCghzdWZmaXhPZhgMIAEoCCItCg9NYXBT",
            "dHJpbmdTdHJpbmcSCwoDa2V5GAEgAygJEg0KBXZhbHVlGAIgAygJIioKDE1h",
            "cEludFN0cmluZxILCgNrZXkYASADKA0SDQoFdmFsdWUYAiADKAki/AEKB1Nl",
            "Y3Rpb24SEQoJY2hhckJlZ2luGAEgAigNEg8KB2NoYXJFbmQYAiACKA0SDgoG",
            "YXV0aG9yGAMgASgJEhcKD3NlbnRlbmNlSW5kZXhlcxgEIAMoDRIQCghkYXRl",
            "dGltZRgFIAEoCRIwCgZxdW90ZXMYBiADKAsyIC5lZHUuc3RhbmZvcmQubmxw",
            "LnBpcGVsaW5lLlF1b3RlEhcKD2F1dGhvckNoYXJCZWdpbhgHIAEoDRIVCg1h",
            "dXRob3JDaGFyRW5kGAggASgNEjAKBnhtbFRhZxgJIAIoCzIgLmVkdS5zdGFu",
            "Zm9yZC5ubHAucGlwZWxpbmUuVG9rZW4i5AEKDlNlbWdyZXhSZXF1ZXN0Eg8K",
            "B3NlbWdyZXgYASADKAkSRQoFcXVlcnkYAiADKAsyNi5lZHUuc3RhbmZvcmQu",
            "bmxwLnBpcGVsaW5lLlNlbWdyZXhSZXF1ZXN0LkRlcGVuZGVuY2llcxp6CgxE",
            "ZXBlbmRlbmNpZXMSLwoFdG9rZW4YASADKAsyIC5lZHUuc3RhbmZvcmQubmxw",
            "LnBpcGVsaW5lLlRva2VuEjkKBWdyYXBoGAIgAigLMiouZWR1LnN0YW5mb3Jk",
            "Lm5scC5waXBlbGluZS5EZXBlbmRlbmN5R3JhcGgiigQKD1NlbWdyZXhSZXNw",
            "b25zZRJGCgZyZXN1bHQYASADKAsyNi5lZHUuc3RhbmZvcmQubmxwLnBpcGVs",
            "aW5lLlNlbWdyZXhSZXNwb25zZS5HcmFwaFJlc3VsdBotCglOYW1lZE5vZGUS",
            "DAoEbmFtZRgBIAIoCRISCgptYXRjaEluZGV4GAIgAigFGisKDU5hbWVkUmVs",
            "YXRpb24SDAoEbmFtZRgBIAIoCRIMCgRyZWxuGAIgAigJGqcBCgVNYXRjaBIS",
            "CgptYXRjaEluZGV4GAEgAigFEkIKBG5vZGUYAiADKAsyNC5lZHUuc3RhbmZv",
            "cmQubmxwLnBpcGVsaW5lLlNlbWdyZXhSZXNwb25zZS5OYW1lZE5vZGUSRgoE",
            "cmVsbhgDIAMoCzI4LmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuU2VtZ3Jl",
            "eFJlc3BvbnNlLk5hbWVkUmVsYXRpb24aUAoNU2VtZ3JleFJlc3VsdBI/CgVt",
            "YXRjaBgBIAMoCzIwLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuU2VtZ3Jl",
            "eFJlc3BvbnNlLk1hdGNoGlcKC0dyYXBoUmVzdWx0EkgKBnJlc3VsdBgBIAMo",
            "CzI4LmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuU2VtZ3JleFJlc3BvbnNl",
            "LlNlbWdyZXhSZXN1bHQiVwoSVG9rZW5zUmVnZXhSZXF1ZXN0EjAKA2RvYxgB",
            "IAIoCzIjLmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuRG9jdW1lbnQSDwoH",
            "cGF0dGVybhgCIAMoCSKnAwoTVG9rZW5zUmVnZXhSZXNwb25zZRJKCgVtYXRj",
            "aBgBIAMoCzI7LmVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmUuVG9rZW5zUmVn",
            "ZXhSZXNwb25zZS5QYXR0ZXJuTWF0Y2gaOQoNTWF0Y2hMb2NhdGlvbhIMCgR0",
            "ZXh0GAEgASgJEg0KBWJlZ2luGAIgASgFEgsKA2VuZBgDIAEoBRqzAQoFTWF0",
            "Y2gSEAoIc2VudGVuY2UYASACKAUSSwoFbWF0Y2gYAiACKAsyPC5lZHUuc3Rh",
            "bmZvcmQubmxwLnBpcGVsaW5lLlRva2Vuc1JlZ2V4UmVzcG9uc2UuTWF0Y2hM",
            "b2NhdGlvbhJLCgVncm91cBgDIAMoCzI8LmVkdS5zdGFuZm9yZC5ubHAucGlw",
            "ZWxpbmUuVG9rZW5zUmVnZXhSZXNwb25zZS5NYXRjaExvY2F0aW9uGlMKDFBh",
            "dHRlcm5NYXRjaBJDCgVtYXRjaBgBIAMoCzI0LmVkdS5zdGFuZm9yZC5ubHAu",
            "cGlwZWxpbmUuVG9rZW5zUmVnZXhSZXNwb25zZS5NYXRjaCqjAQoITGFuZ3Vh",
            "Z2USCwoHVW5rbm93bhAAEgcKA0FueRABEgoKBkFyYWJpYxACEgsKB0NoaW5l",
            "c2UQAxILCgdFbmdsaXNoEAQSCgoGR2VybWFuEAUSCgoGRnJlbmNoEAYSCgoG",
            "SGVicmV3EAcSCwoHU3BhbmlzaBAIEhQKEFVuaXZlcnNhbEVuZ2xpc2gQCRIU",
            "ChBVbml2ZXJzYWxDaGluZXNlEAoqaAoJU2VudGltZW50EhMKD1NUUk9OR19O",
            "RUdBVElWRRAAEhEKDVdFQUtfTkVHQVRJVkUQARILCgdORVVUUkFMEAISEQoN",
            "V0VBS19QT1NJVElWRRADEhMKD1NUUk9OR19QT1NJVElWRRAEKpMBChROYXR1",
            "cmFsTG9naWNSZWxhdGlvbhIPCgtFUVVJVkFMRU5DRRAAEhYKEkZPUldBUkRf",
            "RU5UQUlMTUVOVBABEhYKElJFVkVSU0VfRU5UQUlMTUVOVBACEgwKCE5FR0FU",
            "SU9OEAMSDwoLQUxURVJOQVRJT04QBBIJCgVDT1ZFUhAFEhAKDElOREVQRU5E",
            "RU5DRRAGQioKGWVkdS5zdGFuZm9yZC5ubHAucGlwZWxpbmVCDUNvcmVOTFBQ",
            "cm90b3M="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Edu.Stanford.Nlp.Pipeline.Language), typeof(global::Edu.Stanford.Nlp.Pipeline.Sentiment), typeof(global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Document), global::Edu.Stanford.Nlp.Pipeline.Document.Parser, new[]{ "Text", "Sentence", "CorefChain", "DocID", "DocDate", "Calendar", "SentencelessToken", "Character", "Quote", "Mentions", "HasEntityMentionsAnnotation", "XmlDoc", "Sections", "MentionsForCoref", "HasCorefMentionAnnotation", "HasCorefAnnotation", "CorefMentionToEntityMentionMappings", "EntityMentionToCorefMentionMappings" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Sentence), global::Edu.Stanford.Nlp.Pipeline.Sentence.Parser, new[]{ "Token", "TokenOffsetBegin", "TokenOffsetEnd", "SentenceIndex", "CharacterOffsetBegin", "CharacterOffsetEnd", "ParseTree", "BinarizedParseTree", "AnnotatedParseTree", "Sentiment", "KBestParseTrees", "BasicDependencies", "CollapsedDependencies", "CollapsedCCProcessedDependencies", "AlternativeDependencies", "OpenieTriple", "KbpTriple", "EntailedSentence", "EntailedClause", "EnhancedDependencies", "EnhancedPlusPlusDependencies", "Character", "Paragraph", "Text", "LineNumber", "HasRelationAnnotations", "Entity", "Relation", "HasNumerizedTokensAnnotation", "Mentions", "MentionsForCoref", "HasCorefMentionsAnnotation", "SentenceID", "SectionDate", "SectionIndex", "SectionName", "SectionAuthor", "DocID", "SectionQuoted", "HasEntityMentionsAnnotation", "HasKBPTriplesAnnotation", "HasOpenieTriplesAnnotation", "ChapterIndex", "ParagraphIndex", "EnhancedSentence", "Speaker", "SpeakerType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Token), global::Edu.Stanford.Nlp.Pipeline.Token.Parser, new[]{ "Word", "Pos", "Value", "Category", "Before", "After", "OriginalText", "Ner", "CoarseNER", "FineGrainedNER", "NerLabelProbs", "NormalizedNER", "Lemma", "BeginChar", "EndChar", "Utterance", "Speaker", "SpeakerType", "BeginIndex", "EndIndex", "TokenBeginIndex", "TokenEndIndex", "TimexValue", "HasXmlContext", "XmlContext", "CorefClusterID", "Answer", "HeadWordIndex", "Operator", "Polarity", "PolarityDir", "Span", "Sentiment", "QuotationIndex", "ConllUFeatures", "CoarseTag", "ConllUTokenSpan", "ConllUMisc", "ConllUSecondaryDeps", "WikipediaEntity", "IsNewline", "Gender", "TrueCase", "TrueCaseText", "ChineseChar", "ChineseSeg", "ChineseXMLChar", "ArabicSeg", "SectionName", "SectionAuthor", "SectionDate", "SectionEndLabel", "Parent", "CorefMentionIndex", "EntityMentionIndex", "IsMWT", "IsFirstMWT", "MwtText", "NumericValue", "NumericType", "NumericCompositeValue", "NumericCompositeType", "CodepointOffsetBegin", "CodepointOffsetEnd" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Quote), global::Edu.Stanford.Nlp.Pipeline.Quote.Parser, new[]{ "Text", "Begin", "End", "SentenceBegin", "SentenceEnd", "TokenBegin", "TokenEnd", "Docid", "Index", "Author", "Mention", "MentionBegin", "MentionEnd", "MentionType", "MentionSieve", "Speaker", "SpeakerSieve", "CanonicalMention", "CanonicalMentionBegin", "CanonicalMentionEnd", "AttributionDependencyGraph" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.ParseTree), global::Edu.Stanford.Nlp.Pipeline.ParseTree.Parser, new[]{ "Child", "Value", "YieldBeginIndex", "YieldEndIndex", "Score", "Sentiment" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.DependencyGraph), global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Parser, new[]{ "Node", "Edge", "Root" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Node), global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Node.Parser, new[]{ "SentenceIndex", "Index", "CopyAnnotation" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Edge), global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Edge.Parser, new[]{ "Source", "Target", "Dep", "IsExtra", "SourceCopy", "TargetCopy", "Language" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.CorefChain), global::Edu.Stanford.Nlp.Pipeline.CorefChain.Parser, new[]{ "ChainID", "Mention", "Representative" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.CorefChain.Types.CorefMention), global::Edu.Stanford.Nlp.Pipeline.CorefChain.Types.CorefMention.Parser, new[]{ "MentionID", "MentionType", "Number", "Gender", "Animacy", "BeginIndex", "EndIndex", "HeadIndex", "SentenceIndex", "Position" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Mention), global::Edu.Stanford.Nlp.Pipeline.Mention.Parser, new[]{ "MentionID", "MentionType", "Number", "Gender", "Animacy", "Person", "StartIndex", "EndIndex", "HeadIndex", "HeadString", "NerString", "OriginalRef", "GoldCorefClusterID", "CorefClusterID", "MentionNum", "SentNum", "Utter", "Paragraph", "IsSubject", "IsDirectObject", "IsIndirectObject", "IsPrepositionObject", "HasTwin", "Generic", "IsSingleton", "HasBasicDependency", "HasEnhancedDepenedncy", "HasContextParseTree", "HeadIndexedWord", "DependingVerb", "HeadWord", "SpeakerInfo", "SentenceWords", "OriginalSpan", "Dependents", "PreprocessedTerms", "Appositions", "PredicateNominatives", "RelativePronouns", "ListMembers", "BelongToLists" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.IndexedWord), global::Edu.Stanford.Nlp.Pipeline.IndexedWord.Parser, new[]{ "SentenceNum", "TokenIndex", "DocID", "CopyCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SpeakerInfo), global::Edu.Stanford.Nlp.Pipeline.SpeakerInfo.Parser, new[]{ "SpeakerName", "Mentions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Span), global::Edu.Stanford.Nlp.Pipeline.Span.Parser, new[]{ "Begin", "End" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Timex), global::Edu.Stanford.Nlp.Pipeline.Timex.Parser, new[]{ "Value", "AltValue", "Text", "Type", "Tid", "BeginPoint", "EndPoint" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Entity), global::Edu.Stanford.Nlp.Pipeline.Entity.Parser, new[]{ "HeadStart", "HeadEnd", "MentionType", "NormalizedName", "HeadTokenIndex", "CorefID", "ObjectID", "ExtentStart", "ExtentEnd", "Type", "Subtype" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Relation), global::Edu.Stanford.Nlp.Pipeline.Relation.Parser, new[]{ "ArgName", "Arg", "Signature", "ObjectID", "ExtentStart", "ExtentEnd", "Type", "Subtype" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Operator), global::Edu.Stanford.Nlp.Pipeline.Operator.Parser, new[]{ "Name", "QuantifierSpanBegin", "QuantifierSpanEnd", "SubjectSpanBegin", "SubjectSpanEnd", "ObjectSpanBegin", "ObjectSpanEnd" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Polarity), global::Edu.Stanford.Nlp.Pipeline.Polarity.Parser, new[]{ "ProjectEquivalence", "ProjectForwardEntailment", "ProjectReverseEntailment", "ProjectNegation", "ProjectAlternation", "ProjectCover", "ProjectIndependence" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.NERMention), global::Edu.Stanford.Nlp.Pipeline.NERMention.Parser, new[]{ "SentenceIndex", "TokenStartInSentenceInclusive", "TokenEndInSentenceExclusive", "Ner", "NormalizedNER", "EntityType", "Timex", "WikipediaEntity", "Gender", "EntityMentionIndex", "CanonicalEntityMentionIndex", "EntityMentionText" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SentenceFragment), global::Edu.Stanford.Nlp.Pipeline.SentenceFragment.Parser, new[]{ "TokenIndex", "Root", "AssumedTruth", "Score" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.TokenLocation), global::Edu.Stanford.Nlp.Pipeline.TokenLocation.Parser, new[]{ "SentenceIndex", "TokenIndex" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.RelationTriple), global::Edu.Stanford.Nlp.Pipeline.RelationTriple.Parser, new[]{ "Subject", "Relation", "Object", "Confidence", "SubjectTokens", "RelationTokens", "ObjectTokens", "Tree", "Istmod", "PrefixBe", "SuffixBe", "SuffixOf" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.MapStringString), global::Edu.Stanford.Nlp.Pipeline.MapStringString.Parser, new[]{ "Key", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.MapIntString), global::Edu.Stanford.Nlp.Pipeline.MapIntString.Parser, new[]{ "Key", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.Section), global::Edu.Stanford.Nlp.Pipeline.Section.Parser, new[]{ "CharBegin", "CharEnd", "Author", "SentenceIndexes", "Datetime", "Quotes", "AuthorCharBegin", "AuthorCharEnd", "XmlTag" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest), global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Parser, new[]{ "Semgrex", "Query" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Types.Dependencies), global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Types.Dependencies.Parser, new[]{ "Token", "Graph" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse), global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Parser, new[]{ "Result" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedNode), global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedNode.Parser, new[]{ "Name", "MatchIndex" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedRelation), global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedRelation.Parser, new[]{ "Name", "Reln" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.Match), global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.Match.Parser, new[]{ "MatchIndex", "Node", "Reln" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.SemgrexResult), global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.SemgrexResult.Parser, new[]{ "Match" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.GraphResult), global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.GraphResult.Parser, new[]{ "Result" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.TokensRegexRequest), global::Edu.Stanford.Nlp.Pipeline.TokensRegexRequest.Parser, new[]{ "Doc", "Pattern" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse), global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Parser, new[]{ "Match" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation), global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation.Parser, new[]{ "Text", "Begin", "End" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.Match), global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.Match.Parser, new[]{ "Sentence", "Match_", "Group" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.PatternMatch), global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.PatternMatch.Parser, new[]{ "Match" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  ///
  /// An enumeration for the valid languages allowed in CoreNLP
  /// </summary>
  public enum Language {
    [pbr::OriginalName("Unknown")] Unknown = 0,
    [pbr::OriginalName("Any")] Any = 1,
    [pbr::OriginalName("Arabic")] Arabic = 2,
    [pbr::OriginalName("Chinese")] Chinese = 3,
    [pbr::OriginalName("English")] English = 4,
    [pbr::OriginalName("German")] German = 5,
    [pbr::OriginalName("French")] French = 6,
    [pbr::OriginalName("Hebrew")] Hebrew = 7,
    [pbr::OriginalName("Spanish")] Spanish = 8,
    [pbr::OriginalName("UniversalEnglish")] UniversalEnglish = 9,
    [pbr::OriginalName("UniversalChinese")] UniversalChinese = 10,
  }

  /// <summary>
  ///
  /// An enumeration of valid sentiment values for the sentiment classifier.
  /// </summary>
  public enum Sentiment {
    [pbr::OriginalName("STRONG_NEGATIVE")] StrongNegative = 0,
    [pbr::OriginalName("WEAK_NEGATIVE")] WeakNegative = 1,
    [pbr::OriginalName("NEUTRAL")] Neutral = 2,
    [pbr::OriginalName("WEAK_POSITIVE")] WeakPositive = 3,
    [pbr::OriginalName("STRONG_POSITIVE")] StrongPositive = 4,
  }

  /// <summary>
  ///
  /// The seven informative Natural Logic relations
  /// </summary>
  public enum NaturalLogicRelation {
    [pbr::OriginalName("EQUIVALENCE")] Equivalence = 0,
    [pbr::OriginalName("FORWARD_ENTAILMENT")] ForwardEntailment = 1,
    [pbr::OriginalName("REVERSE_ENTAILMENT")] ReverseEntailment = 2,
    [pbr::OriginalName("NEGATION")] Negation = 3,
    [pbr::OriginalName("ALTERNATION")] Alternation = 4,
    [pbr::OriginalName("COVER")] Cover = 5,
    [pbr::OriginalName("INDEPENDENCE")] Independence = 6,
  }

  #endregion

  #region Messages
  /// <summary>
  ///
  /// A document; that is, the equivalent of an Annotation.
  /// </summary>
  public sealed partial class Document : pb::IExtendableMessage<Document> {
    private static readonly pb::MessageParser<Document> _parser = new pb::MessageParser<Document>(() => new Document());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<Document> _extensions;
    private pb::ExtensionSet<Document> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Document> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Document() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Document(Document other) : this() {
      _hasBits0 = other._hasBits0;
      text_ = other.text_;
      sentence_ = other.sentence_.Clone();
      corefChain_ = other.corefChain_.Clone();
      docID_ = other.docID_;
      docDate_ = other.docDate_;
      calendar_ = other.calendar_;
      sentencelessToken_ = other.sentencelessToken_.Clone();
      character_ = other.character_.Clone();
      quote_ = other.quote_.Clone();
      mentions_ = other.mentions_.Clone();
      hasEntityMentionsAnnotation_ = other.hasEntityMentionsAnnotation_;
      xmlDoc_ = other.xmlDoc_;
      sections_ = other.sections_.Clone();
      mentionsForCoref_ = other.mentionsForCoref_.Clone();
      hasCorefMentionAnnotation_ = other.hasCorefMentionAnnotation_;
      hasCorefAnnotation_ = other.hasCorefAnnotation_;
      corefMentionToEntityMentionMappings_ = other.corefMentionToEntityMentionMappings_.Clone();
      entityMentionToCorefMentionMappings_ = other.entityMentionToCorefMentionMappings_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Document Clone() {
      return new Document(this);
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 1;
    private readonly static string TextDefaultValue = "";

    private string text_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Text {
      get { return text_ ?? TextDefaultValue; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasText {
      get { return text_ != null; }
    }
    /// <summary>Clears the value of the "text" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearText() {
      text_ = null;
    }

    /// <summary>Field number for the "sentence" field.</summary>
    public const int SentenceFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Sentence> _repeated_sentence_codec
        = pb::FieldCodec.ForMessage(18, global::Edu.Stanford.Nlp.Pipeline.Sentence.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Sentence> sentence_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Sentence>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Sentence> Sentence {
      get { return sentence_; }
    }

    /// <summary>Field number for the "corefChain" field.</summary>
    public const int CorefChainFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.CorefChain> _repeated_corefChain_codec
        = pb::FieldCodec.ForMessage(26, global::Edu.Stanford.Nlp.Pipeline.CorefChain.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.CorefChain> corefChain_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.CorefChain>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.CorefChain> CorefChain {
      get { return corefChain_; }
    }

    /// <summary>Field number for the "docID" field.</summary>
    public const int DocIDFieldNumber = 4;
    private readonly static string DocIDDefaultValue = "";

    private string docID_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocID {
      get { return docID_ ?? DocIDDefaultValue; }
      set {
        docID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "docID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDocID {
      get { return docID_ != null; }
    }
    /// <summary>Clears the value of the "docID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDocID() {
      docID_ = null;
    }

    /// <summary>Field number for the "docDate" field.</summary>
    public const int DocDateFieldNumber = 7;
    private readonly static string DocDateDefaultValue = "";

    private string docDate_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocDate {
      get { return docDate_ ?? DocDateDefaultValue; }
      set {
        docDate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "docDate" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDocDate {
      get { return docDate_ != null; }
    }
    /// <summary>Clears the value of the "docDate" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDocDate() {
      docDate_ = null;
    }

    /// <summary>Field number for the "calendar" field.</summary>
    public const int CalendarFieldNumber = 8;
    private readonly static ulong CalendarDefaultValue = 0UL;

    private ulong calendar_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Calendar {
      get { if ((_hasBits0 & 1) != 0) { return calendar_; } else { return CalendarDefaultValue; } }
      set {
        _hasBits0 |= 1;
        calendar_ = value;
      }
    }
    /// <summary>Gets whether the "calendar" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCalendar {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "calendar" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCalendar() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "sentencelessToken" field.</summary>
    public const int SentencelessTokenFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Token> _repeated_sentencelessToken_codec
        = pb::FieldCodec.ForMessage(42, global::Edu.Stanford.Nlp.Pipeline.Token.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> sentencelessToken_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token>();
    /// <summary>
    ///*
    /// A peculiar field, for the corner case when a Document is
    /// serialized without any sentences. Otherwise
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> SentencelessToken {
      get { return sentencelessToken_; }
    }

    /// <summary>Field number for the "character" field.</summary>
    public const int CharacterFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Token> _repeated_character_codec
        = pb::FieldCodec.ForMessage(82, global::Edu.Stanford.Nlp.Pipeline.Token.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> character_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> Character {
      get { return character_; }
    }

    /// <summary>Field number for the "quote" field.</summary>
    public const int QuoteFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Quote> _repeated_quote_codec
        = pb::FieldCodec.ForMessage(50, global::Edu.Stanford.Nlp.Pipeline.Quote.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Quote> quote_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Quote>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Quote> Quote {
      get { return quote_; }
    }

    /// <summary>Field number for the "mentions" field.</summary>
    public const int MentionsFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.NERMention> _repeated_mentions_codec
        = pb::FieldCodec.ForMessage(74, global::Edu.Stanford.Nlp.Pipeline.NERMention.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.NERMention> mentions_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.NERMention>();
    /// <summary>
    ///*
    /// This field is for entity mentions across the document.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.NERMention> Mentions {
      get { return mentions_; }
    }

    /// <summary>Field number for the "hasEntityMentionsAnnotation" field.</summary>
    public const int HasEntityMentionsAnnotationFieldNumber = 13;
    private readonly static bool HasEntityMentionsAnnotationDefaultValue = false;

    private bool hasEntityMentionsAnnotation_;
    /// <summary>
    /// used to differentiate between null and empty list
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEntityMentionsAnnotation {
      get { if ((_hasBits0 & 4) != 0) { return hasEntityMentionsAnnotation_; } else { return HasEntityMentionsAnnotationDefaultValue; } }
      set {
        _hasBits0 |= 4;
        hasEntityMentionsAnnotation_ = value;
      }
    }
    /// <summary>Gets whether the "hasEntityMentionsAnnotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasEntityMentionsAnnotation {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "hasEntityMentionsAnnotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasEntityMentionsAnnotation() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "xmlDoc" field.</summary>
    public const int XmlDocFieldNumber = 11;
    private readonly static bool XmlDocDefaultValue = false;

    private bool xmlDoc_;
    /// <summary>
    ///*
    /// xml information
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool XmlDoc {
      get { if ((_hasBits0 & 2) != 0) { return xmlDoc_; } else { return XmlDocDefaultValue; } }
      set {
        _hasBits0 |= 2;
        xmlDoc_ = value;
      }
    }
    /// <summary>Gets whether the "xmlDoc" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasXmlDoc {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "xmlDoc" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearXmlDoc() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "sections" field.</summary>
    public const int SectionsFieldNumber = 12;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Section> _repeated_sections_codec
        = pb::FieldCodec.ForMessage(98, global::Edu.Stanford.Nlp.Pipeline.Section.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Section> sections_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Section>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Section> Sections {
      get { return sections_; }
    }

    /// <summary>Field number for the "mentionsForCoref" field.</summary>
    public const int MentionsForCorefFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Mention> _repeated_mentionsForCoref_codec
        = pb::FieldCodec.ForMessage(114, global::Edu.Stanford.Nlp.Pipeline.Mention.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Mention> mentionsForCoref_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Mention>();
    /// <summary>
    ///* coref mentions for entire document *
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Mention> MentionsForCoref {
      get { return mentionsForCoref_; }
    }

    /// <summary>Field number for the "hasCorefMentionAnnotation" field.</summary>
    public const int HasCorefMentionAnnotationFieldNumber = 15;
    private readonly static bool HasCorefMentionAnnotationDefaultValue = false;

    private bool hasCorefMentionAnnotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCorefMentionAnnotation {
      get { if ((_hasBits0 & 8) != 0) { return hasCorefMentionAnnotation_; } else { return HasCorefMentionAnnotationDefaultValue; } }
      set {
        _hasBits0 |= 8;
        hasCorefMentionAnnotation_ = value;
      }
    }
    /// <summary>Gets whether the "hasCorefMentionAnnotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasCorefMentionAnnotation {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "hasCorefMentionAnnotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasCorefMentionAnnotation() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "hasCorefAnnotation" field.</summary>
    public const int HasCorefAnnotationFieldNumber = 16;
    private readonly static bool HasCorefAnnotationDefaultValue = false;

    private bool hasCorefAnnotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCorefAnnotation {
      get { if ((_hasBits0 & 16) != 0) { return hasCorefAnnotation_; } else { return HasCorefAnnotationDefaultValue; } }
      set {
        _hasBits0 |= 16;
        hasCorefAnnotation_ = value;
      }
    }
    /// <summary>Gets whether the "hasCorefAnnotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasCorefAnnotation {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "hasCorefAnnotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasCorefAnnotation() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "corefMentionToEntityMentionMappings" field.</summary>
    public const int CorefMentionToEntityMentionMappingsFieldNumber = 17;
    private static readonly pb::FieldCodec<int> _repeated_corefMentionToEntityMentionMappings_codec
        = pb::FieldCodec.ForInt32(136);
    private readonly pbc::RepeatedField<int> corefMentionToEntityMentionMappings_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> CorefMentionToEntityMentionMappings {
      get { return corefMentionToEntityMentionMappings_; }
    }

    /// <summary>Field number for the "entityMentionToCorefMentionMappings" field.</summary>
    public const int EntityMentionToCorefMentionMappingsFieldNumber = 18;
    private static readonly pb::FieldCodec<int> _repeated_entityMentionToCorefMentionMappings_codec
        = pb::FieldCodec.ForInt32(144);
    private readonly pbc::RepeatedField<int> entityMentionToCorefMentionMappings_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> EntityMentionToCorefMentionMappings {
      get { return entityMentionToCorefMentionMappings_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Document);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Document other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Text != other.Text) return false;
      if(!sentence_.Equals(other.sentence_)) return false;
      if(!corefChain_.Equals(other.corefChain_)) return false;
      if (DocID != other.DocID) return false;
      if (DocDate != other.DocDate) return false;
      if (Calendar != other.Calendar) return false;
      if(!sentencelessToken_.Equals(other.sentencelessToken_)) return false;
      if(!character_.Equals(other.character_)) return false;
      if(!quote_.Equals(other.quote_)) return false;
      if(!mentions_.Equals(other.mentions_)) return false;
      if (HasEntityMentionsAnnotation != other.HasEntityMentionsAnnotation) return false;
      if (XmlDoc != other.XmlDoc) return false;
      if(!sections_.Equals(other.sections_)) return false;
      if(!mentionsForCoref_.Equals(other.mentionsForCoref_)) return false;
      if (HasCorefMentionAnnotation != other.HasCorefMentionAnnotation) return false;
      if (HasCorefAnnotation != other.HasCorefAnnotation) return false;
      if(!corefMentionToEntityMentionMappings_.Equals(other.corefMentionToEntityMentionMappings_)) return false;
      if(!entityMentionToCorefMentionMappings_.Equals(other.entityMentionToCorefMentionMappings_)) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasText) hash ^= Text.GetHashCode();
      hash ^= sentence_.GetHashCode();
      hash ^= corefChain_.GetHashCode();
      if (HasDocID) hash ^= DocID.GetHashCode();
      if (HasDocDate) hash ^= DocDate.GetHashCode();
      if (HasCalendar) hash ^= Calendar.GetHashCode();
      hash ^= sentencelessToken_.GetHashCode();
      hash ^= character_.GetHashCode();
      hash ^= quote_.GetHashCode();
      hash ^= mentions_.GetHashCode();
      if (HasHasEntityMentionsAnnotation) hash ^= HasEntityMentionsAnnotation.GetHashCode();
      if (HasXmlDoc) hash ^= XmlDoc.GetHashCode();
      hash ^= sections_.GetHashCode();
      hash ^= mentionsForCoref_.GetHashCode();
      if (HasHasCorefMentionAnnotation) hash ^= HasCorefMentionAnnotation.GetHashCode();
      if (HasHasCorefAnnotation) hash ^= HasCorefAnnotation.GetHashCode();
      hash ^= corefMentionToEntityMentionMappings_.GetHashCode();
      hash ^= entityMentionToCorefMentionMappings_.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasText) {
        output.WriteRawTag(10);
        output.WriteString(Text);
      }
      sentence_.WriteTo(output, _repeated_sentence_codec);
      corefChain_.WriteTo(output, _repeated_corefChain_codec);
      if (HasDocID) {
        output.WriteRawTag(34);
        output.WriteString(DocID);
      }
      sentencelessToken_.WriteTo(output, _repeated_sentencelessToken_codec);
      quote_.WriteTo(output, _repeated_quote_codec);
      if (HasDocDate) {
        output.WriteRawTag(58);
        output.WriteString(DocDate);
      }
      if (HasCalendar) {
        output.WriteRawTag(64);
        output.WriteUInt64(Calendar);
      }
      mentions_.WriteTo(output, _repeated_mentions_codec);
      character_.WriteTo(output, _repeated_character_codec);
      if (HasXmlDoc) {
        output.WriteRawTag(88);
        output.WriteBool(XmlDoc);
      }
      sections_.WriteTo(output, _repeated_sections_codec);
      if (HasHasEntityMentionsAnnotation) {
        output.WriteRawTag(104);
        output.WriteBool(HasEntityMentionsAnnotation);
      }
      mentionsForCoref_.WriteTo(output, _repeated_mentionsForCoref_codec);
      if (HasHasCorefMentionAnnotation) {
        output.WriteRawTag(120);
        output.WriteBool(HasCorefMentionAnnotation);
      }
      if (HasHasCorefAnnotation) {
        output.WriteRawTag(128, 1);
        output.WriteBool(HasCorefAnnotation);
      }
      corefMentionToEntityMentionMappings_.WriteTo(output, _repeated_corefMentionToEntityMentionMappings_codec);
      entityMentionToCorefMentionMappings_.WriteTo(output, _repeated_entityMentionToCorefMentionMappings_codec);
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasText) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      size += sentence_.CalculateSize(_repeated_sentence_codec);
      size += corefChain_.CalculateSize(_repeated_corefChain_codec);
      if (HasDocID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocID);
      }
      if (HasDocDate) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocDate);
      }
      if (HasCalendar) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Calendar);
      }
      size += sentencelessToken_.CalculateSize(_repeated_sentencelessToken_codec);
      size += character_.CalculateSize(_repeated_character_codec);
      size += quote_.CalculateSize(_repeated_quote_codec);
      size += mentions_.CalculateSize(_repeated_mentions_codec);
      if (HasHasEntityMentionsAnnotation) {
        size += 1 + 1;
      }
      if (HasXmlDoc) {
        size += 1 + 1;
      }
      size += sections_.CalculateSize(_repeated_sections_codec);
      size += mentionsForCoref_.CalculateSize(_repeated_mentionsForCoref_codec);
      if (HasHasCorefMentionAnnotation) {
        size += 1 + 1;
      }
      if (HasHasCorefAnnotation) {
        size += 2 + 1;
      }
      size += corefMentionToEntityMentionMappings_.CalculateSize(_repeated_corefMentionToEntityMentionMappings_codec);
      size += entityMentionToCorefMentionMappings_.CalculateSize(_repeated_entityMentionToCorefMentionMappings_codec);
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Document other) {
      if (other == null) {
        return;
      }
      if (other.HasText) {
        Text = other.Text;
      }
      sentence_.Add(other.sentence_);
      corefChain_.Add(other.corefChain_);
      if (other.HasDocID) {
        DocID = other.DocID;
      }
      if (other.HasDocDate) {
        DocDate = other.DocDate;
      }
      if (other.HasCalendar) {
        Calendar = other.Calendar;
      }
      sentencelessToken_.Add(other.sentencelessToken_);
      character_.Add(other.character_);
      quote_.Add(other.quote_);
      mentions_.Add(other.mentions_);
      if (other.HasHasEntityMentionsAnnotation) {
        HasEntityMentionsAnnotation = other.HasEntityMentionsAnnotation;
      }
      if (other.HasXmlDoc) {
        XmlDoc = other.XmlDoc;
      }
      sections_.Add(other.sections_);
      mentionsForCoref_.Add(other.mentionsForCoref_);
      if (other.HasHasCorefMentionAnnotation) {
        HasCorefMentionAnnotation = other.HasCorefMentionAnnotation;
      }
      if (other.HasHasCorefAnnotation) {
        HasCorefAnnotation = other.HasCorefAnnotation;
      }
      corefMentionToEntityMentionMappings_.Add(other.corefMentionToEntityMentionMappings_);
      entityMentionToCorefMentionMappings_.Add(other.entityMentionToCorefMentionMappings_);
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            Text = input.ReadString();
            break;
          }
          case 18: {
            sentence_.AddEntriesFrom(input, _repeated_sentence_codec);
            break;
          }
          case 26: {
            corefChain_.AddEntriesFrom(input, _repeated_corefChain_codec);
            break;
          }
          case 34: {
            DocID = input.ReadString();
            break;
          }
          case 42: {
            sentencelessToken_.AddEntriesFrom(input, _repeated_sentencelessToken_codec);
            break;
          }
          case 50: {
            quote_.AddEntriesFrom(input, _repeated_quote_codec);
            break;
          }
          case 58: {
            DocDate = input.ReadString();
            break;
          }
          case 64: {
            Calendar = input.ReadUInt64();
            break;
          }
          case 74: {
            mentions_.AddEntriesFrom(input, _repeated_mentions_codec);
            break;
          }
          case 82: {
            character_.AddEntriesFrom(input, _repeated_character_codec);
            break;
          }
          case 88: {
            XmlDoc = input.ReadBool();
            break;
          }
          case 98: {
            sections_.AddEntriesFrom(input, _repeated_sections_codec);
            break;
          }
          case 104: {
            HasEntityMentionsAnnotation = input.ReadBool();
            break;
          }
          case 114: {
            mentionsForCoref_.AddEntriesFrom(input, _repeated_mentionsForCoref_codec);
            break;
          }
          case 120: {
            HasCorefMentionAnnotation = input.ReadBool();
            break;
          }
          case 128: {
            HasCorefAnnotation = input.ReadBool();
            break;
          }
          case 138:
          case 136: {
            corefMentionToEntityMentionMappings_.AddEntriesFrom(input, _repeated_corefMentionToEntityMentionMappings_codec);
            break;
          }
          case 146:
          case 144: {
            entityMentionToCorefMentionMappings_.AddEntriesFrom(input, _repeated_entityMentionToCorefMentionMappings_codec);
            break;
          }
        }
      }
    }

    public TValue GetExtension<TValue>(pb::Extension<Document, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Document, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Document, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<Document, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<Document, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<Document, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<Document, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  ///
  /// The serialized version of a CoreMap representing a sentence.
  /// </summary>
  public sealed partial class Sentence : pb::IExtendableMessage<Sentence> {
    private static readonly pb::MessageParser<Sentence> _parser = new pb::MessageParser<Sentence>(() => new Sentence());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<Sentence> _extensions;
    private pb::ExtensionSet<Sentence> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Sentence> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Sentence() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Sentence(Sentence other) : this() {
      _hasBits0 = other._hasBits0;
      token_ = other.token_.Clone();
      tokenOffsetBegin_ = other.tokenOffsetBegin_;
      tokenOffsetEnd_ = other.tokenOffsetEnd_;
      sentenceIndex_ = other.sentenceIndex_;
      characterOffsetBegin_ = other.characterOffsetBegin_;
      characterOffsetEnd_ = other.characterOffsetEnd_;
      parseTree_ = other.parseTree_ != null ? other.parseTree_.Clone() : null;
      binarizedParseTree_ = other.binarizedParseTree_ != null ? other.binarizedParseTree_.Clone() : null;
      annotatedParseTree_ = other.annotatedParseTree_ != null ? other.annotatedParseTree_.Clone() : null;
      sentiment_ = other.sentiment_;
      kBestParseTrees_ = other.kBestParseTrees_.Clone();
      basicDependencies_ = other.basicDependencies_ != null ? other.basicDependencies_.Clone() : null;
      collapsedDependencies_ = other.collapsedDependencies_ != null ? other.collapsedDependencies_.Clone() : null;
      collapsedCCProcessedDependencies_ = other.collapsedCCProcessedDependencies_ != null ? other.collapsedCCProcessedDependencies_.Clone() : null;
      alternativeDependencies_ = other.alternativeDependencies_ != null ? other.alternativeDependencies_.Clone() : null;
      openieTriple_ = other.openieTriple_.Clone();
      kbpTriple_ = other.kbpTriple_.Clone();
      entailedSentence_ = other.entailedSentence_.Clone();
      entailedClause_ = other.entailedClause_.Clone();
      enhancedDependencies_ = other.enhancedDependencies_ != null ? other.enhancedDependencies_.Clone() : null;
      enhancedPlusPlusDependencies_ = other.enhancedPlusPlusDependencies_ != null ? other.enhancedPlusPlusDependencies_.Clone() : null;
      character_ = other.character_.Clone();
      paragraph_ = other.paragraph_;
      text_ = other.text_;
      lineNumber_ = other.lineNumber_;
      hasRelationAnnotations_ = other.hasRelationAnnotations_;
      entity_ = other.entity_.Clone();
      relation_ = other.relation_.Clone();
      hasNumerizedTokensAnnotation_ = other.hasNumerizedTokensAnnotation_;
      mentions_ = other.mentions_.Clone();
      mentionsForCoref_ = other.mentionsForCoref_.Clone();
      hasCorefMentionsAnnotation_ = other.hasCorefMentionsAnnotation_;
      sentenceID_ = other.sentenceID_;
      sectionDate_ = other.sectionDate_;
      sectionIndex_ = other.sectionIndex_;
      sectionName_ = other.sectionName_;
      sectionAuthor_ = other.sectionAuthor_;
      docID_ = other.docID_;
      sectionQuoted_ = other.sectionQuoted_;
      hasEntityMentionsAnnotation_ = other.hasEntityMentionsAnnotation_;
      hasKBPTriplesAnnotation_ = other.hasKBPTriplesAnnotation_;
      hasOpenieTriplesAnnotation_ = other.hasOpenieTriplesAnnotation_;
      chapterIndex_ = other.chapterIndex_;
      paragraphIndex_ = other.paragraphIndex_;
      enhancedSentence_ = other.enhancedSentence_ != null ? other.enhancedSentence_.Clone() : null;
      speaker_ = other.speaker_;
      speakerType_ = other.speakerType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Sentence Clone() {
      return new Sentence(this);
    }

    /// <summary>Field number for the "token" field.</summary>
    public const int TokenFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Token> _repeated_token_codec
        = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.Token.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> token_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> Token {
      get { return token_; }
    }

    /// <summary>Field number for the "tokenOffsetBegin" field.</summary>
    public const int TokenOffsetBeginFieldNumber = 2;
    private readonly static uint TokenOffsetBeginDefaultValue = 0;

    private uint tokenOffsetBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenOffsetBegin {
      get { if ((_hasBits0 & 1) != 0) { return tokenOffsetBegin_; } else { return TokenOffsetBeginDefaultValue; } }
      set {
        _hasBits0 |= 1;
        tokenOffsetBegin_ = value;
      }
    }
    /// <summary>Gets whether the "tokenOffsetBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenOffsetBegin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "tokenOffsetBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenOffsetBegin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "tokenOffsetEnd" field.</summary>
    public const int TokenOffsetEndFieldNumber = 3;
    private readonly static uint TokenOffsetEndDefaultValue = 0;

    private uint tokenOffsetEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenOffsetEnd {
      get { if ((_hasBits0 & 2) != 0) { return tokenOffsetEnd_; } else { return TokenOffsetEndDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tokenOffsetEnd_ = value;
      }
    }
    /// <summary>Gets whether the "tokenOffsetEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenOffsetEnd {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tokenOffsetEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenOffsetEnd() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "sentenceIndex" field.</summary>
    public const int SentenceIndexFieldNumber = 4;
    private readonly static uint SentenceIndexDefaultValue = 0;

    private uint sentenceIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SentenceIndex {
      get { if ((_hasBits0 & 4) != 0) { return sentenceIndex_; } else { return SentenceIndexDefaultValue; } }
      set {
        _hasBits0 |= 4;
        sentenceIndex_ = value;
      }
    }
    /// <summary>Gets whether the "sentenceIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentenceIndex {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "sentenceIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentenceIndex() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "characterOffsetBegin" field.</summary>
    public const int CharacterOffsetBeginFieldNumber = 5;
    private readonly static uint CharacterOffsetBeginDefaultValue = 0;

    private uint characterOffsetBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CharacterOffsetBegin {
      get { if ((_hasBits0 & 8) != 0) { return characterOffsetBegin_; } else { return CharacterOffsetBeginDefaultValue; } }
      set {
        _hasBits0 |= 8;
        characterOffsetBegin_ = value;
      }
    }
    /// <summary>Gets whether the "characterOffsetBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCharacterOffsetBegin {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "characterOffsetBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCharacterOffsetBegin() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "characterOffsetEnd" field.</summary>
    public const int CharacterOffsetEndFieldNumber = 6;
    private readonly static uint CharacterOffsetEndDefaultValue = 0;

    private uint characterOffsetEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CharacterOffsetEnd {
      get { if ((_hasBits0 & 16) != 0) { return characterOffsetEnd_; } else { return CharacterOffsetEndDefaultValue; } }
      set {
        _hasBits0 |= 16;
        characterOffsetEnd_ = value;
      }
    }
    /// <summary>Gets whether the "characterOffsetEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCharacterOffsetEnd {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "characterOffsetEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCharacterOffsetEnd() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "parseTree" field.</summary>
    public const int ParseTreeFieldNumber = 7;
    private global::Edu.Stanford.Nlp.Pipeline.ParseTree parseTree_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.ParseTree ParseTree {
      get { return parseTree_; }
      set {
        parseTree_ = value;
      }
    }

    /// <summary>Field number for the "binarizedParseTree" field.</summary>
    public const int BinarizedParseTreeFieldNumber = 31;
    private global::Edu.Stanford.Nlp.Pipeline.ParseTree binarizedParseTree_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.ParseTree BinarizedParseTree {
      get { return binarizedParseTree_; }
      set {
        binarizedParseTree_ = value;
      }
    }

    /// <summary>Field number for the "annotatedParseTree" field.</summary>
    public const int AnnotatedParseTreeFieldNumber = 32;
    private global::Edu.Stanford.Nlp.Pipeline.ParseTree annotatedParseTree_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.ParseTree AnnotatedParseTree {
      get { return annotatedParseTree_; }
      set {
        annotatedParseTree_ = value;
      }
    }

    /// <summary>Field number for the "sentiment" field.</summary>
    public const int SentimentFieldNumber = 33;
    private readonly static string SentimentDefaultValue = "";

    private string sentiment_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Sentiment {
      get { return sentiment_ ?? SentimentDefaultValue; }
      set {
        sentiment_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sentiment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentiment {
      get { return sentiment_ != null; }
    }
    /// <summary>Clears the value of the "sentiment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentiment() {
      sentiment_ = null;
    }

    /// <summary>Field number for the "kBestParseTrees" field.</summary>
    public const int KBestParseTreesFieldNumber = 34;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.ParseTree> _repeated_kBestParseTrees_codec
        = pb::FieldCodec.ForMessage(274, global::Edu.Stanford.Nlp.Pipeline.ParseTree.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.ParseTree> kBestParseTrees_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.ParseTree>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.ParseTree> KBestParseTrees {
      get { return kBestParseTrees_; }
    }

    /// <summary>Field number for the "basicDependencies" field.</summary>
    public const int BasicDependenciesFieldNumber = 8;
    private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph basicDependencies_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph BasicDependencies {
      get { return basicDependencies_; }
      set {
        basicDependencies_ = value;
      }
    }

    /// <summary>Field number for the "collapsedDependencies" field.</summary>
    public const int CollapsedDependenciesFieldNumber = 9;
    private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph collapsedDependencies_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph CollapsedDependencies {
      get { return collapsedDependencies_; }
      set {
        collapsedDependencies_ = value;
      }
    }

    /// <summary>Field number for the "collapsedCCProcessedDependencies" field.</summary>
    public const int CollapsedCCProcessedDependenciesFieldNumber = 10;
    private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph collapsedCCProcessedDependencies_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph CollapsedCCProcessedDependencies {
      get { return collapsedCCProcessedDependencies_; }
      set {
        collapsedCCProcessedDependencies_ = value;
      }
    }

    /// <summary>Field number for the "alternativeDependencies" field.</summary>
    public const int AlternativeDependenciesFieldNumber = 13;
    private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph alternativeDependencies_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph AlternativeDependencies {
      get { return alternativeDependencies_; }
      set {
        alternativeDependencies_ = value;
      }
    }

    /// <summary>Field number for the "openieTriple" field.</summary>
    public const int OpenieTripleFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.RelationTriple> _repeated_openieTriple_codec
        = pb::FieldCodec.ForMessage(114, global::Edu.Stanford.Nlp.Pipeline.RelationTriple.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.RelationTriple> openieTriple_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.RelationTriple>();
    /// <summary>
    /// The OpenIE triples in the sentence
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.RelationTriple> OpenieTriple {
      get { return openieTriple_; }
    }

    /// <summary>Field number for the "kbpTriple" field.</summary>
    public const int KbpTripleFieldNumber = 16;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.RelationTriple> _repeated_kbpTriple_codec
        = pb::FieldCodec.ForMessage(130, global::Edu.Stanford.Nlp.Pipeline.RelationTriple.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.RelationTriple> kbpTriple_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.RelationTriple>();
    /// <summary>
    /// The KBP triples in this sentence
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.RelationTriple> KbpTriple {
      get { return kbpTriple_; }
    }

    /// <summary>Field number for the "entailedSentence" field.</summary>
    public const int EntailedSentenceFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.SentenceFragment> _repeated_entailedSentence_codec
        = pb::FieldCodec.ForMessage(122, global::Edu.Stanford.Nlp.Pipeline.SentenceFragment.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SentenceFragment> entailedSentence_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SentenceFragment>();
    /// <summary>
    /// The entailed sentences, by natural logic
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SentenceFragment> EntailedSentence {
      get { return entailedSentence_; }
    }

    /// <summary>Field number for the "entailedClause" field.</summary>
    public const int EntailedClauseFieldNumber = 35;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.SentenceFragment> _repeated_entailedClause_codec
        = pb::FieldCodec.ForMessage(282, global::Edu.Stanford.Nlp.Pipeline.SentenceFragment.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SentenceFragment> entailedClause_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SentenceFragment>();
    /// <summary>
    /// The entailed clauses, by natural logic
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SentenceFragment> EntailedClause {
      get { return entailedClause_; }
    }

    /// <summary>Field number for the "enhancedDependencies" field.</summary>
    public const int EnhancedDependenciesFieldNumber = 17;
    private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph enhancedDependencies_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph EnhancedDependencies {
      get { return enhancedDependencies_; }
      set {
        enhancedDependencies_ = value;
      }
    }

    /// <summary>Field number for the "enhancedPlusPlusDependencies" field.</summary>
    public const int EnhancedPlusPlusDependenciesFieldNumber = 18;
    private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph enhancedPlusPlusDependencies_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph EnhancedPlusPlusDependencies {
      get { return enhancedPlusPlusDependencies_; }
      set {
        enhancedPlusPlusDependencies_ = value;
      }
    }

    /// <summary>Field number for the "character" field.</summary>
    public const int CharacterFieldNumber = 19;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Token> _repeated_character_codec
        = pb::FieldCodec.ForMessage(154, global::Edu.Stanford.Nlp.Pipeline.Token.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> character_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> Character {
      get { return character_; }
    }

    /// <summary>Field number for the "paragraph" field.</summary>
    public const int ParagraphFieldNumber = 11;
    private readonly static uint ParagraphDefaultValue = 0;

    private uint paragraph_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Paragraph {
      get { if ((_hasBits0 & 32) != 0) { return paragraph_; } else { return ParagraphDefaultValue; } }
      set {
        _hasBits0 |= 32;
        paragraph_ = value;
      }
    }
    /// <summary>Gets whether the "paragraph" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasParagraph {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "paragraph" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearParagraph() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 12;
    private readonly static string TextDefaultValue = "";

    private string text_;
    /// <summary>
    /// Only needed if we're only saving the sentence.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Text {
      get { return text_ ?? TextDefaultValue; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasText {
      get { return text_ != null; }
    }
    /// <summary>Clears the value of the "text" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearText() {
      text_ = null;
    }

    /// <summary>Field number for the "lineNumber" field.</summary>
    public const int LineNumberFieldNumber = 20;
    private readonly static uint LineNumberDefaultValue = 0;

    private uint lineNumber_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint LineNumber {
      get { if ((_hasBits0 & 64) != 0) { return lineNumber_; } else { return LineNumberDefaultValue; } }
      set {
        _hasBits0 |= 64;
        lineNumber_ = value;
      }
    }
    /// <summary>Gets whether the "lineNumber" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLineNumber {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "lineNumber" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLineNumber() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "hasRelationAnnotations" field.</summary>
    public const int HasRelationAnnotationsFieldNumber = 51;
    private readonly static bool HasRelationAnnotationsDefaultValue = false;

    private bool hasRelationAnnotations_;
    /// <summary>
    /// Fields set by other annotators in CoreNLP
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRelationAnnotations {
      get { if ((_hasBits0 & 128) != 0) { return hasRelationAnnotations_; } else { return HasRelationAnnotationsDefaultValue; } }
      set {
        _hasBits0 |= 128;
        hasRelationAnnotations_ = value;
      }
    }
    /// <summary>Gets whether the "hasRelationAnnotations" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasRelationAnnotations {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "hasRelationAnnotations" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasRelationAnnotations() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "entity" field.</summary>
    public const int EntityFieldNumber = 52;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Entity> _repeated_entity_codec
        = pb::FieldCodec.ForMessage(418, global::Edu.Stanford.Nlp.Pipeline.Entity.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Entity> entity_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Entity>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Entity> Entity {
      get { return entity_; }
    }

    /// <summary>Field number for the "relation" field.</summary>
    public const int RelationFieldNumber = 53;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Relation> _repeated_relation_codec
        = pb::FieldCodec.ForMessage(426, global::Edu.Stanford.Nlp.Pipeline.Relation.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Relation> relation_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Relation>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Relation> Relation {
      get { return relation_; }
    }

    /// <summary>Field number for the "hasNumerizedTokensAnnotation" field.</summary>
    public const int HasNumerizedTokensAnnotationFieldNumber = 54;
    private readonly static bool HasNumerizedTokensAnnotationDefaultValue = false;

    private bool hasNumerizedTokensAnnotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNumerizedTokensAnnotation {
      get { if ((_hasBits0 & 256) != 0) { return hasNumerizedTokensAnnotation_; } else { return HasNumerizedTokensAnnotationDefaultValue; } }
      set {
        _hasBits0 |= 256;
        hasNumerizedTokensAnnotation_ = value;
      }
    }
    /// <summary>Gets whether the "hasNumerizedTokensAnnotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasNumerizedTokensAnnotation {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "hasNumerizedTokensAnnotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasNumerizedTokensAnnotation() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "mentions" field.</summary>
    public const int MentionsFieldNumber = 55;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.NERMention> _repeated_mentions_codec
        = pb::FieldCodec.ForMessage(442, global::Edu.Stanford.Nlp.Pipeline.NERMention.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.NERMention> mentions_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.NERMention>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.NERMention> Mentions {
      get { return mentions_; }
    }

    /// <summary>Field number for the "mentionsForCoref" field.</summary>
    public const int MentionsForCorefFieldNumber = 56;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Mention> _repeated_mentionsForCoref_codec
        = pb::FieldCodec.ForMessage(450, global::Edu.Stanford.Nlp.Pipeline.Mention.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Mention> mentionsForCoref_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Mention>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Mention> MentionsForCoref {
      get { return mentionsForCoref_; }
    }

    /// <summary>Field number for the "hasCorefMentionsAnnotation" field.</summary>
    public const int HasCorefMentionsAnnotationFieldNumber = 57;
    private readonly static bool HasCorefMentionsAnnotationDefaultValue = false;

    private bool hasCorefMentionsAnnotation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCorefMentionsAnnotation {
      get { if ((_hasBits0 & 512) != 0) { return hasCorefMentionsAnnotation_; } else { return HasCorefMentionsAnnotationDefaultValue; } }
      set {
        _hasBits0 |= 512;
        hasCorefMentionsAnnotation_ = value;
      }
    }
    /// <summary>Gets whether the "hasCorefMentionsAnnotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasCorefMentionsAnnotation {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "hasCorefMentionsAnnotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasCorefMentionsAnnotation() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "sentenceID" field.</summary>
    public const int SentenceIDFieldNumber = 58;
    private readonly static string SentenceIDDefaultValue = "";

    private string sentenceID_;
    /// <summary>
    /// Useful when storing sentences (e.g. ForEach)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SentenceID {
      get { return sentenceID_ ?? SentenceIDDefaultValue; }
      set {
        sentenceID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sentenceID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentenceID {
      get { return sentenceID_ != null; }
    }
    /// <summary>Clears the value of the "sentenceID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentenceID() {
      sentenceID_ = null;
    }

    /// <summary>Field number for the "sectionDate" field.</summary>
    public const int SectionDateFieldNumber = 59;
    private readonly static string SectionDateDefaultValue = "";

    private string sectionDate_;
    /// <summary>
    /// date of section
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SectionDate {
      get { return sectionDate_ ?? SectionDateDefaultValue; }
      set {
        sectionDate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sectionDate" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionDate {
      get { return sectionDate_ != null; }
    }
    /// <summary>Clears the value of the "sectionDate" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionDate() {
      sectionDate_ = null;
    }

    /// <summary>Field number for the "sectionIndex" field.</summary>
    public const int SectionIndexFieldNumber = 60;
    private readonly static uint SectionIndexDefaultValue = 0;

    private uint sectionIndex_;
    /// <summary>
    /// section index for this sentence's section
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SectionIndex {
      get { if ((_hasBits0 & 1024) != 0) { return sectionIndex_; } else { return SectionIndexDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        sectionIndex_ = value;
      }
    }
    /// <summary>Gets whether the "sectionIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionIndex {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "sectionIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionIndex() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "sectionName" field.</summary>
    public const int SectionNameFieldNumber = 61;
    private readonly static string SectionNameDefaultValue = "";

    private string sectionName_;
    /// <summary>
    /// name of section
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SectionName {
      get { return sectionName_ ?? SectionNameDefaultValue; }
      set {
        sectionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sectionName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionName {
      get { return sectionName_ != null; }
    }
    /// <summary>Clears the value of the "sectionName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionName() {
      sectionName_ = null;
    }

    /// <summary>Field number for the "sectionAuthor" field.</summary>
    public const int SectionAuthorFieldNumber = 62;
    private readonly static string SectionAuthorDefaultValue = "";

    private string sectionAuthor_;
    /// <summary>
    /// author of section
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SectionAuthor {
      get { return sectionAuthor_ ?? SectionAuthorDefaultValue; }
      set {
        sectionAuthor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sectionAuthor" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionAuthor {
      get { return sectionAuthor_ != null; }
    }
    /// <summary>Clears the value of the "sectionAuthor" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionAuthor() {
      sectionAuthor_ = null;
    }

    /// <summary>Field number for the "docID" field.</summary>
    public const int DocIDFieldNumber = 63;
    private readonly static string DocIDDefaultValue = "";

    private string docID_;
    /// <summary>
    /// doc id
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocID {
      get { return docID_ ?? DocIDDefaultValue; }
      set {
        docID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "docID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDocID {
      get { return docID_ != null; }
    }
    /// <summary>Clears the value of the "docID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDocID() {
      docID_ = null;
    }

    /// <summary>Field number for the "sectionQuoted" field.</summary>
    public const int SectionQuotedFieldNumber = 64;
    private readonly static bool SectionQuotedDefaultValue = false;

    private bool sectionQuoted_;
    /// <summary>
    /// is this sentence in an xml quote in a post
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SectionQuoted {
      get { if ((_hasBits0 & 2048) != 0) { return sectionQuoted_; } else { return SectionQuotedDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        sectionQuoted_ = value;
      }
    }
    /// <summary>Gets whether the "sectionQuoted" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionQuoted {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "sectionQuoted" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionQuoted() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "hasEntityMentionsAnnotation" field.</summary>
    public const int HasEntityMentionsAnnotationFieldNumber = 65;
    private readonly static bool HasEntityMentionsAnnotationDefaultValue = false;

    private bool hasEntityMentionsAnnotation_;
    /// <summary>
    /// check if there are entity mentions
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEntityMentionsAnnotation {
      get { if ((_hasBits0 & 4096) != 0) { return hasEntityMentionsAnnotation_; } else { return HasEntityMentionsAnnotationDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        hasEntityMentionsAnnotation_ = value;
      }
    }
    /// <summary>Gets whether the "hasEntityMentionsAnnotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasEntityMentionsAnnotation {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "hasEntityMentionsAnnotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasEntityMentionsAnnotation() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "hasKBPTriplesAnnotation" field.</summary>
    public const int HasKBPTriplesAnnotationFieldNumber = 68;
    private readonly static bool HasKBPTriplesAnnotationDefaultValue = false;

    private bool hasKBPTriplesAnnotation_;
    /// <summary>
    /// check if there are KBP triples
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasKBPTriplesAnnotation {
      get { if ((_hasBits0 & 32768) != 0) { return hasKBPTriplesAnnotation_; } else { return HasKBPTriplesAnnotationDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        hasKBPTriplesAnnotation_ = value;
      }
    }
    /// <summary>Gets whether the "hasKBPTriplesAnnotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasKBPTriplesAnnotation {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "hasKBPTriplesAnnotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasKBPTriplesAnnotation() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "hasOpenieTriplesAnnotation" field.</summary>
    public const int HasOpenieTriplesAnnotationFieldNumber = 69;
    private readonly static bool HasOpenieTriplesAnnotationDefaultValue = false;

    private bool hasOpenieTriplesAnnotation_;
    /// <summary>
    /// check if there are OpenIE triples
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOpenieTriplesAnnotation {
      get { if ((_hasBits0 & 65536) != 0) { return hasOpenieTriplesAnnotation_; } else { return HasOpenieTriplesAnnotationDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        hasOpenieTriplesAnnotation_ = value;
      }
    }
    /// <summary>Gets whether the "hasOpenieTriplesAnnotation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasOpenieTriplesAnnotation {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "hasOpenieTriplesAnnotation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasOpenieTriplesAnnotation() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "chapterIndex" field.</summary>
    public const int ChapterIndexFieldNumber = 66;
    private readonly static uint ChapterIndexDefaultValue = 0;

    private uint chapterIndex_;
    /// <summary>
    /// quote stuff
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ChapterIndex {
      get { if ((_hasBits0 & 8192) != 0) { return chapterIndex_; } else { return ChapterIndexDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        chapterIndex_ = value;
      }
    }
    /// <summary>Gets whether the "chapterIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasChapterIndex {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "chapterIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearChapterIndex() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "paragraphIndex" field.</summary>
    public const int ParagraphIndexFieldNumber = 67;
    private readonly static uint ParagraphIndexDefaultValue = 0;

    private uint paragraphIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ParagraphIndex {
      get { if ((_hasBits0 & 16384) != 0) { return paragraphIndex_; } else { return ParagraphIndexDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        paragraphIndex_ = value;
      }
    }
    /// <summary>Gets whether the "paragraphIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasParagraphIndex {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "paragraphIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearParagraphIndex() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "enhancedSentence" field.</summary>
    public const int EnhancedSentenceFieldNumber = 70;
    private global::Edu.Stanford.Nlp.Pipeline.Sentence enhancedSentence_;
    /// <summary>
    /// the quote annotator can soometimes add merged sentences
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Sentence EnhancedSentence {
      get { return enhancedSentence_; }
      set {
        enhancedSentence_ = value;
      }
    }

    /// <summary>Field number for the "speaker" field.</summary>
    public const int SpeakerFieldNumber = 71;
    private readonly static string SpeakerDefaultValue = "";

    private string speaker_;
    /// <summary>
    /// speaker stuff
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Speaker {
      get { return speaker_ ?? SpeakerDefaultValue; }
      set {
        speaker_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "speaker" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeaker {
      get { return speaker_ != null; }
    }
    /// <summary>Clears the value of the "speaker" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeaker() {
      speaker_ = null;
    }

    /// <summary>Field number for the "speakerType" field.</summary>
    public const int SpeakerTypeFieldNumber = 72;
    private readonly static string SpeakerTypeDefaultValue = "";

    private string speakerType_;
    /// <summary>
    /// The type of speaker speaking this sentence
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SpeakerType {
      get { return speakerType_ ?? SpeakerTypeDefaultValue; }
      set {
        speakerType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "speakerType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeakerType {
      get { return speakerType_ != null; }
    }
    /// <summary>Clears the value of the "speakerType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeakerType() {
      speakerType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Sentence);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Sentence other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!token_.Equals(other.token_)) return false;
      if (TokenOffsetBegin != other.TokenOffsetBegin) return false;
      if (TokenOffsetEnd != other.TokenOffsetEnd) return false;
      if (SentenceIndex != other.SentenceIndex) return false;
      if (CharacterOffsetBegin != other.CharacterOffsetBegin) return false;
      if (CharacterOffsetEnd != other.CharacterOffsetEnd) return false;
      if (!object.Equals(ParseTree, other.ParseTree)) return false;
      if (!object.Equals(BinarizedParseTree, other.BinarizedParseTree)) return false;
      if (!object.Equals(AnnotatedParseTree, other.AnnotatedParseTree)) return false;
      if (Sentiment != other.Sentiment) return false;
      if(!kBestParseTrees_.Equals(other.kBestParseTrees_)) return false;
      if (!object.Equals(BasicDependencies, other.BasicDependencies)) return false;
      if (!object.Equals(CollapsedDependencies, other.CollapsedDependencies)) return false;
      if (!object.Equals(CollapsedCCProcessedDependencies, other.CollapsedCCProcessedDependencies)) return false;
      if (!object.Equals(AlternativeDependencies, other.AlternativeDependencies)) return false;
      if(!openieTriple_.Equals(other.openieTriple_)) return false;
      if(!kbpTriple_.Equals(other.kbpTriple_)) return false;
      if(!entailedSentence_.Equals(other.entailedSentence_)) return false;
      if(!entailedClause_.Equals(other.entailedClause_)) return false;
      if (!object.Equals(EnhancedDependencies, other.EnhancedDependencies)) return false;
      if (!object.Equals(EnhancedPlusPlusDependencies, other.EnhancedPlusPlusDependencies)) return false;
      if(!character_.Equals(other.character_)) return false;
      if (Paragraph != other.Paragraph) return false;
      if (Text != other.Text) return false;
      if (LineNumber != other.LineNumber) return false;
      if (HasRelationAnnotations != other.HasRelationAnnotations) return false;
      if(!entity_.Equals(other.entity_)) return false;
      if(!relation_.Equals(other.relation_)) return false;
      if (HasNumerizedTokensAnnotation != other.HasNumerizedTokensAnnotation) return false;
      if(!mentions_.Equals(other.mentions_)) return false;
      if(!mentionsForCoref_.Equals(other.mentionsForCoref_)) return false;
      if (HasCorefMentionsAnnotation != other.HasCorefMentionsAnnotation) return false;
      if (SentenceID != other.SentenceID) return false;
      if (SectionDate != other.SectionDate) return false;
      if (SectionIndex != other.SectionIndex) return false;
      if (SectionName != other.SectionName) return false;
      if (SectionAuthor != other.SectionAuthor) return false;
      if (DocID != other.DocID) return false;
      if (SectionQuoted != other.SectionQuoted) return false;
      if (HasEntityMentionsAnnotation != other.HasEntityMentionsAnnotation) return false;
      if (HasKBPTriplesAnnotation != other.HasKBPTriplesAnnotation) return false;
      if (HasOpenieTriplesAnnotation != other.HasOpenieTriplesAnnotation) return false;
      if (ChapterIndex != other.ChapterIndex) return false;
      if (ParagraphIndex != other.ParagraphIndex) return false;
      if (!object.Equals(EnhancedSentence, other.EnhancedSentence)) return false;
      if (Speaker != other.Speaker) return false;
      if (SpeakerType != other.SpeakerType) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= token_.GetHashCode();
      if (HasTokenOffsetBegin) hash ^= TokenOffsetBegin.GetHashCode();
      if (HasTokenOffsetEnd) hash ^= TokenOffsetEnd.GetHashCode();
      if (HasSentenceIndex) hash ^= SentenceIndex.GetHashCode();
      if (HasCharacterOffsetBegin) hash ^= CharacterOffsetBegin.GetHashCode();
      if (HasCharacterOffsetEnd) hash ^= CharacterOffsetEnd.GetHashCode();
      if (parseTree_ != null) hash ^= ParseTree.GetHashCode();
      if (binarizedParseTree_ != null) hash ^= BinarizedParseTree.GetHashCode();
      if (annotatedParseTree_ != null) hash ^= AnnotatedParseTree.GetHashCode();
      if (HasSentiment) hash ^= Sentiment.GetHashCode();
      hash ^= kBestParseTrees_.GetHashCode();
      if (basicDependencies_ != null) hash ^= BasicDependencies.GetHashCode();
      if (collapsedDependencies_ != null) hash ^= CollapsedDependencies.GetHashCode();
      if (collapsedCCProcessedDependencies_ != null) hash ^= CollapsedCCProcessedDependencies.GetHashCode();
      if (alternativeDependencies_ != null) hash ^= AlternativeDependencies.GetHashCode();
      hash ^= openieTriple_.GetHashCode();
      hash ^= kbpTriple_.GetHashCode();
      hash ^= entailedSentence_.GetHashCode();
      hash ^= entailedClause_.GetHashCode();
      if (enhancedDependencies_ != null) hash ^= EnhancedDependencies.GetHashCode();
      if (enhancedPlusPlusDependencies_ != null) hash ^= EnhancedPlusPlusDependencies.GetHashCode();
      hash ^= character_.GetHashCode();
      if (HasParagraph) hash ^= Paragraph.GetHashCode();
      if (HasText) hash ^= Text.GetHashCode();
      if (HasLineNumber) hash ^= LineNumber.GetHashCode();
      if (HasHasRelationAnnotations) hash ^= HasRelationAnnotations.GetHashCode();
      hash ^= entity_.GetHashCode();
      hash ^= relation_.GetHashCode();
      if (HasHasNumerizedTokensAnnotation) hash ^= HasNumerizedTokensAnnotation.GetHashCode();
      hash ^= mentions_.GetHashCode();
      hash ^= mentionsForCoref_.GetHashCode();
      if (HasHasCorefMentionsAnnotation) hash ^= HasCorefMentionsAnnotation.GetHashCode();
      if (HasSentenceID) hash ^= SentenceID.GetHashCode();
      if (HasSectionDate) hash ^= SectionDate.GetHashCode();
      if (HasSectionIndex) hash ^= SectionIndex.GetHashCode();
      if (HasSectionName) hash ^= SectionName.GetHashCode();
      if (HasSectionAuthor) hash ^= SectionAuthor.GetHashCode();
      if (HasDocID) hash ^= DocID.GetHashCode();
      if (HasSectionQuoted) hash ^= SectionQuoted.GetHashCode();
      if (HasHasEntityMentionsAnnotation) hash ^= HasEntityMentionsAnnotation.GetHashCode();
      if (HasHasKBPTriplesAnnotation) hash ^= HasKBPTriplesAnnotation.GetHashCode();
      if (HasHasOpenieTriplesAnnotation) hash ^= HasOpenieTriplesAnnotation.GetHashCode();
      if (HasChapterIndex) hash ^= ChapterIndex.GetHashCode();
      if (HasParagraphIndex) hash ^= ParagraphIndex.GetHashCode();
      if (enhancedSentence_ != null) hash ^= EnhancedSentence.GetHashCode();
      if (HasSpeaker) hash ^= Speaker.GetHashCode();
      if (HasSpeakerType) hash ^= SpeakerType.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      token_.WriteTo(output, _repeated_token_codec);
      if (HasTokenOffsetBegin) {
        output.WriteRawTag(16);
        output.WriteUInt32(TokenOffsetBegin);
      }
      if (HasTokenOffsetEnd) {
        output.WriteRawTag(24);
        output.WriteUInt32(TokenOffsetEnd);
      }
      if (HasSentenceIndex) {
        output.WriteRawTag(32);
        output.WriteUInt32(SentenceIndex);
      }
      if (HasCharacterOffsetBegin) {
        output.WriteRawTag(40);
        output.WriteUInt32(CharacterOffsetBegin);
      }
      if (HasCharacterOffsetEnd) {
        output.WriteRawTag(48);
        output.WriteUInt32(CharacterOffsetEnd);
      }
      if (parseTree_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(ParseTree);
      }
      if (basicDependencies_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(BasicDependencies);
      }
      if (collapsedDependencies_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(CollapsedDependencies);
      }
      if (collapsedCCProcessedDependencies_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CollapsedCCProcessedDependencies);
      }
      if (HasParagraph) {
        output.WriteRawTag(88);
        output.WriteUInt32(Paragraph);
      }
      if (HasText) {
        output.WriteRawTag(98);
        output.WriteString(Text);
      }
      if (alternativeDependencies_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(AlternativeDependencies);
      }
      openieTriple_.WriteTo(output, _repeated_openieTriple_codec);
      entailedSentence_.WriteTo(output, _repeated_entailedSentence_codec);
      kbpTriple_.WriteTo(output, _repeated_kbpTriple_codec);
      if (enhancedDependencies_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(EnhancedDependencies);
      }
      if (enhancedPlusPlusDependencies_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(EnhancedPlusPlusDependencies);
      }
      character_.WriteTo(output, _repeated_character_codec);
      if (HasLineNumber) {
        output.WriteRawTag(160, 1);
        output.WriteUInt32(LineNumber);
      }
      if (binarizedParseTree_ != null) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(BinarizedParseTree);
      }
      if (annotatedParseTree_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(AnnotatedParseTree);
      }
      if (HasSentiment) {
        output.WriteRawTag(138, 2);
        output.WriteString(Sentiment);
      }
      kBestParseTrees_.WriteTo(output, _repeated_kBestParseTrees_codec);
      entailedClause_.WriteTo(output, _repeated_entailedClause_codec);
      if (HasHasRelationAnnotations) {
        output.WriteRawTag(152, 3);
        output.WriteBool(HasRelationAnnotations);
      }
      entity_.WriteTo(output, _repeated_entity_codec);
      relation_.WriteTo(output, _repeated_relation_codec);
      if (HasHasNumerizedTokensAnnotation) {
        output.WriteRawTag(176, 3);
        output.WriteBool(HasNumerizedTokensAnnotation);
      }
      mentions_.WriteTo(output, _repeated_mentions_codec);
      mentionsForCoref_.WriteTo(output, _repeated_mentionsForCoref_codec);
      if (HasHasCorefMentionsAnnotation) {
        output.WriteRawTag(200, 3);
        output.WriteBool(HasCorefMentionsAnnotation);
      }
      if (HasSentenceID) {
        output.WriteRawTag(210, 3);
        output.WriteString(SentenceID);
      }
      if (HasSectionDate) {
        output.WriteRawTag(218, 3);
        output.WriteString(SectionDate);
      }
      if (HasSectionIndex) {
        output.WriteRawTag(224, 3);
        output.WriteUInt32(SectionIndex);
      }
      if (HasSectionName) {
        output.WriteRawTag(234, 3);
        output.WriteString(SectionName);
      }
      if (HasSectionAuthor) {
        output.WriteRawTag(242, 3);
        output.WriteString(SectionAuthor);
      }
      if (HasDocID) {
        output.WriteRawTag(250, 3);
        output.WriteString(DocID);
      }
      if (HasSectionQuoted) {
        output.WriteRawTag(128, 4);
        output.WriteBool(SectionQuoted);
      }
      if (HasHasEntityMentionsAnnotation) {
        output.WriteRawTag(136, 4);
        output.WriteBool(HasEntityMentionsAnnotation);
      }
      if (HasChapterIndex) {
        output.WriteRawTag(144, 4);
        output.WriteUInt32(ChapterIndex);
      }
      if (HasParagraphIndex) {
        output.WriteRawTag(152, 4);
        output.WriteUInt32(ParagraphIndex);
      }
      if (HasHasKBPTriplesAnnotation) {
        output.WriteRawTag(160, 4);
        output.WriteBool(HasKBPTriplesAnnotation);
      }
      if (HasHasOpenieTriplesAnnotation) {
        output.WriteRawTag(168, 4);
        output.WriteBool(HasOpenieTriplesAnnotation);
      }
      if (enhancedSentence_ != null) {
        output.WriteRawTag(178, 4);
        output.WriteMessage(EnhancedSentence);
      }
      if (HasSpeaker) {
        output.WriteRawTag(186, 4);
        output.WriteString(Speaker);
      }
      if (HasSpeakerType) {
        output.WriteRawTag(194, 4);
        output.WriteString(SpeakerType);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += token_.CalculateSize(_repeated_token_codec);
      if (HasTokenOffsetBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TokenOffsetBegin);
      }
      if (HasTokenOffsetEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TokenOffsetEnd);
      }
      if (HasSentenceIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SentenceIndex);
      }
      if (HasCharacterOffsetBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CharacterOffsetBegin);
      }
      if (HasCharacterOffsetEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CharacterOffsetEnd);
      }
      if (parseTree_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ParseTree);
      }
      if (binarizedParseTree_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(BinarizedParseTree);
      }
      if (annotatedParseTree_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AnnotatedParseTree);
      }
      if (HasSentiment) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Sentiment);
      }
      size += kBestParseTrees_.CalculateSize(_repeated_kBestParseTrees_codec);
      if (basicDependencies_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BasicDependencies);
      }
      if (collapsedDependencies_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CollapsedDependencies);
      }
      if (collapsedCCProcessedDependencies_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CollapsedCCProcessedDependencies);
      }
      if (alternativeDependencies_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AlternativeDependencies);
      }
      size += openieTriple_.CalculateSize(_repeated_openieTriple_codec);
      size += kbpTriple_.CalculateSize(_repeated_kbpTriple_codec);
      size += entailedSentence_.CalculateSize(_repeated_entailedSentence_codec);
      size += entailedClause_.CalculateSize(_repeated_entailedClause_codec);
      if (enhancedDependencies_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(EnhancedDependencies);
      }
      if (enhancedPlusPlusDependencies_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(EnhancedPlusPlusDependencies);
      }
      size += character_.CalculateSize(_repeated_character_codec);
      if (HasParagraph) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Paragraph);
      }
      if (HasText) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (HasLineNumber) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(LineNumber);
      }
      if (HasHasRelationAnnotations) {
        size += 2 + 1;
      }
      size += entity_.CalculateSize(_repeated_entity_codec);
      size += relation_.CalculateSize(_repeated_relation_codec);
      if (HasHasNumerizedTokensAnnotation) {
        size += 2 + 1;
      }
      size += mentions_.CalculateSize(_repeated_mentions_codec);
      size += mentionsForCoref_.CalculateSize(_repeated_mentionsForCoref_codec);
      if (HasHasCorefMentionsAnnotation) {
        size += 2 + 1;
      }
      if (HasSentenceID) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SentenceID);
      }
      if (HasSectionDate) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SectionDate);
      }
      if (HasSectionIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(SectionIndex);
      }
      if (HasSectionName) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SectionName);
      }
      if (HasSectionAuthor) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SectionAuthor);
      }
      if (HasDocID) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(DocID);
      }
      if (HasSectionQuoted) {
        size += 2 + 1;
      }
      if (HasHasEntityMentionsAnnotation) {
        size += 2 + 1;
      }
      if (HasHasKBPTriplesAnnotation) {
        size += 2 + 1;
      }
      if (HasHasOpenieTriplesAnnotation) {
        size += 2 + 1;
      }
      if (HasChapterIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(ChapterIndex);
      }
      if (HasParagraphIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(ParagraphIndex);
      }
      if (enhancedSentence_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(EnhancedSentence);
      }
      if (HasSpeaker) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Speaker);
      }
      if (HasSpeakerType) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SpeakerType);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Sentence other) {
      if (other == null) {
        return;
      }
      token_.Add(other.token_);
      if (other.HasTokenOffsetBegin) {
        TokenOffsetBegin = other.TokenOffsetBegin;
      }
      if (other.HasTokenOffsetEnd) {
        TokenOffsetEnd = other.TokenOffsetEnd;
      }
      if (other.HasSentenceIndex) {
        SentenceIndex = other.SentenceIndex;
      }
      if (other.HasCharacterOffsetBegin) {
        CharacterOffsetBegin = other.CharacterOffsetBegin;
      }
      if (other.HasCharacterOffsetEnd) {
        CharacterOffsetEnd = other.CharacterOffsetEnd;
      }
      if (other.parseTree_ != null) {
        if (parseTree_ == null) {
          ParseTree = new global::Edu.Stanford.Nlp.Pipeline.ParseTree();
        }
        ParseTree.MergeFrom(other.ParseTree);
      }
      if (other.binarizedParseTree_ != null) {
        if (binarizedParseTree_ == null) {
          BinarizedParseTree = new global::Edu.Stanford.Nlp.Pipeline.ParseTree();
        }
        BinarizedParseTree.MergeFrom(other.BinarizedParseTree);
      }
      if (other.annotatedParseTree_ != null) {
        if (annotatedParseTree_ == null) {
          AnnotatedParseTree = new global::Edu.Stanford.Nlp.Pipeline.ParseTree();
        }
        AnnotatedParseTree.MergeFrom(other.AnnotatedParseTree);
      }
      if (other.HasSentiment) {
        Sentiment = other.Sentiment;
      }
      kBestParseTrees_.Add(other.kBestParseTrees_);
      if (other.basicDependencies_ != null) {
        if (basicDependencies_ == null) {
          BasicDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
        }
        BasicDependencies.MergeFrom(other.BasicDependencies);
      }
      if (other.collapsedDependencies_ != null) {
        if (collapsedDependencies_ == null) {
          CollapsedDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
        }
        CollapsedDependencies.MergeFrom(other.CollapsedDependencies);
      }
      if (other.collapsedCCProcessedDependencies_ != null) {
        if (collapsedCCProcessedDependencies_ == null) {
          CollapsedCCProcessedDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
        }
        CollapsedCCProcessedDependencies.MergeFrom(other.CollapsedCCProcessedDependencies);
      }
      if (other.alternativeDependencies_ != null) {
        if (alternativeDependencies_ == null) {
          AlternativeDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
        }
        AlternativeDependencies.MergeFrom(other.AlternativeDependencies);
      }
      openieTriple_.Add(other.openieTriple_);
      kbpTriple_.Add(other.kbpTriple_);
      entailedSentence_.Add(other.entailedSentence_);
      entailedClause_.Add(other.entailedClause_);
      if (other.enhancedDependencies_ != null) {
        if (enhancedDependencies_ == null) {
          EnhancedDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
        }
        EnhancedDependencies.MergeFrom(other.EnhancedDependencies);
      }
      if (other.enhancedPlusPlusDependencies_ != null) {
        if (enhancedPlusPlusDependencies_ == null) {
          EnhancedPlusPlusDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
        }
        EnhancedPlusPlusDependencies.MergeFrom(other.EnhancedPlusPlusDependencies);
      }
      character_.Add(other.character_);
      if (other.HasParagraph) {
        Paragraph = other.Paragraph;
      }
      if (other.HasText) {
        Text = other.Text;
      }
      if (other.HasLineNumber) {
        LineNumber = other.LineNumber;
      }
      if (other.HasHasRelationAnnotations) {
        HasRelationAnnotations = other.HasRelationAnnotations;
      }
      entity_.Add(other.entity_);
      relation_.Add(other.relation_);
      if (other.HasHasNumerizedTokensAnnotation) {
        HasNumerizedTokensAnnotation = other.HasNumerizedTokensAnnotation;
      }
      mentions_.Add(other.mentions_);
      mentionsForCoref_.Add(other.mentionsForCoref_);
      if (other.HasHasCorefMentionsAnnotation) {
        HasCorefMentionsAnnotation = other.HasCorefMentionsAnnotation;
      }
      if (other.HasSentenceID) {
        SentenceID = other.SentenceID;
      }
      if (other.HasSectionDate) {
        SectionDate = other.SectionDate;
      }
      if (other.HasSectionIndex) {
        SectionIndex = other.SectionIndex;
      }
      if (other.HasSectionName) {
        SectionName = other.SectionName;
      }
      if (other.HasSectionAuthor) {
        SectionAuthor = other.SectionAuthor;
      }
      if (other.HasDocID) {
        DocID = other.DocID;
      }
      if (other.HasSectionQuoted) {
        SectionQuoted = other.SectionQuoted;
      }
      if (other.HasHasEntityMentionsAnnotation) {
        HasEntityMentionsAnnotation = other.HasEntityMentionsAnnotation;
      }
      if (other.HasHasKBPTriplesAnnotation) {
        HasKBPTriplesAnnotation = other.HasKBPTriplesAnnotation;
      }
      if (other.HasHasOpenieTriplesAnnotation) {
        HasOpenieTriplesAnnotation = other.HasOpenieTriplesAnnotation;
      }
      if (other.HasChapterIndex) {
        ChapterIndex = other.ChapterIndex;
      }
      if (other.HasParagraphIndex) {
        ParagraphIndex = other.ParagraphIndex;
      }
      if (other.enhancedSentence_ != null) {
        if (enhancedSentence_ == null) {
          EnhancedSentence = new global::Edu.Stanford.Nlp.Pipeline.Sentence();
        }
        EnhancedSentence.MergeFrom(other.EnhancedSentence);
      }
      if (other.HasSpeaker) {
        Speaker = other.Speaker;
      }
      if (other.HasSpeakerType) {
        SpeakerType = other.SpeakerType;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            token_.AddEntriesFrom(input, _repeated_token_codec);
            break;
          }
          case 16: {
            TokenOffsetBegin = input.ReadUInt32();
            break;
          }
          case 24: {
            TokenOffsetEnd = input.ReadUInt32();
            break;
          }
          case 32: {
            SentenceIndex = input.ReadUInt32();
            break;
          }
          case 40: {
            CharacterOffsetBegin = input.ReadUInt32();
            break;
          }
          case 48: {
            CharacterOffsetEnd = input.ReadUInt32();
            break;
          }
          case 58: {
            if (parseTree_ == null) {
              ParseTree = new global::Edu.Stanford.Nlp.Pipeline.ParseTree();
            }
            input.ReadMessage(ParseTree);
            break;
          }
          case 66: {
            if (basicDependencies_ == null) {
              BasicDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            input.ReadMessage(BasicDependencies);
            break;
          }
          case 74: {
            if (collapsedDependencies_ == null) {
              CollapsedDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            input.ReadMessage(CollapsedDependencies);
            break;
          }
          case 82: {
            if (collapsedCCProcessedDependencies_ == null) {
              CollapsedCCProcessedDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            input.ReadMessage(CollapsedCCProcessedDependencies);
            break;
          }
          case 88: {
            Paragraph = input.ReadUInt32();
            break;
          }
          case 98: {
            Text = input.ReadString();
            break;
          }
          case 106: {
            if (alternativeDependencies_ == null) {
              AlternativeDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            input.ReadMessage(AlternativeDependencies);
            break;
          }
          case 114: {
            openieTriple_.AddEntriesFrom(input, _repeated_openieTriple_codec);
            break;
          }
          case 122: {
            entailedSentence_.AddEntriesFrom(input, _repeated_entailedSentence_codec);
            break;
          }
          case 130: {
            kbpTriple_.AddEntriesFrom(input, _repeated_kbpTriple_codec);
            break;
          }
          case 138: {
            if (enhancedDependencies_ == null) {
              EnhancedDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            input.ReadMessage(EnhancedDependencies);
            break;
          }
          case 146: {
            if (enhancedPlusPlusDependencies_ == null) {
              EnhancedPlusPlusDependencies = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            input.ReadMessage(EnhancedPlusPlusDependencies);
            break;
          }
          case 154: {
            character_.AddEntriesFrom(input, _repeated_character_codec);
            break;
          }
          case 160: {
            LineNumber = input.ReadUInt32();
            break;
          }
          case 250: {
            if (binarizedParseTree_ == null) {
              BinarizedParseTree = new global::Edu.Stanford.Nlp.Pipeline.ParseTree();
            }
            input.ReadMessage(BinarizedParseTree);
            break;
          }
          case 258: {
            if (annotatedParseTree_ == null) {
              AnnotatedParseTree = new global::Edu.Stanford.Nlp.Pipeline.ParseTree();
            }
            input.ReadMessage(AnnotatedParseTree);
            break;
          }
          case 266: {
            Sentiment = input.ReadString();
            break;
          }
          case 274: {
            kBestParseTrees_.AddEntriesFrom(input, _repeated_kBestParseTrees_codec);
            break;
          }
          case 282: {
            entailedClause_.AddEntriesFrom(input, _repeated_entailedClause_codec);
            break;
          }
          case 408: {
            HasRelationAnnotations = input.ReadBool();
            break;
          }
          case 418: {
            entity_.AddEntriesFrom(input, _repeated_entity_codec);
            break;
          }
          case 426: {
            relation_.AddEntriesFrom(input, _repeated_relation_codec);
            break;
          }
          case 432: {
            HasNumerizedTokensAnnotation = input.ReadBool();
            break;
          }
          case 442: {
            mentions_.AddEntriesFrom(input, _repeated_mentions_codec);
            break;
          }
          case 450: {
            mentionsForCoref_.AddEntriesFrom(input, _repeated_mentionsForCoref_codec);
            break;
          }
          case 456: {
            HasCorefMentionsAnnotation = input.ReadBool();
            break;
          }
          case 466: {
            SentenceID = input.ReadString();
            break;
          }
          case 474: {
            SectionDate = input.ReadString();
            break;
          }
          case 480: {
            SectionIndex = input.ReadUInt32();
            break;
          }
          case 490: {
            SectionName = input.ReadString();
            break;
          }
          case 498: {
            SectionAuthor = input.ReadString();
            break;
          }
          case 506: {
            DocID = input.ReadString();
            break;
          }
          case 512: {
            SectionQuoted = input.ReadBool();
            break;
          }
          case 520: {
            HasEntityMentionsAnnotation = input.ReadBool();
            break;
          }
          case 528: {
            ChapterIndex = input.ReadUInt32();
            break;
          }
          case 536: {
            ParagraphIndex = input.ReadUInt32();
            break;
          }
          case 544: {
            HasKBPTriplesAnnotation = input.ReadBool();
            break;
          }
          case 552: {
            HasOpenieTriplesAnnotation = input.ReadBool();
            break;
          }
          case 562: {
            if (enhancedSentence_ == null) {
              EnhancedSentence = new global::Edu.Stanford.Nlp.Pipeline.Sentence();
            }
            input.ReadMessage(EnhancedSentence);
            break;
          }
          case 570: {
            Speaker = input.ReadString();
            break;
          }
          case 578: {
            SpeakerType = input.ReadString();
            break;
          }
        }
      }
    }

    public TValue GetExtension<TValue>(pb::Extension<Sentence, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Sentence, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Sentence, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<Sentence, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<Sentence, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<Sentence, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<Sentence, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  ///
  /// The serialized version of a Token (a CoreLabel).
  /// </summary>
  public sealed partial class Token : pb::IExtendableMessage<Token> {
    private static readonly pb::MessageParser<Token> _parser = new pb::MessageParser<Token>(() => new Token());
    private pb::UnknownFieldSet _unknownFields;
    private pb::ExtensionSet<Token> _extensions;
    private pb::ExtensionSet<Token> _Extensions { get { return _extensions; } }
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Token> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Token() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Token(Token other) : this() {
      _hasBits0 = other._hasBits0;
      word_ = other.word_;
      pos_ = other.pos_;
      value_ = other.value_;
      category_ = other.category_;
      before_ = other.before_;
      after_ = other.after_;
      originalText_ = other.originalText_;
      ner_ = other.ner_;
      coarseNER_ = other.coarseNER_;
      fineGrainedNER_ = other.fineGrainedNER_;
      nerLabelProbs_ = other.nerLabelProbs_.Clone();
      normalizedNER_ = other.normalizedNER_;
      lemma_ = other.lemma_;
      beginChar_ = other.beginChar_;
      endChar_ = other.endChar_;
      utterance_ = other.utterance_;
      speaker_ = other.speaker_;
      speakerType_ = other.speakerType_;
      beginIndex_ = other.beginIndex_;
      endIndex_ = other.endIndex_;
      tokenBeginIndex_ = other.tokenBeginIndex_;
      tokenEndIndex_ = other.tokenEndIndex_;
      timexValue_ = other.timexValue_ != null ? other.timexValue_.Clone() : null;
      hasXmlContext_ = other.hasXmlContext_;
      xmlContext_ = other.xmlContext_.Clone();
      corefClusterID_ = other.corefClusterID_;
      answer_ = other.answer_;
      headWordIndex_ = other.headWordIndex_;
      operator_ = other.operator_ != null ? other.operator_.Clone() : null;
      polarity_ = other.polarity_ != null ? other.polarity_.Clone() : null;
      polarityDir_ = other.polarityDir_;
      span_ = other.span_ != null ? other.span_.Clone() : null;
      sentiment_ = other.sentiment_;
      quotationIndex_ = other.quotationIndex_;
      conllUFeatures_ = other.conllUFeatures_ != null ? other.conllUFeatures_.Clone() : null;
      coarseTag_ = other.coarseTag_;
      conllUTokenSpan_ = other.conllUTokenSpan_ != null ? other.conllUTokenSpan_.Clone() : null;
      conllUMisc_ = other.conllUMisc_;
      conllUSecondaryDeps_ = other.conllUSecondaryDeps_ != null ? other.conllUSecondaryDeps_.Clone() : null;
      wikipediaEntity_ = other.wikipediaEntity_;
      isNewline_ = other.isNewline_;
      gender_ = other.gender_;
      trueCase_ = other.trueCase_;
      trueCaseText_ = other.trueCaseText_;
      chineseChar_ = other.chineseChar_;
      chineseSeg_ = other.chineseSeg_;
      chineseXMLChar_ = other.chineseXMLChar_;
      arabicSeg_ = other.arabicSeg_;
      sectionName_ = other.sectionName_;
      sectionAuthor_ = other.sectionAuthor_;
      sectionDate_ = other.sectionDate_;
      sectionEndLabel_ = other.sectionEndLabel_;
      parent_ = other.parent_;
      corefMentionIndex_ = other.corefMentionIndex_.Clone();
      entityMentionIndex_ = other.entityMentionIndex_;
      isMWT_ = other.isMWT_;
      isFirstMWT_ = other.isFirstMWT_;
      mwtText_ = other.mwtText_;
      numericValue_ = other.numericValue_;
      numericType_ = other.numericType_;
      numericCompositeValue_ = other.numericCompositeValue_;
      numericCompositeType_ = other.numericCompositeType_;
      codepointOffsetBegin_ = other.codepointOffsetBegin_;
      codepointOffsetEnd_ = other.codepointOffsetEnd_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
      _extensions = pb::ExtensionSet.Clone(other._extensions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Token Clone() {
      return new Token(this);
    }

    /// <summary>Field number for the "word" field.</summary>
    public const int WordFieldNumber = 1;
    private readonly static string WordDefaultValue = "";

    private string word_;
    /// <summary>
    /// Fields set by the default annotators [new CoreNLP(new Properties())]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Word {
      get { return word_ ?? WordDefaultValue; }
      set {
        word_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "word" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWord {
      get { return word_ != null; }
    }
    /// <summary>Clears the value of the "word" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWord() {
      word_ = null;
    }

    /// <summary>Field number for the "pos" field.</summary>
    public const int PosFieldNumber = 2;
    private readonly static string PosDefaultValue = "";

    private string pos_;
    /// <summary>
    /// The word's part of speech tag
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Pos {
      get { return pos_ ?? PosDefaultValue; }
      set {
        pos_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "pos" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPos {
      get { return pos_ != null; }
    }
    /// <summary>Clears the value of the "pos" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPos() {
      pos_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 3;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    /// <summary>
    /// The word's 'value', (e.g., parse tree node)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      value_ = null;
    }

    /// <summary>Field number for the "category" field.</summary>
    public const int CategoryFieldNumber = 4;
    private readonly static string CategoryDefaultValue = "";

    private string category_;
    /// <summary>
    /// The word's 'category' (e.g., parse tree node)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Category {
      get { return category_ ?? CategoryDefaultValue; }
      set {
        category_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "category" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCategory {
      get { return category_ != null; }
    }
    /// <summary>Clears the value of the "category" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCategory() {
      category_ = null;
    }

    /// <summary>Field number for the "before" field.</summary>
    public const int BeforeFieldNumber = 5;
    private readonly static string BeforeDefaultValue = "";

    private string before_;
    /// <summary>
    /// The whitespace/xml before the token
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Before {
      get { return before_ ?? BeforeDefaultValue; }
      set {
        before_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "before" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBefore {
      get { return before_ != null; }
    }
    /// <summary>Clears the value of the "before" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBefore() {
      before_ = null;
    }

    /// <summary>Field number for the "after" field.</summary>
    public const int AfterFieldNumber = 6;
    private readonly static string AfterDefaultValue = "";

    private string after_;
    /// <summary>
    /// The whitespace/xml after the token
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string After {
      get { return after_ ?? AfterDefaultValue; }
      set {
        after_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "after" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAfter {
      get { return after_ != null; }
    }
    /// <summary>Clears the value of the "after" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAfter() {
      after_ = null;
    }

    /// <summary>Field number for the "originalText" field.</summary>
    public const int OriginalTextFieldNumber = 7;
    private readonly static string OriginalTextDefaultValue = "";

    private string originalText_;
    /// <summary>
    /// The original text for this token
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OriginalText {
      get { return originalText_ ?? OriginalTextDefaultValue; }
      set {
        originalText_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "originalText" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOriginalText {
      get { return originalText_ != null; }
    }
    /// <summary>Clears the value of the "originalText" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOriginalText() {
      originalText_ = null;
    }

    /// <summary>Field number for the "ner" field.</summary>
    public const int NerFieldNumber = 8;
    private readonly static string NerDefaultValue = "";

    private string ner_;
    /// <summary>
    /// The word's NER tag
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Ner {
      get { return ner_ ?? NerDefaultValue; }
      set {
        ner_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ner" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNer {
      get { return ner_ != null; }
    }
    /// <summary>Clears the value of the "ner" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNer() {
      ner_ = null;
    }

    /// <summary>Field number for the "coarseNER" field.</summary>
    public const int CoarseNERFieldNumber = 62;
    private readonly static string CoarseNERDefaultValue = "";

    private string coarseNER_;
    /// <summary>
    /// The word's coarse NER tag
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CoarseNER {
      get { return coarseNER_ ?? CoarseNERDefaultValue; }
      set {
        coarseNER_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "coarseNER" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCoarseNER {
      get { return coarseNER_ != null; }
    }
    /// <summary>Clears the value of the "coarseNER" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCoarseNER() {
      coarseNER_ = null;
    }

    /// <summary>Field number for the "fineGrainedNER" field.</summary>
    public const int FineGrainedNERFieldNumber = 63;
    private readonly static string FineGrainedNERDefaultValue = "";

    private string fineGrainedNER_;
    /// <summary>
    /// The word's fine-grained NER tag
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FineGrainedNER {
      get { return fineGrainedNER_ ?? FineGrainedNERDefaultValue; }
      set {
        fineGrainedNER_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fineGrainedNER" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFineGrainedNER {
      get { return fineGrainedNER_ != null; }
    }
    /// <summary>Clears the value of the "fineGrainedNER" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFineGrainedNER() {
      fineGrainedNER_ = null;
    }

    /// <summary>Field number for the "nerLabelProbs" field.</summary>
    public const int NerLabelProbsFieldNumber = 66;
    private static readonly pb::FieldCodec<string> _repeated_nerLabelProbs_codec
        = pb::FieldCodec.ForString(530);
    private readonly pbc::RepeatedField<string> nerLabelProbs_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// listing of probs
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> NerLabelProbs {
      get { return nerLabelProbs_; }
    }

    /// <summary>Field number for the "normalizedNER" field.</summary>
    public const int NormalizedNERFieldNumber = 9;
    private readonly static string NormalizedNERDefaultValue = "";

    private string normalizedNER_;
    /// <summary>
    /// The word's normalized NER tag
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NormalizedNER {
      get { return normalizedNER_ ?? NormalizedNERDefaultValue; }
      set {
        normalizedNER_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "normalizedNER" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNormalizedNER {
      get { return normalizedNER_ != null; }
    }
    /// <summary>Clears the value of the "normalizedNER" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNormalizedNER() {
      normalizedNER_ = null;
    }

    /// <summary>Field number for the "lemma" field.</summary>
    public const int LemmaFieldNumber = 10;
    private readonly static string LemmaDefaultValue = "";

    private string lemma_;
    /// <summary>
    /// The word's lemma
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Lemma {
      get { return lemma_ ?? LemmaDefaultValue; }
      set {
        lemma_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "lemma" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLemma {
      get { return lemma_ != null; }
    }
    /// <summary>Clears the value of the "lemma" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLemma() {
      lemma_ = null;
    }

    /// <summary>Field number for the "beginChar" field.</summary>
    public const int BeginCharFieldNumber = 11;
    private readonly static uint BeginCharDefaultValue = 0;

    private uint beginChar_;
    /// <summary>
    /// The character offset begin, in the document
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BeginChar {
      get { if ((_hasBits0 & 1) != 0) { return beginChar_; } else { return BeginCharDefaultValue; } }
      set {
        _hasBits0 |= 1;
        beginChar_ = value;
      }
    }
    /// <summary>Gets whether the "beginChar" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBeginChar {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "beginChar" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBeginChar() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "endChar" field.</summary>
    public const int EndCharFieldNumber = 12;
    private readonly static uint EndCharDefaultValue = 0;

    private uint endChar_;
    /// <summary>
    /// The character offset end, in the document
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EndChar {
      get { if ((_hasBits0 & 2) != 0) { return endChar_; } else { return EndCharDefaultValue; } }
      set {
        _hasBits0 |= 2;
        endChar_ = value;
      }
    }
    /// <summary>Gets whether the "endChar" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEndChar {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "endChar" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEndChar() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "utterance" field.</summary>
    public const int UtteranceFieldNumber = 13;
    private readonly static uint UtteranceDefaultValue = 0;

    private uint utterance_;
    /// <summary>
    /// The utterance tag used in dcoref
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Utterance {
      get { if ((_hasBits0 & 4) != 0) { return utterance_; } else { return UtteranceDefaultValue; } }
      set {
        _hasBits0 |= 4;
        utterance_ = value;
      }
    }
    /// <summary>Gets whether the "utterance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUtterance {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "utterance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUtterance() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "speaker" field.</summary>
    public const int SpeakerFieldNumber = 14;
    private readonly static string SpeakerDefaultValue = "";

    private string speaker_;
    /// <summary>
    /// The speaker speaking this word
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Speaker {
      get { return speaker_ ?? SpeakerDefaultValue; }
      set {
        speaker_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "speaker" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeaker {
      get { return speaker_ != null; }
    }
    /// <summary>Clears the value of the "speaker" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeaker() {
      speaker_ = null;
    }

    /// <summary>Field number for the "speakerType" field.</summary>
    public const int SpeakerTypeFieldNumber = 77;
    private readonly static string SpeakerTypeDefaultValue = "";

    private string speakerType_;
    /// <summary>
    /// The type of speaker speaking this word
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SpeakerType {
      get { return speakerType_ ?? SpeakerTypeDefaultValue; }
      set {
        speakerType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "speakerType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeakerType {
      get { return speakerType_ != null; }
    }
    /// <summary>Clears the value of the "speakerType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeakerType() {
      speakerType_ = null;
    }

    /// <summary>Field number for the "beginIndex" field.</summary>
    public const int BeginIndexFieldNumber = 15;
    private readonly static uint BeginIndexDefaultValue = 0;

    private uint beginIndex_;
    /// <summary>
    /// The begin index of, e.g., a span
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BeginIndex {
      get { if ((_hasBits0 & 8) != 0) { return beginIndex_; } else { return BeginIndexDefaultValue; } }
      set {
        _hasBits0 |= 8;
        beginIndex_ = value;
      }
    }
    /// <summary>Gets whether the "beginIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBeginIndex {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "beginIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBeginIndex() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "endIndex" field.</summary>
    public const int EndIndexFieldNumber = 16;
    private readonly static uint EndIndexDefaultValue = 0;

    private uint endIndex_;
    /// <summary>
    /// The begin index of, e.g., a span
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EndIndex {
      get { if ((_hasBits0 & 16) != 0) { return endIndex_; } else { return EndIndexDefaultValue; } }
      set {
        _hasBits0 |= 16;
        endIndex_ = value;
      }
    }
    /// <summary>Gets whether the "endIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEndIndex {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "endIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEndIndex() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "tokenBeginIndex" field.</summary>
    public const int TokenBeginIndexFieldNumber = 17;
    private readonly static uint TokenBeginIndexDefaultValue = 0;

    private uint tokenBeginIndex_;
    /// <summary>
    /// The begin index of the token
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenBeginIndex {
      get { if ((_hasBits0 & 32) != 0) { return tokenBeginIndex_; } else { return TokenBeginIndexDefaultValue; } }
      set {
        _hasBits0 |= 32;
        tokenBeginIndex_ = value;
      }
    }
    /// <summary>Gets whether the "tokenBeginIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenBeginIndex {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "tokenBeginIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenBeginIndex() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "tokenEndIndex" field.</summary>
    public const int TokenEndIndexFieldNumber = 18;
    private readonly static uint TokenEndIndexDefaultValue = 0;

    private uint tokenEndIndex_;
    /// <summary>
    /// The end index of the token
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenEndIndex {
      get { if ((_hasBits0 & 64) != 0) { return tokenEndIndex_; } else { return TokenEndIndexDefaultValue; } }
      set {
        _hasBits0 |= 64;
        tokenEndIndex_ = value;
      }
    }
    /// <summary>Gets whether the "tokenEndIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenEndIndex {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "tokenEndIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenEndIndex() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "timexValue" field.</summary>
    public const int TimexValueFieldNumber = 19;
    private global::Edu.Stanford.Nlp.Pipeline.Timex timexValue_;
    /// <summary>
    /// The time this word refers to
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Timex TimexValue {
      get { return timexValue_; }
      set {
        timexValue_ = value;
      }
    }

    /// <summary>Field number for the "hasXmlContext" field.</summary>
    public const int HasXmlContextFieldNumber = 21;
    private readonly static bool HasXmlContextDefaultValue = false;

    private bool hasXmlContext_;
    /// <summary>
    /// Used by clean xml annotator
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasXmlContext {
      get { if ((_hasBits0 & 128) != 0) { return hasXmlContext_; } else { return HasXmlContextDefaultValue; } }
      set {
        _hasBits0 |= 128;
        hasXmlContext_ = value;
      }
    }
    /// <summary>Gets whether the "hasXmlContext" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasXmlContext {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "hasXmlContext" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasXmlContext() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "xmlContext" field.</summary>
    public const int XmlContextFieldNumber = 22;
    private static readonly pb::FieldCodec<string> _repeated_xmlContext_codec
        = pb::FieldCodec.ForString(178);
    private readonly pbc::RepeatedField<string> xmlContext_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Used by clean xml annotator
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> XmlContext {
      get { return xmlContext_; }
    }

    /// <summary>Field number for the "corefClusterID" field.</summary>
    public const int CorefClusterIDFieldNumber = 23;
    private readonly static uint CorefClusterIDDefaultValue = 0;

    private uint corefClusterID_;
    /// <summary>
    /// The [primary] cluster id for this token
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CorefClusterID {
      get { if ((_hasBits0 & 256) != 0) { return corefClusterID_; } else { return CorefClusterIDDefaultValue; } }
      set {
        _hasBits0 |= 256;
        corefClusterID_ = value;
      }
    }
    /// <summary>Gets whether the "corefClusterID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCorefClusterID {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "corefClusterID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCorefClusterID() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "answer" field.</summary>
    public const int AnswerFieldNumber = 24;
    private readonly static string AnswerDefaultValue = "";

    private string answer_;
    /// <summary>
    /// A temporary annotation which is occasionally left in
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Answer {
      get { return answer_ ?? AnswerDefaultValue; }
      set {
        answer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "answer" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAnswer {
      get { return answer_ != null; }
    }
    /// <summary>Clears the value of the "answer" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAnswer() {
      answer_ = null;
    }

    /// <summary>Field number for the "headWordIndex" field.</summary>
    public const int HeadWordIndexFieldNumber = 26;
    private readonly static uint HeadWordIndexDefaultValue = 0;

    private uint headWordIndex_;
    /// <summary>
    ///  optional string projectedCategory = 25;   // The syntactic category of the maximal constituent headed by the word. Not used anywhere, so deleted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint HeadWordIndex {
      get { if ((_hasBits0 & 512) != 0) { return headWordIndex_; } else { return HeadWordIndexDefaultValue; } }
      set {
        _hasBits0 |= 512;
        headWordIndex_ = value;
      }
    }
    /// <summary>Gets whether the "headWordIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadWordIndex {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "headWordIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadWordIndex() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "operator" field.</summary>
    public const int OperatorFieldNumber = 27;
    private global::Edu.Stanford.Nlp.Pipeline.Operator operator_;
    /// <summary>
    /// If this is an operator, which one is it and what is its scope (as per Natural Logic)?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Operator Operator {
      get { return operator_; }
      set {
        operator_ = value;
      }
    }

    /// <summary>Field number for the "polarity" field.</summary>
    public const int PolarityFieldNumber = 28;
    private global::Edu.Stanford.Nlp.Pipeline.Polarity polarity_;
    /// <summary>
    /// The polarity of this word, according to Natural Logic
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Polarity Polarity {
      get { return polarity_; }
      set {
        polarity_ = value;
      }
    }

    /// <summary>Field number for the "polarity_dir" field.</summary>
    public const int PolarityDirFieldNumber = 39;
    private readonly static string PolarityDirDefaultValue = "";

    private string polarityDir_;
    /// <summary>
    /// The polarity of this word, either "up", "down", or "flat"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PolarityDir {
      get { return polarityDir_ ?? PolarityDirDefaultValue; }
      set {
        polarityDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "polarity_dir" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPolarityDir {
      get { return polarityDir_ != null; }
    }
    /// <summary>Clears the value of the "polarity_dir" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPolarityDir() {
      polarityDir_ = null;
    }

    /// <summary>Field number for the "span" field.</summary>
    public const int SpanFieldNumber = 29;
    private global::Edu.Stanford.Nlp.Pipeline.Span span_;
    /// <summary>
    /// The span of a leaf node of a tree
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Span Span {
      get { return span_; }
      set {
        span_ = value;
      }
    }

    /// <summary>Field number for the "sentiment" field.</summary>
    public const int SentimentFieldNumber = 30;
    private readonly static string SentimentDefaultValue = "";

    private string sentiment_;
    /// <summary>
    /// The final sentiment of the sentence
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Sentiment {
      get { return sentiment_ ?? SentimentDefaultValue; }
      set {
        sentiment_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sentiment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentiment {
      get { return sentiment_ != null; }
    }
    /// <summary>Clears the value of the "sentiment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentiment() {
      sentiment_ = null;
    }

    /// <summary>Field number for the "quotationIndex" field.</summary>
    public const int QuotationIndexFieldNumber = 31;
    private readonly static int QuotationIndexDefaultValue = 0;

    private int quotationIndex_;
    /// <summary>
    /// The index of the quotation this token refers to
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int QuotationIndex {
      get { if ((_hasBits0 & 1024) != 0) { return quotationIndex_; } else { return QuotationIndexDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        quotationIndex_ = value;
      }
    }
    /// <summary>Gets whether the "quotationIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasQuotationIndex {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "quotationIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearQuotationIndex() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "conllUFeatures" field.</summary>
    public const int ConllUFeaturesFieldNumber = 32;
    private global::Edu.Stanford.Nlp.Pipeline.MapStringString conllUFeatures_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.MapStringString ConllUFeatures {
      get { return conllUFeatures_; }
      set {
        conllUFeatures_ = value;
      }
    }

    /// <summary>Field number for the "coarseTag" field.</summary>
    public const int CoarseTagFieldNumber = 33;
    private readonly static string CoarseTagDefaultValue = "";

    private string coarseTag_;
    /// <summary>
    ///  The coarse POS tag (used to store the UPOS tag)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CoarseTag {
      get { return coarseTag_ ?? CoarseTagDefaultValue; }
      set {
        coarseTag_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "coarseTag" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCoarseTag {
      get { return coarseTag_ != null; }
    }
    /// <summary>Clears the value of the "coarseTag" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCoarseTag() {
      coarseTag_ = null;
    }

    /// <summary>Field number for the "conllUTokenSpan" field.</summary>
    public const int ConllUTokenSpanFieldNumber = 34;
    private global::Edu.Stanford.Nlp.Pipeline.Span conllUTokenSpan_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Span ConllUTokenSpan {
      get { return conllUTokenSpan_; }
      set {
        conllUTokenSpan_ = value;
      }
    }

    /// <summary>Field number for the "conllUMisc" field.</summary>
    public const int ConllUMiscFieldNumber = 35;
    private readonly static string ConllUMiscDefaultValue = "";

    private string conllUMisc_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ConllUMisc {
      get { return conllUMisc_ ?? ConllUMiscDefaultValue; }
      set {
        conllUMisc_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "conllUMisc" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasConllUMisc {
      get { return conllUMisc_ != null; }
    }
    /// <summary>Clears the value of the "conllUMisc" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConllUMisc() {
      conllUMisc_ = null;
    }

    /// <summary>Field number for the "conllUSecondaryDeps" field.</summary>
    public const int ConllUSecondaryDepsFieldNumber = 36;
    private global::Edu.Stanford.Nlp.Pipeline.MapStringString conllUSecondaryDeps_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.MapStringString ConllUSecondaryDeps {
      get { return conllUSecondaryDeps_; }
      set {
        conllUSecondaryDeps_ = value;
      }
    }

    /// <summary>Field number for the "wikipediaEntity" field.</summary>
    public const int WikipediaEntityFieldNumber = 37;
    private readonly static string WikipediaEntityDefaultValue = "";

    private string wikipediaEntity_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string WikipediaEntity {
      get { return wikipediaEntity_ ?? WikipediaEntityDefaultValue; }
      set {
        wikipediaEntity_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "wikipediaEntity" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWikipediaEntity {
      get { return wikipediaEntity_ != null; }
    }
    /// <summary>Clears the value of the "wikipediaEntity" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWikipediaEntity() {
      wikipediaEntity_ = null;
    }

    /// <summary>Field number for the "isNewline" field.</summary>
    public const int IsNewlineFieldNumber = 38;
    private readonly static bool IsNewlineDefaultValue = false;

    private bool isNewline_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsNewline {
      get { if ((_hasBits0 & 2048) != 0) { return isNewline_; } else { return IsNewlineDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        isNewline_ = value;
      }
    }
    /// <summary>Gets whether the "isNewline" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsNewline {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "isNewline" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsNewline() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "gender" field.</summary>
    public const int GenderFieldNumber = 51;
    private readonly static string GenderDefaultValue = "";

    private string gender_;
    /// <summary>
    /// Fields set by other annotators in CoreNLP
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Gender {
      get { return gender_ ?? GenderDefaultValue; }
      set {
        gender_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gender" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGender {
      get { return gender_ != null; }
    }
    /// <summary>Clears the value of the "gender" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGender() {
      gender_ = null;
    }

    /// <summary>Field number for the "trueCase" field.</summary>
    public const int TrueCaseFieldNumber = 52;
    private readonly static string TrueCaseDefaultValue = "";

    private string trueCase_;
    /// <summary>
    /// true case type of token
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TrueCase {
      get { return trueCase_ ?? TrueCaseDefaultValue; }
      set {
        trueCase_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "trueCase" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTrueCase {
      get { return trueCase_ != null; }
    }
    /// <summary>Clears the value of the "trueCase" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTrueCase() {
      trueCase_ = null;
    }

    /// <summary>Field number for the "trueCaseText" field.</summary>
    public const int TrueCaseTextFieldNumber = 53;
    private readonly static string TrueCaseTextDefaultValue = "";

    private string trueCaseText_;
    /// <summary>
    /// true case gloss of token
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TrueCaseText {
      get { return trueCaseText_ ?? TrueCaseTextDefaultValue; }
      set {
        trueCaseText_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "trueCaseText" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTrueCaseText {
      get { return trueCaseText_ != null; }
    }
    /// <summary>Clears the value of the "trueCaseText" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTrueCaseText() {
      trueCaseText_ = null;
    }

    /// <summary>Field number for the "chineseChar" field.</summary>
    public const int ChineseCharFieldNumber = 54;
    private readonly static string ChineseCharDefaultValue = "";

    private string chineseChar_;
    /// <summary>
    ///  Chinese character info
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ChineseChar {
      get { return chineseChar_ ?? ChineseCharDefaultValue; }
      set {
        chineseChar_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "chineseChar" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasChineseChar {
      get { return chineseChar_ != null; }
    }
    /// <summary>Clears the value of the "chineseChar" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearChineseChar() {
      chineseChar_ = null;
    }

    /// <summary>Field number for the "chineseSeg" field.</summary>
    public const int ChineseSegFieldNumber = 55;
    private readonly static string ChineseSegDefaultValue = "";

    private string chineseSeg_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ChineseSeg {
      get { return chineseSeg_ ?? ChineseSegDefaultValue; }
      set {
        chineseSeg_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "chineseSeg" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasChineseSeg {
      get { return chineseSeg_ != null; }
    }
    /// <summary>Clears the value of the "chineseSeg" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearChineseSeg() {
      chineseSeg_ = null;
    }

    /// <summary>Field number for the "chineseXMLChar" field.</summary>
    public const int ChineseXMLCharFieldNumber = 60;
    private readonly static string ChineseXMLCharDefaultValue = "";

    private string chineseXMLChar_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ChineseXMLChar {
      get { return chineseXMLChar_ ?? ChineseXMLCharDefaultValue; }
      set {
        chineseXMLChar_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "chineseXMLChar" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasChineseXMLChar {
      get { return chineseXMLChar_ != null; }
    }
    /// <summary>Clears the value of the "chineseXMLChar" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearChineseXMLChar() {
      chineseXMLChar_ = null;
    }

    /// <summary>Field number for the "arabicSeg" field.</summary>
    public const int ArabicSegFieldNumber = 76;
    private readonly static string ArabicSegDefaultValue = "";

    private string arabicSeg_;
    /// <summary>
    ///  Arabic character info
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ArabicSeg {
      get { return arabicSeg_ ?? ArabicSegDefaultValue; }
      set {
        arabicSeg_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "arabicSeg" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasArabicSeg {
      get { return arabicSeg_ != null; }
    }
    /// <summary>Clears the value of the "arabicSeg" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearArabicSeg() {
      arabicSeg_ = null;
    }

    /// <summary>Field number for the "sectionName" field.</summary>
    public const int SectionNameFieldNumber = 56;
    private readonly static string SectionNameDefaultValue = "";

    private string sectionName_;
    /// <summary>
    /// Section info
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SectionName {
      get { return sectionName_ ?? SectionNameDefaultValue; }
      set {
        sectionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sectionName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionName {
      get { return sectionName_ != null; }
    }
    /// <summary>Clears the value of the "sectionName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionName() {
      sectionName_ = null;
    }

    /// <summary>Field number for the "sectionAuthor" field.</summary>
    public const int SectionAuthorFieldNumber = 57;
    private readonly static string SectionAuthorDefaultValue = "";

    private string sectionAuthor_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SectionAuthor {
      get { return sectionAuthor_ ?? SectionAuthorDefaultValue; }
      set {
        sectionAuthor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sectionAuthor" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionAuthor {
      get { return sectionAuthor_ != null; }
    }
    /// <summary>Clears the value of the "sectionAuthor" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionAuthor() {
      sectionAuthor_ = null;
    }

    /// <summary>Field number for the "sectionDate" field.</summary>
    public const int SectionDateFieldNumber = 58;
    private readonly static string SectionDateDefaultValue = "";

    private string sectionDate_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SectionDate {
      get { return sectionDate_ ?? SectionDateDefaultValue; }
      set {
        sectionDate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sectionDate" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionDate {
      get { return sectionDate_ != null; }
    }
    /// <summary>Clears the value of the "sectionDate" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionDate() {
      sectionDate_ = null;
    }

    /// <summary>Field number for the "sectionEndLabel" field.</summary>
    public const int SectionEndLabelFieldNumber = 59;
    private readonly static string SectionEndLabelDefaultValue = "";

    private string sectionEndLabel_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SectionEndLabel {
      get { return sectionEndLabel_ ?? SectionEndLabelDefaultValue; }
      set {
        sectionEndLabel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sectionEndLabel" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSectionEndLabel {
      get { return sectionEndLabel_ != null; }
    }
    /// <summary>Clears the value of the "sectionEndLabel" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSectionEndLabel() {
      sectionEndLabel_ = null;
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 61;
    private readonly static string ParentDefaultValue = "";

    private string parent_;
    /// <summary>
    /// French tokens have parents
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_ ?? ParentDefaultValue; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "parent" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasParent {
      get { return parent_ != null; }
    }
    /// <summary>Clears the value of the "parent" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearParent() {
      parent_ = null;
    }

    /// <summary>Field number for the "corefMentionIndex" field.</summary>
    public const int CorefMentionIndexFieldNumber = 64;
    private static readonly pb::FieldCodec<uint> _repeated_corefMentionIndex_codec
        = pb::FieldCodec.ForUInt32(512);
    private readonly pbc::RepeatedField<uint> corefMentionIndex_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// mention index info
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> CorefMentionIndex {
      get { return corefMentionIndex_; }
    }

    /// <summary>Field number for the "entityMentionIndex" field.</summary>
    public const int EntityMentionIndexFieldNumber = 65;
    private readonly static uint EntityMentionIndexDefaultValue = 0;

    private uint entityMentionIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EntityMentionIndex {
      get { if ((_hasBits0 & 4096) != 0) { return entityMentionIndex_; } else { return EntityMentionIndexDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        entityMentionIndex_ = value;
      }
    }
    /// <summary>Gets whether the "entityMentionIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEntityMentionIndex {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "entityMentionIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEntityMentionIndex() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "isMWT" field.</summary>
    public const int IsMWTFieldNumber = 67;
    private readonly static bool IsMWTDefaultValue = false;

    private bool isMWT_;
    /// <summary>
    /// mwt stuff
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsMWT {
      get { if ((_hasBits0 & 8192) != 0) { return isMWT_; } else { return IsMWTDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        isMWT_ = value;
      }
    }
    /// <summary>Gets whether the "isMWT" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsMWT {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "isMWT" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsMWT() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "isFirstMWT" field.</summary>
    public const int IsFirstMWTFieldNumber = 68;
    private readonly static bool IsFirstMWTDefaultValue = false;

    private bool isFirstMWT_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsFirstMWT {
      get { if ((_hasBits0 & 16384) != 0) { return isFirstMWT_; } else { return IsFirstMWTDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        isFirstMWT_ = value;
      }
    }
    /// <summary>Gets whether the "isFirstMWT" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsFirstMWT {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "isFirstMWT" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsFirstMWT() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "mwtText" field.</summary>
    public const int MwtTextFieldNumber = 69;
    private readonly static string MwtTextDefaultValue = "";

    private string mwtText_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MwtText {
      get { return mwtText_ ?? MwtTextDefaultValue; }
      set {
        mwtText_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mwtText" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMwtText {
      get { return mwtText_ != null; }
    }
    /// <summary>Clears the value of the "mwtText" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMwtText() {
      mwtText_ = null;
    }

    /// <summary>Field number for the "numericValue" field.</summary>
    public const int NumericValueFieldNumber = 70;
    private readonly static ulong NumericValueDefaultValue = 0UL;

    private ulong numericValue_;
    /// <summary>
    /// number info
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong NumericValue {
      get { if ((_hasBits0 & 32768) != 0) { return numericValue_; } else { return NumericValueDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        numericValue_ = value;
      }
    }
    /// <summary>Gets whether the "numericValue" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNumericValue {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "numericValue" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNumericValue() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "numericType" field.</summary>
    public const int NumericTypeFieldNumber = 71;
    private readonly static string NumericTypeDefaultValue = "";

    private string numericType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NumericType {
      get { return numericType_ ?? NumericTypeDefaultValue; }
      set {
        numericType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "numericType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNumericType {
      get { return numericType_ != null; }
    }
    /// <summary>Clears the value of the "numericType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNumericType() {
      numericType_ = null;
    }

    /// <summary>Field number for the "numericCompositeValue" field.</summary>
    public const int NumericCompositeValueFieldNumber = 72;
    private readonly static ulong NumericCompositeValueDefaultValue = 0UL;

    private ulong numericCompositeValue_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong NumericCompositeValue {
      get { if ((_hasBits0 & 65536) != 0) { return numericCompositeValue_; } else { return NumericCompositeValueDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        numericCompositeValue_ = value;
      }
    }
    /// <summary>Gets whether the "numericCompositeValue" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNumericCompositeValue {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "numericCompositeValue" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNumericCompositeValue() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "numericCompositeType" field.</summary>
    public const int NumericCompositeTypeFieldNumber = 73;
    private readonly static string NumericCompositeTypeDefaultValue = "";

    private string numericCompositeType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NumericCompositeType {
      get { return numericCompositeType_ ?? NumericCompositeTypeDefaultValue; }
      set {
        numericCompositeType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "numericCompositeType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNumericCompositeType {
      get { return numericCompositeType_ != null; }
    }
    /// <summary>Clears the value of the "numericCompositeType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNumericCompositeType() {
      numericCompositeType_ = null;
    }

    /// <summary>Field number for the "codepointOffsetBegin" field.</summary>
    public const int CodepointOffsetBeginFieldNumber = 74;
    private readonly static uint CodepointOffsetBeginDefaultValue = 0;

    private uint codepointOffsetBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CodepointOffsetBegin {
      get { if ((_hasBits0 & 131072) != 0) { return codepointOffsetBegin_; } else { return CodepointOffsetBeginDefaultValue; } }
      set {
        _hasBits0 |= 131072;
        codepointOffsetBegin_ = value;
      }
    }
    /// <summary>Gets whether the "codepointOffsetBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCodepointOffsetBegin {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "codepointOffsetBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCodepointOffsetBegin() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "codepointOffsetEnd" field.</summary>
    public const int CodepointOffsetEndFieldNumber = 75;
    private readonly static uint CodepointOffsetEndDefaultValue = 0;

    private uint codepointOffsetEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CodepointOffsetEnd {
      get { if ((_hasBits0 & 262144) != 0) { return codepointOffsetEnd_; } else { return CodepointOffsetEndDefaultValue; } }
      set {
        _hasBits0 |= 262144;
        codepointOffsetEnd_ = value;
      }
    }
    /// <summary>Gets whether the "codepointOffsetEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCodepointOffsetEnd {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "codepointOffsetEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCodepointOffsetEnd() {
      _hasBits0 &= ~262144;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Token);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Token other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Word != other.Word) return false;
      if (Pos != other.Pos) return false;
      if (Value != other.Value) return false;
      if (Category != other.Category) return false;
      if (Before != other.Before) return false;
      if (After != other.After) return false;
      if (OriginalText != other.OriginalText) return false;
      if (Ner != other.Ner) return false;
      if (CoarseNER != other.CoarseNER) return false;
      if (FineGrainedNER != other.FineGrainedNER) return false;
      if(!nerLabelProbs_.Equals(other.nerLabelProbs_)) return false;
      if (NormalizedNER != other.NormalizedNER) return false;
      if (Lemma != other.Lemma) return false;
      if (BeginChar != other.BeginChar) return false;
      if (EndChar != other.EndChar) return false;
      if (Utterance != other.Utterance) return false;
      if (Speaker != other.Speaker) return false;
      if (SpeakerType != other.SpeakerType) return false;
      if (BeginIndex != other.BeginIndex) return false;
      if (EndIndex != other.EndIndex) return false;
      if (TokenBeginIndex != other.TokenBeginIndex) return false;
      if (TokenEndIndex != other.TokenEndIndex) return false;
      if (!object.Equals(TimexValue, other.TimexValue)) return false;
      if (HasXmlContext != other.HasXmlContext) return false;
      if(!xmlContext_.Equals(other.xmlContext_)) return false;
      if (CorefClusterID != other.CorefClusterID) return false;
      if (Answer != other.Answer) return false;
      if (HeadWordIndex != other.HeadWordIndex) return false;
      if (!object.Equals(Operator, other.Operator)) return false;
      if (!object.Equals(Polarity, other.Polarity)) return false;
      if (PolarityDir != other.PolarityDir) return false;
      if (!object.Equals(Span, other.Span)) return false;
      if (Sentiment != other.Sentiment) return false;
      if (QuotationIndex != other.QuotationIndex) return false;
      if (!object.Equals(ConllUFeatures, other.ConllUFeatures)) return false;
      if (CoarseTag != other.CoarseTag) return false;
      if (!object.Equals(ConllUTokenSpan, other.ConllUTokenSpan)) return false;
      if (ConllUMisc != other.ConllUMisc) return false;
      if (!object.Equals(ConllUSecondaryDeps, other.ConllUSecondaryDeps)) return false;
      if (WikipediaEntity != other.WikipediaEntity) return false;
      if (IsNewline != other.IsNewline) return false;
      if (Gender != other.Gender) return false;
      if (TrueCase != other.TrueCase) return false;
      if (TrueCaseText != other.TrueCaseText) return false;
      if (ChineseChar != other.ChineseChar) return false;
      if (ChineseSeg != other.ChineseSeg) return false;
      if (ChineseXMLChar != other.ChineseXMLChar) return false;
      if (ArabicSeg != other.ArabicSeg) return false;
      if (SectionName != other.SectionName) return false;
      if (SectionAuthor != other.SectionAuthor) return false;
      if (SectionDate != other.SectionDate) return false;
      if (SectionEndLabel != other.SectionEndLabel) return false;
      if (Parent != other.Parent) return false;
      if(!corefMentionIndex_.Equals(other.corefMentionIndex_)) return false;
      if (EntityMentionIndex != other.EntityMentionIndex) return false;
      if (IsMWT != other.IsMWT) return false;
      if (IsFirstMWT != other.IsFirstMWT) return false;
      if (MwtText != other.MwtText) return false;
      if (NumericValue != other.NumericValue) return false;
      if (NumericType != other.NumericType) return false;
      if (NumericCompositeValue != other.NumericCompositeValue) return false;
      if (NumericCompositeType != other.NumericCompositeType) return false;
      if (CodepointOffsetBegin != other.CodepointOffsetBegin) return false;
      if (CodepointOffsetEnd != other.CodepointOffsetEnd) return false;
      if (!Equals(_extensions, other._extensions)) {
        return false;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasWord) hash ^= Word.GetHashCode();
      if (HasPos) hash ^= Pos.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (HasCategory) hash ^= Category.GetHashCode();
      if (HasBefore) hash ^= Before.GetHashCode();
      if (HasAfter) hash ^= After.GetHashCode();
      if (HasOriginalText) hash ^= OriginalText.GetHashCode();
      if (HasNer) hash ^= Ner.GetHashCode();
      if (HasCoarseNER) hash ^= CoarseNER.GetHashCode();
      if (HasFineGrainedNER) hash ^= FineGrainedNER.GetHashCode();
      hash ^= nerLabelProbs_.GetHashCode();
      if (HasNormalizedNER) hash ^= NormalizedNER.GetHashCode();
      if (HasLemma) hash ^= Lemma.GetHashCode();
      if (HasBeginChar) hash ^= BeginChar.GetHashCode();
      if (HasEndChar) hash ^= EndChar.GetHashCode();
      if (HasUtterance) hash ^= Utterance.GetHashCode();
      if (HasSpeaker) hash ^= Speaker.GetHashCode();
      if (HasSpeakerType) hash ^= SpeakerType.GetHashCode();
      if (HasBeginIndex) hash ^= BeginIndex.GetHashCode();
      if (HasEndIndex) hash ^= EndIndex.GetHashCode();
      if (HasTokenBeginIndex) hash ^= TokenBeginIndex.GetHashCode();
      if (HasTokenEndIndex) hash ^= TokenEndIndex.GetHashCode();
      if (timexValue_ != null) hash ^= TimexValue.GetHashCode();
      if (HasHasXmlContext) hash ^= HasXmlContext.GetHashCode();
      hash ^= xmlContext_.GetHashCode();
      if (HasCorefClusterID) hash ^= CorefClusterID.GetHashCode();
      if (HasAnswer) hash ^= Answer.GetHashCode();
      if (HasHeadWordIndex) hash ^= HeadWordIndex.GetHashCode();
      if (operator_ != null) hash ^= Operator.GetHashCode();
      if (polarity_ != null) hash ^= Polarity.GetHashCode();
      if (HasPolarityDir) hash ^= PolarityDir.GetHashCode();
      if (span_ != null) hash ^= Span.GetHashCode();
      if (HasSentiment) hash ^= Sentiment.GetHashCode();
      if (HasQuotationIndex) hash ^= QuotationIndex.GetHashCode();
      if (conllUFeatures_ != null) hash ^= ConllUFeatures.GetHashCode();
      if (HasCoarseTag) hash ^= CoarseTag.GetHashCode();
      if (conllUTokenSpan_ != null) hash ^= ConllUTokenSpan.GetHashCode();
      if (HasConllUMisc) hash ^= ConllUMisc.GetHashCode();
      if (conllUSecondaryDeps_ != null) hash ^= ConllUSecondaryDeps.GetHashCode();
      if (HasWikipediaEntity) hash ^= WikipediaEntity.GetHashCode();
      if (HasIsNewline) hash ^= IsNewline.GetHashCode();
      if (HasGender) hash ^= Gender.GetHashCode();
      if (HasTrueCase) hash ^= TrueCase.GetHashCode();
      if (HasTrueCaseText) hash ^= TrueCaseText.GetHashCode();
      if (HasChineseChar) hash ^= ChineseChar.GetHashCode();
      if (HasChineseSeg) hash ^= ChineseSeg.GetHashCode();
      if (HasChineseXMLChar) hash ^= ChineseXMLChar.GetHashCode();
      if (HasArabicSeg) hash ^= ArabicSeg.GetHashCode();
      if (HasSectionName) hash ^= SectionName.GetHashCode();
      if (HasSectionAuthor) hash ^= SectionAuthor.GetHashCode();
      if (HasSectionDate) hash ^= SectionDate.GetHashCode();
      if (HasSectionEndLabel) hash ^= SectionEndLabel.GetHashCode();
      if (HasParent) hash ^= Parent.GetHashCode();
      hash ^= corefMentionIndex_.GetHashCode();
      if (HasEntityMentionIndex) hash ^= EntityMentionIndex.GetHashCode();
      if (HasIsMWT) hash ^= IsMWT.GetHashCode();
      if (HasIsFirstMWT) hash ^= IsFirstMWT.GetHashCode();
      if (HasMwtText) hash ^= MwtText.GetHashCode();
      if (HasNumericValue) hash ^= NumericValue.GetHashCode();
      if (HasNumericType) hash ^= NumericType.GetHashCode();
      if (HasNumericCompositeValue) hash ^= NumericCompositeValue.GetHashCode();
      if (HasNumericCompositeType) hash ^= NumericCompositeType.GetHashCode();
      if (HasCodepointOffsetBegin) hash ^= CodepointOffsetBegin.GetHashCode();
      if (HasCodepointOffsetEnd) hash ^= CodepointOffsetEnd.GetHashCode();
      if (_extensions != null) {
        hash ^= _extensions.GetHashCode();
      }
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasWord) {
        output.WriteRawTag(10);
        output.WriteString(Word);
      }
      if (HasPos) {
        output.WriteRawTag(18);
        output.WriteString(Pos);
      }
      if (HasValue) {
        output.WriteRawTag(26);
        output.WriteString(Value);
      }
      if (HasCategory) {
        output.WriteRawTag(34);
        output.WriteString(Category);
      }
      if (HasBefore) {
        output.WriteRawTag(42);
        output.WriteString(Before);
      }
      if (HasAfter) {
        output.WriteRawTag(50);
        output.WriteString(After);
      }
      if (HasOriginalText) {
        output.WriteRawTag(58);
        output.WriteString(OriginalText);
      }
      if (HasNer) {
        output.WriteRawTag(66);
        output.WriteString(Ner);
      }
      if (HasNormalizedNER) {
        output.WriteRawTag(74);
        output.WriteString(NormalizedNER);
      }
      if (HasLemma) {
        output.WriteRawTag(82);
        output.WriteString(Lemma);
      }
      if (HasBeginChar) {
        output.WriteRawTag(88);
        output.WriteUInt32(BeginChar);
      }
      if (HasEndChar) {
        output.WriteRawTag(96);
        output.WriteUInt32(EndChar);
      }
      if (HasUtterance) {
        output.WriteRawTag(104);
        output.WriteUInt32(Utterance);
      }
      if (HasSpeaker) {
        output.WriteRawTag(114);
        output.WriteString(Speaker);
      }
      if (HasBeginIndex) {
        output.WriteRawTag(120);
        output.WriteUInt32(BeginIndex);
      }
      if (HasEndIndex) {
        output.WriteRawTag(128, 1);
        output.WriteUInt32(EndIndex);
      }
      if (HasTokenBeginIndex) {
        output.WriteRawTag(136, 1);
        output.WriteUInt32(TokenBeginIndex);
      }
      if (HasTokenEndIndex) {
        output.WriteRawTag(144, 1);
        output.WriteUInt32(TokenEndIndex);
      }
      if (timexValue_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(TimexValue);
      }
      if (HasHasXmlContext) {
        output.WriteRawTag(168, 1);
        output.WriteBool(HasXmlContext);
      }
      xmlContext_.WriteTo(output, _repeated_xmlContext_codec);
      if (HasCorefClusterID) {
        output.WriteRawTag(184, 1);
        output.WriteUInt32(CorefClusterID);
      }
      if (HasAnswer) {
        output.WriteRawTag(194, 1);
        output.WriteString(Answer);
      }
      if (HasHeadWordIndex) {
        output.WriteRawTag(208, 1);
        output.WriteUInt32(HeadWordIndex);
      }
      if (operator_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(Operator);
      }
      if (polarity_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(Polarity);
      }
      if (span_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(Span);
      }
      if (HasSentiment) {
        output.WriteRawTag(242, 1);
        output.WriteString(Sentiment);
      }
      if (HasQuotationIndex) {
        output.WriteRawTag(248, 1);
        output.WriteInt32(QuotationIndex);
      }
      if (conllUFeatures_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(ConllUFeatures);
      }
      if (HasCoarseTag) {
        output.WriteRawTag(138, 2);
        output.WriteString(CoarseTag);
      }
      if (conllUTokenSpan_ != null) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(ConllUTokenSpan);
      }
      if (HasConllUMisc) {
        output.WriteRawTag(154, 2);
        output.WriteString(ConllUMisc);
      }
      if (conllUSecondaryDeps_ != null) {
        output.WriteRawTag(162, 2);
        output.WriteMessage(ConllUSecondaryDeps);
      }
      if (HasWikipediaEntity) {
        output.WriteRawTag(170, 2);
        output.WriteString(WikipediaEntity);
      }
      if (HasIsNewline) {
        output.WriteRawTag(176, 2);
        output.WriteBool(IsNewline);
      }
      if (HasPolarityDir) {
        output.WriteRawTag(186, 2);
        output.WriteString(PolarityDir);
      }
      if (HasGender) {
        output.WriteRawTag(154, 3);
        output.WriteString(Gender);
      }
      if (HasTrueCase) {
        output.WriteRawTag(162, 3);
        output.WriteString(TrueCase);
      }
      if (HasTrueCaseText) {
        output.WriteRawTag(170, 3);
        output.WriteString(TrueCaseText);
      }
      if (HasChineseChar) {
        output.WriteRawTag(178, 3);
        output.WriteString(ChineseChar);
      }
      if (HasChineseSeg) {
        output.WriteRawTag(186, 3);
        output.WriteString(ChineseSeg);
      }
      if (HasSectionName) {
        output.WriteRawTag(194, 3);
        output.WriteString(SectionName);
      }
      if (HasSectionAuthor) {
        output.WriteRawTag(202, 3);
        output.WriteString(SectionAuthor);
      }
      if (HasSectionDate) {
        output.WriteRawTag(210, 3);
        output.WriteString(SectionDate);
      }
      if (HasSectionEndLabel) {
        output.WriteRawTag(218, 3);
        output.WriteString(SectionEndLabel);
      }
      if (HasChineseXMLChar) {
        output.WriteRawTag(226, 3);
        output.WriteString(ChineseXMLChar);
      }
      if (HasParent) {
        output.WriteRawTag(234, 3);
        output.WriteString(Parent);
      }
      if (HasCoarseNER) {
        output.WriteRawTag(242, 3);
        output.WriteString(CoarseNER);
      }
      if (HasFineGrainedNER) {
        output.WriteRawTag(250, 3);
        output.WriteString(FineGrainedNER);
      }
      corefMentionIndex_.WriteTo(output, _repeated_corefMentionIndex_codec);
      if (HasEntityMentionIndex) {
        output.WriteRawTag(136, 4);
        output.WriteUInt32(EntityMentionIndex);
      }
      nerLabelProbs_.WriteTo(output, _repeated_nerLabelProbs_codec);
      if (HasIsMWT) {
        output.WriteRawTag(152, 4);
        output.WriteBool(IsMWT);
      }
      if (HasIsFirstMWT) {
        output.WriteRawTag(160, 4);
        output.WriteBool(IsFirstMWT);
      }
      if (HasMwtText) {
        output.WriteRawTag(170, 4);
        output.WriteString(MwtText);
      }
      if (HasNumericValue) {
        output.WriteRawTag(176, 4);
        output.WriteUInt64(NumericValue);
      }
      if (HasNumericType) {
        output.WriteRawTag(186, 4);
        output.WriteString(NumericType);
      }
      if (HasNumericCompositeValue) {
        output.WriteRawTag(192, 4);
        output.WriteUInt64(NumericCompositeValue);
      }
      if (HasNumericCompositeType) {
        output.WriteRawTag(202, 4);
        output.WriteString(NumericCompositeType);
      }
      if (HasCodepointOffsetBegin) {
        output.WriteRawTag(208, 4);
        output.WriteUInt32(CodepointOffsetBegin);
      }
      if (HasCodepointOffsetEnd) {
        output.WriteRawTag(216, 4);
        output.WriteUInt32(CodepointOffsetEnd);
      }
      if (HasArabicSeg) {
        output.WriteRawTag(226, 4);
        output.WriteString(ArabicSeg);
      }
      if (HasSpeakerType) {
        output.WriteRawTag(234, 4);
        output.WriteString(SpeakerType);
      }
      if (_extensions != null) {
        _extensions.WriteTo(output);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasWord) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Word);
      }
      if (HasPos) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Pos);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (HasCategory) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Category);
      }
      if (HasBefore) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Before);
      }
      if (HasAfter) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(After);
      }
      if (HasOriginalText) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OriginalText);
      }
      if (HasNer) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ner);
      }
      if (HasCoarseNER) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CoarseNER);
      }
      if (HasFineGrainedNER) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(FineGrainedNER);
      }
      size += nerLabelProbs_.CalculateSize(_repeated_nerLabelProbs_codec);
      if (HasNormalizedNER) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NormalizedNER);
      }
      if (HasLemma) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Lemma);
      }
      if (HasBeginChar) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BeginChar);
      }
      if (HasEndChar) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EndChar);
      }
      if (HasUtterance) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Utterance);
      }
      if (HasSpeaker) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Speaker);
      }
      if (HasSpeakerType) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SpeakerType);
      }
      if (HasBeginIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BeginIndex);
      }
      if (HasEndIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(EndIndex);
      }
      if (HasTokenBeginIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(TokenBeginIndex);
      }
      if (HasTokenEndIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(TokenEndIndex);
      }
      if (timexValue_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TimexValue);
      }
      if (HasHasXmlContext) {
        size += 2 + 1;
      }
      size += xmlContext_.CalculateSize(_repeated_xmlContext_codec);
      if (HasCorefClusterID) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(CorefClusterID);
      }
      if (HasAnswer) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Answer);
      }
      if (HasHeadWordIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(HeadWordIndex);
      }
      if (operator_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Operator);
      }
      if (polarity_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Polarity);
      }
      if (HasPolarityDir) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(PolarityDir);
      }
      if (span_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Span);
      }
      if (HasSentiment) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Sentiment);
      }
      if (HasQuotationIndex) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(QuotationIndex);
      }
      if (conllUFeatures_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ConllUFeatures);
      }
      if (HasCoarseTag) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CoarseTag);
      }
      if (conllUTokenSpan_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ConllUTokenSpan);
      }
      if (HasConllUMisc) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ConllUMisc);
      }
      if (conllUSecondaryDeps_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ConllUSecondaryDeps);
      }
      if (HasWikipediaEntity) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(WikipediaEntity);
      }
      if (HasIsNewline) {
        size += 2 + 1;
      }
      if (HasGender) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Gender);
      }
      if (HasTrueCase) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(TrueCase);
      }
      if (HasTrueCaseText) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(TrueCaseText);
      }
      if (HasChineseChar) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ChineseChar);
      }
      if (HasChineseSeg) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ChineseSeg);
      }
      if (HasChineseXMLChar) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ChineseXMLChar);
      }
      if (HasArabicSeg) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ArabicSeg);
      }
      if (HasSectionName) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SectionName);
      }
      if (HasSectionAuthor) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SectionAuthor);
      }
      if (HasSectionDate) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SectionDate);
      }
      if (HasSectionEndLabel) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SectionEndLabel);
      }
      if (HasParent) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      size += corefMentionIndex_.CalculateSize(_repeated_corefMentionIndex_codec);
      if (HasEntityMentionIndex) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(EntityMentionIndex);
      }
      if (HasIsMWT) {
        size += 2 + 1;
      }
      if (HasIsFirstMWT) {
        size += 2 + 1;
      }
      if (HasMwtText) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(MwtText);
      }
      if (HasNumericValue) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(NumericValue);
      }
      if (HasNumericType) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(NumericType);
      }
      if (HasNumericCompositeValue) {
        size += 2 + pb::CodedOutputStream.ComputeUInt64Size(NumericCompositeValue);
      }
      if (HasNumericCompositeType) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(NumericCompositeType);
      }
      if (HasCodepointOffsetBegin) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(CodepointOffsetBegin);
      }
      if (HasCodepointOffsetEnd) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(CodepointOffsetEnd);
      }
      if (_extensions != null) {
        size += _extensions.CalculateSize();
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Token other) {
      if (other == null) {
        return;
      }
      if (other.HasWord) {
        Word = other.Word;
      }
      if (other.HasPos) {
        Pos = other.Pos;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasCategory) {
        Category = other.Category;
      }
      if (other.HasBefore) {
        Before = other.Before;
      }
      if (other.HasAfter) {
        After = other.After;
      }
      if (other.HasOriginalText) {
        OriginalText = other.OriginalText;
      }
      if (other.HasNer) {
        Ner = other.Ner;
      }
      if (other.HasCoarseNER) {
        CoarseNER = other.CoarseNER;
      }
      if (other.HasFineGrainedNER) {
        FineGrainedNER = other.FineGrainedNER;
      }
      nerLabelProbs_.Add(other.nerLabelProbs_);
      if (other.HasNormalizedNER) {
        NormalizedNER = other.NormalizedNER;
      }
      if (other.HasLemma) {
        Lemma = other.Lemma;
      }
      if (other.HasBeginChar) {
        BeginChar = other.BeginChar;
      }
      if (other.HasEndChar) {
        EndChar = other.EndChar;
      }
      if (other.HasUtterance) {
        Utterance = other.Utterance;
      }
      if (other.HasSpeaker) {
        Speaker = other.Speaker;
      }
      if (other.HasSpeakerType) {
        SpeakerType = other.SpeakerType;
      }
      if (other.HasBeginIndex) {
        BeginIndex = other.BeginIndex;
      }
      if (other.HasEndIndex) {
        EndIndex = other.EndIndex;
      }
      if (other.HasTokenBeginIndex) {
        TokenBeginIndex = other.TokenBeginIndex;
      }
      if (other.HasTokenEndIndex) {
        TokenEndIndex = other.TokenEndIndex;
      }
      if (other.timexValue_ != null) {
        if (timexValue_ == null) {
          TimexValue = new global::Edu.Stanford.Nlp.Pipeline.Timex();
        }
        TimexValue.MergeFrom(other.TimexValue);
      }
      if (other.HasHasXmlContext) {
        HasXmlContext = other.HasXmlContext;
      }
      xmlContext_.Add(other.xmlContext_);
      if (other.HasCorefClusterID) {
        CorefClusterID = other.CorefClusterID;
      }
      if (other.HasAnswer) {
        Answer = other.Answer;
      }
      if (other.HasHeadWordIndex) {
        HeadWordIndex = other.HeadWordIndex;
      }
      if (other.operator_ != null) {
        if (operator_ == null) {
          Operator = new global::Edu.Stanford.Nlp.Pipeline.Operator();
        }
        Operator.MergeFrom(other.Operator);
      }
      if (other.polarity_ != null) {
        if (polarity_ == null) {
          Polarity = new global::Edu.Stanford.Nlp.Pipeline.Polarity();
        }
        Polarity.MergeFrom(other.Polarity);
      }
      if (other.HasPolarityDir) {
        PolarityDir = other.PolarityDir;
      }
      if (other.span_ != null) {
        if (span_ == null) {
          Span = new global::Edu.Stanford.Nlp.Pipeline.Span();
        }
        Span.MergeFrom(other.Span);
      }
      if (other.HasSentiment) {
        Sentiment = other.Sentiment;
      }
      if (other.HasQuotationIndex) {
        QuotationIndex = other.QuotationIndex;
      }
      if (other.conllUFeatures_ != null) {
        if (conllUFeatures_ == null) {
          ConllUFeatures = new global::Edu.Stanford.Nlp.Pipeline.MapStringString();
        }
        ConllUFeatures.MergeFrom(other.ConllUFeatures);
      }
      if (other.HasCoarseTag) {
        CoarseTag = other.CoarseTag;
      }
      if (other.conllUTokenSpan_ != null) {
        if (conllUTokenSpan_ == null) {
          ConllUTokenSpan = new global::Edu.Stanford.Nlp.Pipeline.Span();
        }
        ConllUTokenSpan.MergeFrom(other.ConllUTokenSpan);
      }
      if (other.HasConllUMisc) {
        ConllUMisc = other.ConllUMisc;
      }
      if (other.conllUSecondaryDeps_ != null) {
        if (conllUSecondaryDeps_ == null) {
          ConllUSecondaryDeps = new global::Edu.Stanford.Nlp.Pipeline.MapStringString();
        }
        ConllUSecondaryDeps.MergeFrom(other.ConllUSecondaryDeps);
      }
      if (other.HasWikipediaEntity) {
        WikipediaEntity = other.WikipediaEntity;
      }
      if (other.HasIsNewline) {
        IsNewline = other.IsNewline;
      }
      if (other.HasGender) {
        Gender = other.Gender;
      }
      if (other.HasTrueCase) {
        TrueCase = other.TrueCase;
      }
      if (other.HasTrueCaseText) {
        TrueCaseText = other.TrueCaseText;
      }
      if (other.HasChineseChar) {
        ChineseChar = other.ChineseChar;
      }
      if (other.HasChineseSeg) {
        ChineseSeg = other.ChineseSeg;
      }
      if (other.HasChineseXMLChar) {
        ChineseXMLChar = other.ChineseXMLChar;
      }
      if (other.HasArabicSeg) {
        ArabicSeg = other.ArabicSeg;
      }
      if (other.HasSectionName) {
        SectionName = other.SectionName;
      }
      if (other.HasSectionAuthor) {
        SectionAuthor = other.SectionAuthor;
      }
      if (other.HasSectionDate) {
        SectionDate = other.SectionDate;
      }
      if (other.HasSectionEndLabel) {
        SectionEndLabel = other.SectionEndLabel;
      }
      if (other.HasParent) {
        Parent = other.Parent;
      }
      corefMentionIndex_.Add(other.corefMentionIndex_);
      if (other.HasEntityMentionIndex) {
        EntityMentionIndex = other.EntityMentionIndex;
      }
      if (other.HasIsMWT) {
        IsMWT = other.IsMWT;
      }
      if (other.HasIsFirstMWT) {
        IsFirstMWT = other.IsFirstMWT;
      }
      if (other.HasMwtText) {
        MwtText = other.MwtText;
      }
      if (other.HasNumericValue) {
        NumericValue = other.NumericValue;
      }
      if (other.HasNumericType) {
        NumericType = other.NumericType;
      }
      if (other.HasNumericCompositeValue) {
        NumericCompositeValue = other.NumericCompositeValue;
      }
      if (other.HasNumericCompositeType) {
        NumericCompositeType = other.NumericCompositeType;
      }
      if (other.HasCodepointOffsetBegin) {
        CodepointOffsetBegin = other.CodepointOffsetBegin;
      }
      if (other.HasCodepointOffsetEnd) {
        CodepointOffsetEnd = other.CodepointOffsetEnd;
      }
      pb::ExtensionSet.MergeFrom(ref _extensions, other._extensions);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            if (!pb::ExtensionSet.TryMergeFieldFrom(ref _extensions, input)) {
              _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            }
            break;
          case 10: {
            Word = input.ReadString();
            break;
          }
          case 18: {
            Pos = input.ReadString();
            break;
          }
          case 26: {
            Value = input.ReadString();
            break;
          }
          case 34: {
            Category = input.ReadString();
            break;
          }
          case 42: {
            Before = input.ReadString();
            break;
          }
          case 50: {
            After = input.ReadString();
            break;
          }
          case 58: {
            OriginalText = input.ReadString();
            break;
          }
          case 66: {
            Ner = input.ReadString();
            break;
          }
          case 74: {
            NormalizedNER = input.ReadString();
            break;
          }
          case 82: {
            Lemma = input.ReadString();
            break;
          }
          case 88: {
            BeginChar = input.ReadUInt32();
            break;
          }
          case 96: {
            EndChar = input.ReadUInt32();
            break;
          }
          case 104: {
            Utterance = input.ReadUInt32();
            break;
          }
          case 114: {
            Speaker = input.ReadString();
            break;
          }
          case 120: {
            BeginIndex = input.ReadUInt32();
            break;
          }
          case 128: {
            EndIndex = input.ReadUInt32();
            break;
          }
          case 136: {
            TokenBeginIndex = input.ReadUInt32();
            break;
          }
          case 144: {
            TokenEndIndex = input.ReadUInt32();
            break;
          }
          case 154: {
            if (timexValue_ == null) {
              TimexValue = new global::Edu.Stanford.Nlp.Pipeline.Timex();
            }
            input.ReadMessage(TimexValue);
            break;
          }
          case 168: {
            HasXmlContext = input.ReadBool();
            break;
          }
          case 178: {
            xmlContext_.AddEntriesFrom(input, _repeated_xmlContext_codec);
            break;
          }
          case 184: {
            CorefClusterID = input.ReadUInt32();
            break;
          }
          case 194: {
            Answer = input.ReadString();
            break;
          }
          case 208: {
            HeadWordIndex = input.ReadUInt32();
            break;
          }
          case 218: {
            if (operator_ == null) {
              Operator = new global::Edu.Stanford.Nlp.Pipeline.Operator();
            }
            input.ReadMessage(Operator);
            break;
          }
          case 226: {
            if (polarity_ == null) {
              Polarity = new global::Edu.Stanford.Nlp.Pipeline.Polarity();
            }
            input.ReadMessage(Polarity);
            break;
          }
          case 234: {
            if (span_ == null) {
              Span = new global::Edu.Stanford.Nlp.Pipeline.Span();
            }
            input.ReadMessage(Span);
            break;
          }
          case 242: {
            Sentiment = input.ReadString();
            break;
          }
          case 248: {
            QuotationIndex = input.ReadInt32();
            break;
          }
          case 258: {
            if (conllUFeatures_ == null) {
              ConllUFeatures = new global::Edu.Stanford.Nlp.Pipeline.MapStringString();
            }
            input.ReadMessage(ConllUFeatures);
            break;
          }
          case 266: {
            CoarseTag = input.ReadString();
            break;
          }
          case 274: {
            if (conllUTokenSpan_ == null) {
              ConllUTokenSpan = new global::Edu.Stanford.Nlp.Pipeline.Span();
            }
            input.ReadMessage(ConllUTokenSpan);
            break;
          }
          case 282: {
            ConllUMisc = input.ReadString();
            break;
          }
          case 290: {
            if (conllUSecondaryDeps_ == null) {
              ConllUSecondaryDeps = new global::Edu.Stanford.Nlp.Pipeline.MapStringString();
            }
            input.ReadMessage(ConllUSecondaryDeps);
            break;
          }
          case 298: {
            WikipediaEntity = input.ReadString();
            break;
          }
          case 304: {
            IsNewline = input.ReadBool();
            break;
          }
          case 314: {
            PolarityDir = input.ReadString();
            break;
          }
          case 410: {
            Gender = input.ReadString();
            break;
          }
          case 418: {
            TrueCase = input.ReadString();
            break;
          }
          case 426: {
            TrueCaseText = input.ReadString();
            break;
          }
          case 434: {
            ChineseChar = input.ReadString();
            break;
          }
          case 442: {
            ChineseSeg = input.ReadString();
            break;
          }
          case 450: {
            SectionName = input.ReadString();
            break;
          }
          case 458: {
            SectionAuthor = input.ReadString();
            break;
          }
          case 466: {
            SectionDate = input.ReadString();
            break;
          }
          case 474: {
            SectionEndLabel = input.ReadString();
            break;
          }
          case 482: {
            ChineseXMLChar = input.ReadString();
            break;
          }
          case 490: {
            Parent = input.ReadString();
            break;
          }
          case 498: {
            CoarseNER = input.ReadString();
            break;
          }
          case 506: {
            FineGrainedNER = input.ReadString();
            break;
          }
          case 514:
          case 512: {
            corefMentionIndex_.AddEntriesFrom(input, _repeated_corefMentionIndex_codec);
            break;
          }
          case 520: {
            EntityMentionIndex = input.ReadUInt32();
            break;
          }
          case 530: {
            nerLabelProbs_.AddEntriesFrom(input, _repeated_nerLabelProbs_codec);
            break;
          }
          case 536: {
            IsMWT = input.ReadBool();
            break;
          }
          case 544: {
            IsFirstMWT = input.ReadBool();
            break;
          }
          case 554: {
            MwtText = input.ReadString();
            break;
          }
          case 560: {
            NumericValue = input.ReadUInt64();
            break;
          }
          case 570: {
            NumericType = input.ReadString();
            break;
          }
          case 576: {
            NumericCompositeValue = input.ReadUInt64();
            break;
          }
          case 586: {
            NumericCompositeType = input.ReadString();
            break;
          }
          case 592: {
            CodepointOffsetBegin = input.ReadUInt32();
            break;
          }
          case 600: {
            CodepointOffsetEnd = input.ReadUInt32();
            break;
          }
          case 610: {
            ArabicSeg = input.ReadString();
            break;
          }
          case 618: {
            SpeakerType = input.ReadString();
            break;
          }
        }
      }
    }

    public TValue GetExtension<TValue>(pb::Extension<Token, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetExtension<TValue>(pb::RepeatedExtension<Token, TValue> extension) {
      return pb::ExtensionSet.Get(ref _extensions, extension);
    }
    public pbc::RepeatedField<TValue> GetOrInitializeExtension<TValue>(pb::RepeatedExtension<Token, TValue> extension) {
      return pb::ExtensionSet.GetOrInitialize(ref _extensions, extension);
    }
    public void SetExtension<TValue>(pb::Extension<Token, TValue> extension, TValue value) {
      pb::ExtensionSet.Set(ref _extensions, extension, value);
    }
    public bool HasExtension<TValue>(pb::Extension<Token, TValue> extension) {
      return pb::ExtensionSet.Has(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::Extension<Token, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }
    public void ClearExtension<TValue>(pb::RepeatedExtension<Token, TValue> extension) {
      pb::ExtensionSet.Clear(ref _extensions, extension);
    }

  }

  /// <summary>
  ///
  /// A quotation marker in text
  /// </summary>
  public sealed partial class Quote : pb::IMessage<Quote> {
    private static readonly pb::MessageParser<Quote> _parser = new pb::MessageParser<Quote>(() => new Quote());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Quote> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Quote() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Quote(Quote other) : this() {
      _hasBits0 = other._hasBits0;
      text_ = other.text_;
      begin_ = other.begin_;
      end_ = other.end_;
      sentenceBegin_ = other.sentenceBegin_;
      sentenceEnd_ = other.sentenceEnd_;
      tokenBegin_ = other.tokenBegin_;
      tokenEnd_ = other.tokenEnd_;
      docid_ = other.docid_;
      index_ = other.index_;
      author_ = other.author_;
      mention_ = other.mention_;
      mentionBegin_ = other.mentionBegin_;
      mentionEnd_ = other.mentionEnd_;
      mentionType_ = other.mentionType_;
      mentionSieve_ = other.mentionSieve_;
      speaker_ = other.speaker_;
      speakerSieve_ = other.speakerSieve_;
      canonicalMention_ = other.canonicalMention_;
      canonicalMentionBegin_ = other.canonicalMentionBegin_;
      canonicalMentionEnd_ = other.canonicalMentionEnd_;
      attributionDependencyGraph_ = other.attributionDependencyGraph_ != null ? other.attributionDependencyGraph_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Quote Clone() {
      return new Quote(this);
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 1;
    private readonly static string TextDefaultValue = "";

    private string text_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Text {
      get { return text_ ?? TextDefaultValue; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasText {
      get { return text_ != null; }
    }
    /// <summary>Clears the value of the "text" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearText() {
      text_ = null;
    }

    /// <summary>Field number for the "begin" field.</summary>
    public const int BeginFieldNumber = 2;
    private readonly static uint BeginDefaultValue = 0;

    private uint begin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Begin {
      get { if ((_hasBits0 & 1) != 0) { return begin_; } else { return BeginDefaultValue; } }
      set {
        _hasBits0 |= 1;
        begin_ = value;
      }
    }
    /// <summary>Gets whether the "begin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBegin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "begin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBegin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "end" field.</summary>
    public const int EndFieldNumber = 3;
    private readonly static uint EndDefaultValue = 0;

    private uint end_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint End {
      get { if ((_hasBits0 & 2) != 0) { return end_; } else { return EndDefaultValue; } }
      set {
        _hasBits0 |= 2;
        end_ = value;
      }
    }
    /// <summary>Gets whether the "end" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEnd {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "end" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEnd() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "sentenceBegin" field.</summary>
    public const int SentenceBeginFieldNumber = 5;
    private readonly static uint SentenceBeginDefaultValue = 0;

    private uint sentenceBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SentenceBegin {
      get { if ((_hasBits0 & 4) != 0) { return sentenceBegin_; } else { return SentenceBeginDefaultValue; } }
      set {
        _hasBits0 |= 4;
        sentenceBegin_ = value;
      }
    }
    /// <summary>Gets whether the "sentenceBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentenceBegin {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "sentenceBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentenceBegin() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "sentenceEnd" field.</summary>
    public const int SentenceEndFieldNumber = 6;
    private readonly static uint SentenceEndDefaultValue = 0;

    private uint sentenceEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SentenceEnd {
      get { if ((_hasBits0 & 8) != 0) { return sentenceEnd_; } else { return SentenceEndDefaultValue; } }
      set {
        _hasBits0 |= 8;
        sentenceEnd_ = value;
      }
    }
    /// <summary>Gets whether the "sentenceEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentenceEnd {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "sentenceEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentenceEnd() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "tokenBegin" field.</summary>
    public const int TokenBeginFieldNumber = 7;
    private readonly static uint TokenBeginDefaultValue = 0;

    private uint tokenBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenBegin {
      get { if ((_hasBits0 & 16) != 0) { return tokenBegin_; } else { return TokenBeginDefaultValue; } }
      set {
        _hasBits0 |= 16;
        tokenBegin_ = value;
      }
    }
    /// <summary>Gets whether the "tokenBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenBegin {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "tokenBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenBegin() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "tokenEnd" field.</summary>
    public const int TokenEndFieldNumber = 8;
    private readonly static uint TokenEndDefaultValue = 0;

    private uint tokenEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenEnd {
      get { if ((_hasBits0 & 32) != 0) { return tokenEnd_; } else { return TokenEndDefaultValue; } }
      set {
        _hasBits0 |= 32;
        tokenEnd_ = value;
      }
    }
    /// <summary>Gets whether the "tokenEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenEnd {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "tokenEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenEnd() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "docid" field.</summary>
    public const int DocidFieldNumber = 9;
    private readonly static string DocidDefaultValue = "";

    private string docid_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Docid {
      get { return docid_ ?? DocidDefaultValue; }
      set {
        docid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "docid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDocid {
      get { return docid_ != null; }
    }
    /// <summary>Clears the value of the "docid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDocid() {
      docid_ = null;
    }

    /// <summary>Field number for the "index" field.</summary>
    public const int IndexFieldNumber = 10;
    private readonly static uint IndexDefaultValue = 0;

    private uint index_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Index {
      get { if ((_hasBits0 & 64) != 0) { return index_; } else { return IndexDefaultValue; } }
      set {
        _hasBits0 |= 64;
        index_ = value;
      }
    }
    /// <summary>Gets whether the "index" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIndex {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "index" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIndex() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "author" field.</summary>
    public const int AuthorFieldNumber = 11;
    private readonly static string AuthorDefaultValue = "";

    private string author_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Author {
      get { return author_ ?? AuthorDefaultValue; }
      set {
        author_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "author" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAuthor {
      get { return author_ != null; }
    }
    /// <summary>Clears the value of the "author" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAuthor() {
      author_ = null;
    }

    /// <summary>Field number for the "mention" field.</summary>
    public const int MentionFieldNumber = 12;
    private readonly static string MentionDefaultValue = "";

    private string mention_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Mention {
      get { return mention_ ?? MentionDefaultValue; }
      set {
        mention_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mention" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMention {
      get { return mention_ != null; }
    }
    /// <summary>Clears the value of the "mention" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMention() {
      mention_ = null;
    }

    /// <summary>Field number for the "mentionBegin" field.</summary>
    public const int MentionBeginFieldNumber = 13;
    private readonly static uint MentionBeginDefaultValue = 0;

    private uint mentionBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MentionBegin {
      get { if ((_hasBits0 & 128) != 0) { return mentionBegin_; } else { return MentionBeginDefaultValue; } }
      set {
        _hasBits0 |= 128;
        mentionBegin_ = value;
      }
    }
    /// <summary>Gets whether the "mentionBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMentionBegin {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "mentionBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMentionBegin() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "mentionEnd" field.</summary>
    public const int MentionEndFieldNumber = 14;
    private readonly static uint MentionEndDefaultValue = 0;

    private uint mentionEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MentionEnd {
      get { if ((_hasBits0 & 256) != 0) { return mentionEnd_; } else { return MentionEndDefaultValue; } }
      set {
        _hasBits0 |= 256;
        mentionEnd_ = value;
      }
    }
    /// <summary>Gets whether the "mentionEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMentionEnd {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "mentionEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMentionEnd() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "mentionType" field.</summary>
    public const int MentionTypeFieldNumber = 15;
    private readonly static string MentionTypeDefaultValue = "";

    private string mentionType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MentionType {
      get { return mentionType_ ?? MentionTypeDefaultValue; }
      set {
        mentionType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mentionType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMentionType {
      get { return mentionType_ != null; }
    }
    /// <summary>Clears the value of the "mentionType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMentionType() {
      mentionType_ = null;
    }

    /// <summary>Field number for the "mentionSieve" field.</summary>
    public const int MentionSieveFieldNumber = 16;
    private readonly static string MentionSieveDefaultValue = "";

    private string mentionSieve_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MentionSieve {
      get { return mentionSieve_ ?? MentionSieveDefaultValue; }
      set {
        mentionSieve_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mentionSieve" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMentionSieve {
      get { return mentionSieve_ != null; }
    }
    /// <summary>Clears the value of the "mentionSieve" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMentionSieve() {
      mentionSieve_ = null;
    }

    /// <summary>Field number for the "speaker" field.</summary>
    public const int SpeakerFieldNumber = 17;
    private readonly static string SpeakerDefaultValue = "";

    private string speaker_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Speaker {
      get { return speaker_ ?? SpeakerDefaultValue; }
      set {
        speaker_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "speaker" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeaker {
      get { return speaker_ != null; }
    }
    /// <summary>Clears the value of the "speaker" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeaker() {
      speaker_ = null;
    }

    /// <summary>Field number for the "speakerSieve" field.</summary>
    public const int SpeakerSieveFieldNumber = 18;
    private readonly static string SpeakerSieveDefaultValue = "";

    private string speakerSieve_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SpeakerSieve {
      get { return speakerSieve_ ?? SpeakerSieveDefaultValue; }
      set {
        speakerSieve_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "speakerSieve" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeakerSieve {
      get { return speakerSieve_ != null; }
    }
    /// <summary>Clears the value of the "speakerSieve" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeakerSieve() {
      speakerSieve_ = null;
    }

    /// <summary>Field number for the "canonicalMention" field.</summary>
    public const int CanonicalMentionFieldNumber = 19;
    private readonly static string CanonicalMentionDefaultValue = "";

    private string canonicalMention_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CanonicalMention {
      get { return canonicalMention_ ?? CanonicalMentionDefaultValue; }
      set {
        canonicalMention_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "canonicalMention" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCanonicalMention {
      get { return canonicalMention_ != null; }
    }
    /// <summary>Clears the value of the "canonicalMention" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCanonicalMention() {
      canonicalMention_ = null;
    }

    /// <summary>Field number for the "canonicalMentionBegin" field.</summary>
    public const int CanonicalMentionBeginFieldNumber = 20;
    private readonly static uint CanonicalMentionBeginDefaultValue = 0;

    private uint canonicalMentionBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CanonicalMentionBegin {
      get { if ((_hasBits0 & 512) != 0) { return canonicalMentionBegin_; } else { return CanonicalMentionBeginDefaultValue; } }
      set {
        _hasBits0 |= 512;
        canonicalMentionBegin_ = value;
      }
    }
    /// <summary>Gets whether the "canonicalMentionBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCanonicalMentionBegin {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "canonicalMentionBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCanonicalMentionBegin() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "canonicalMentionEnd" field.</summary>
    public const int CanonicalMentionEndFieldNumber = 21;
    private readonly static uint CanonicalMentionEndDefaultValue = 0;

    private uint canonicalMentionEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CanonicalMentionEnd {
      get { if ((_hasBits0 & 1024) != 0) { return canonicalMentionEnd_; } else { return CanonicalMentionEndDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        canonicalMentionEnd_ = value;
      }
    }
    /// <summary>Gets whether the "canonicalMentionEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCanonicalMentionEnd {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "canonicalMentionEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCanonicalMentionEnd() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "attributionDependencyGraph" field.</summary>
    public const int AttributionDependencyGraphFieldNumber = 22;
    private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph attributionDependencyGraph_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph AttributionDependencyGraph {
      get { return attributionDependencyGraph_; }
      set {
        attributionDependencyGraph_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Quote);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Quote other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Text != other.Text) return false;
      if (Begin != other.Begin) return false;
      if (End != other.End) return false;
      if (SentenceBegin != other.SentenceBegin) return false;
      if (SentenceEnd != other.SentenceEnd) return false;
      if (TokenBegin != other.TokenBegin) return false;
      if (TokenEnd != other.TokenEnd) return false;
      if (Docid != other.Docid) return false;
      if (Index != other.Index) return false;
      if (Author != other.Author) return false;
      if (Mention != other.Mention) return false;
      if (MentionBegin != other.MentionBegin) return false;
      if (MentionEnd != other.MentionEnd) return false;
      if (MentionType != other.MentionType) return false;
      if (MentionSieve != other.MentionSieve) return false;
      if (Speaker != other.Speaker) return false;
      if (SpeakerSieve != other.SpeakerSieve) return false;
      if (CanonicalMention != other.CanonicalMention) return false;
      if (CanonicalMentionBegin != other.CanonicalMentionBegin) return false;
      if (CanonicalMentionEnd != other.CanonicalMentionEnd) return false;
      if (!object.Equals(AttributionDependencyGraph, other.AttributionDependencyGraph)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasText) hash ^= Text.GetHashCode();
      if (HasBegin) hash ^= Begin.GetHashCode();
      if (HasEnd) hash ^= End.GetHashCode();
      if (HasSentenceBegin) hash ^= SentenceBegin.GetHashCode();
      if (HasSentenceEnd) hash ^= SentenceEnd.GetHashCode();
      if (HasTokenBegin) hash ^= TokenBegin.GetHashCode();
      if (HasTokenEnd) hash ^= TokenEnd.GetHashCode();
      if (HasDocid) hash ^= Docid.GetHashCode();
      if (HasIndex) hash ^= Index.GetHashCode();
      if (HasAuthor) hash ^= Author.GetHashCode();
      if (HasMention) hash ^= Mention.GetHashCode();
      if (HasMentionBegin) hash ^= MentionBegin.GetHashCode();
      if (HasMentionEnd) hash ^= MentionEnd.GetHashCode();
      if (HasMentionType) hash ^= MentionType.GetHashCode();
      if (HasMentionSieve) hash ^= MentionSieve.GetHashCode();
      if (HasSpeaker) hash ^= Speaker.GetHashCode();
      if (HasSpeakerSieve) hash ^= SpeakerSieve.GetHashCode();
      if (HasCanonicalMention) hash ^= CanonicalMention.GetHashCode();
      if (HasCanonicalMentionBegin) hash ^= CanonicalMentionBegin.GetHashCode();
      if (HasCanonicalMentionEnd) hash ^= CanonicalMentionEnd.GetHashCode();
      if (attributionDependencyGraph_ != null) hash ^= AttributionDependencyGraph.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasText) {
        output.WriteRawTag(10);
        output.WriteString(Text);
      }
      if (HasBegin) {
        output.WriteRawTag(16);
        output.WriteUInt32(Begin);
      }
      if (HasEnd) {
        output.WriteRawTag(24);
        output.WriteUInt32(End);
      }
      if (HasSentenceBegin) {
        output.WriteRawTag(40);
        output.WriteUInt32(SentenceBegin);
      }
      if (HasSentenceEnd) {
        output.WriteRawTag(48);
        output.WriteUInt32(SentenceEnd);
      }
      if (HasTokenBegin) {
        output.WriteRawTag(56);
        output.WriteUInt32(TokenBegin);
      }
      if (HasTokenEnd) {
        output.WriteRawTag(64);
        output.WriteUInt32(TokenEnd);
      }
      if (HasDocid) {
        output.WriteRawTag(74);
        output.WriteString(Docid);
      }
      if (HasIndex) {
        output.WriteRawTag(80);
        output.WriteUInt32(Index);
      }
      if (HasAuthor) {
        output.WriteRawTag(90);
        output.WriteString(Author);
      }
      if (HasMention) {
        output.WriteRawTag(98);
        output.WriteString(Mention);
      }
      if (HasMentionBegin) {
        output.WriteRawTag(104);
        output.WriteUInt32(MentionBegin);
      }
      if (HasMentionEnd) {
        output.WriteRawTag(112);
        output.WriteUInt32(MentionEnd);
      }
      if (HasMentionType) {
        output.WriteRawTag(122);
        output.WriteString(MentionType);
      }
      if (HasMentionSieve) {
        output.WriteRawTag(130, 1);
        output.WriteString(MentionSieve);
      }
      if (HasSpeaker) {
        output.WriteRawTag(138, 1);
        output.WriteString(Speaker);
      }
      if (HasSpeakerSieve) {
        output.WriteRawTag(146, 1);
        output.WriteString(SpeakerSieve);
      }
      if (HasCanonicalMention) {
        output.WriteRawTag(154, 1);
        output.WriteString(CanonicalMention);
      }
      if (HasCanonicalMentionBegin) {
        output.WriteRawTag(160, 1);
        output.WriteUInt32(CanonicalMentionBegin);
      }
      if (HasCanonicalMentionEnd) {
        output.WriteRawTag(168, 1);
        output.WriteUInt32(CanonicalMentionEnd);
      }
      if (attributionDependencyGraph_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(AttributionDependencyGraph);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasText) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (HasBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Begin);
      }
      if (HasEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(End);
      }
      if (HasSentenceBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SentenceBegin);
      }
      if (HasSentenceEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SentenceEnd);
      }
      if (HasTokenBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TokenBegin);
      }
      if (HasTokenEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TokenEnd);
      }
      if (HasDocid) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Docid);
      }
      if (HasIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Index);
      }
      if (HasAuthor) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Author);
      }
      if (HasMention) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Mention);
      }
      if (HasMentionBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MentionBegin);
      }
      if (HasMentionEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MentionEnd);
      }
      if (HasMentionType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MentionType);
      }
      if (HasMentionSieve) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(MentionSieve);
      }
      if (HasSpeaker) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Speaker);
      }
      if (HasSpeakerSieve) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SpeakerSieve);
      }
      if (HasCanonicalMention) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CanonicalMention);
      }
      if (HasCanonicalMentionBegin) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(CanonicalMentionBegin);
      }
      if (HasCanonicalMentionEnd) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(CanonicalMentionEnd);
      }
      if (attributionDependencyGraph_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AttributionDependencyGraph);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Quote other) {
      if (other == null) {
        return;
      }
      if (other.HasText) {
        Text = other.Text;
      }
      if (other.HasBegin) {
        Begin = other.Begin;
      }
      if (other.HasEnd) {
        End = other.End;
      }
      if (other.HasSentenceBegin) {
        SentenceBegin = other.SentenceBegin;
      }
      if (other.HasSentenceEnd) {
        SentenceEnd = other.SentenceEnd;
      }
      if (other.HasTokenBegin) {
        TokenBegin = other.TokenBegin;
      }
      if (other.HasTokenEnd) {
        TokenEnd = other.TokenEnd;
      }
      if (other.HasDocid) {
        Docid = other.Docid;
      }
      if (other.HasIndex) {
        Index = other.Index;
      }
      if (other.HasAuthor) {
        Author = other.Author;
      }
      if (other.HasMention) {
        Mention = other.Mention;
      }
      if (other.HasMentionBegin) {
        MentionBegin = other.MentionBegin;
      }
      if (other.HasMentionEnd) {
        MentionEnd = other.MentionEnd;
      }
      if (other.HasMentionType) {
        MentionType = other.MentionType;
      }
      if (other.HasMentionSieve) {
        MentionSieve = other.MentionSieve;
      }
      if (other.HasSpeaker) {
        Speaker = other.Speaker;
      }
      if (other.HasSpeakerSieve) {
        SpeakerSieve = other.SpeakerSieve;
      }
      if (other.HasCanonicalMention) {
        CanonicalMention = other.CanonicalMention;
      }
      if (other.HasCanonicalMentionBegin) {
        CanonicalMentionBegin = other.CanonicalMentionBegin;
      }
      if (other.HasCanonicalMentionEnd) {
        CanonicalMentionEnd = other.CanonicalMentionEnd;
      }
      if (other.attributionDependencyGraph_ != null) {
        if (attributionDependencyGraph_ == null) {
          AttributionDependencyGraph = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
        }
        AttributionDependencyGraph.MergeFrom(other.AttributionDependencyGraph);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Text = input.ReadString();
            break;
          }
          case 16: {
            Begin = input.ReadUInt32();
            break;
          }
          case 24: {
            End = input.ReadUInt32();
            break;
          }
          case 40: {
            SentenceBegin = input.ReadUInt32();
            break;
          }
          case 48: {
            SentenceEnd = input.ReadUInt32();
            break;
          }
          case 56: {
            TokenBegin = input.ReadUInt32();
            break;
          }
          case 64: {
            TokenEnd = input.ReadUInt32();
            break;
          }
          case 74: {
            Docid = input.ReadString();
            break;
          }
          case 80: {
            Index = input.ReadUInt32();
            break;
          }
          case 90: {
            Author = input.ReadString();
            break;
          }
          case 98: {
            Mention = input.ReadString();
            break;
          }
          case 104: {
            MentionBegin = input.ReadUInt32();
            break;
          }
          case 112: {
            MentionEnd = input.ReadUInt32();
            break;
          }
          case 122: {
            MentionType = input.ReadString();
            break;
          }
          case 130: {
            MentionSieve = input.ReadString();
            break;
          }
          case 138: {
            Speaker = input.ReadString();
            break;
          }
          case 146: {
            SpeakerSieve = input.ReadString();
            break;
          }
          case 154: {
            CanonicalMention = input.ReadString();
            break;
          }
          case 160: {
            CanonicalMentionBegin = input.ReadUInt32();
            break;
          }
          case 168: {
            CanonicalMentionEnd = input.ReadUInt32();
            break;
          }
          case 178: {
            if (attributionDependencyGraph_ == null) {
              AttributionDependencyGraph = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            input.ReadMessage(AttributionDependencyGraph);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A syntactic parse tree, with scores.
  /// </summary>
  public sealed partial class ParseTree : pb::IMessage<ParseTree> {
    private static readonly pb::MessageParser<ParseTree> _parser = new pb::MessageParser<ParseTree>(() => new ParseTree());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ParseTree> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParseTree() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParseTree(ParseTree other) : this() {
      _hasBits0 = other._hasBits0;
      child_ = other.child_.Clone();
      value_ = other.value_;
      yieldBeginIndex_ = other.yieldBeginIndex_;
      yieldEndIndex_ = other.yieldEndIndex_;
      score_ = other.score_;
      sentiment_ = other.sentiment_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParseTree Clone() {
      return new ParseTree(this);
    }

    /// <summary>Field number for the "child" field.</summary>
    public const int ChildFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.ParseTree> _repeated_child_codec
        = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.ParseTree.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.ParseTree> child_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.ParseTree>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.ParseTree> Child {
      get { return child_; }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      value_ = null;
    }

    /// <summary>Field number for the "yieldBeginIndex" field.</summary>
    public const int YieldBeginIndexFieldNumber = 3;
    private readonly static uint YieldBeginIndexDefaultValue = 0;

    private uint yieldBeginIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint YieldBeginIndex {
      get { if ((_hasBits0 & 1) != 0) { return yieldBeginIndex_; } else { return YieldBeginIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        yieldBeginIndex_ = value;
      }
    }
    /// <summary>Gets whether the "yieldBeginIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldBeginIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "yieldBeginIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldBeginIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "yieldEndIndex" field.</summary>
    public const int YieldEndIndexFieldNumber = 4;
    private readonly static uint YieldEndIndexDefaultValue = 0;

    private uint yieldEndIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint YieldEndIndex {
      get { if ((_hasBits0 & 2) != 0) { return yieldEndIndex_; } else { return YieldEndIndexDefaultValue; } }
      set {
        _hasBits0 |= 2;
        yieldEndIndex_ = value;
      }
    }
    /// <summary>Gets whether the "yieldEndIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasYieldEndIndex {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "yieldEndIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearYieldEndIndex() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "score" field.</summary>
    public const int ScoreFieldNumber = 5;
    private readonly static double ScoreDefaultValue = 0D;

    private double score_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Score {
      get { if ((_hasBits0 & 4) != 0) { return score_; } else { return ScoreDefaultValue; } }
      set {
        _hasBits0 |= 4;
        score_ = value;
      }
    }
    /// <summary>Gets whether the "score" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScore {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "score" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScore() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "sentiment" field.</summary>
    public const int SentimentFieldNumber = 6;
    private readonly static global::Edu.Stanford.Nlp.Pipeline.Sentiment SentimentDefaultValue = global::Edu.Stanford.Nlp.Pipeline.Sentiment.StrongNegative;

    private global::Edu.Stanford.Nlp.Pipeline.Sentiment sentiment_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Sentiment Sentiment {
      get { if ((_hasBits0 & 8) != 0) { return sentiment_; } else { return SentimentDefaultValue; } }
      set {
        _hasBits0 |= 8;
        sentiment_ = value;
      }
    }
    /// <summary>Gets whether the "sentiment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentiment {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "sentiment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentiment() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ParseTree);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ParseTree other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!child_.Equals(other.child_)) return false;
      if (Value != other.Value) return false;
      if (YieldBeginIndex != other.YieldBeginIndex) return false;
      if (YieldEndIndex != other.YieldEndIndex) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Score, other.Score)) return false;
      if (Sentiment != other.Sentiment) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= child_.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (HasYieldBeginIndex) hash ^= YieldBeginIndex.GetHashCode();
      if (HasYieldEndIndex) hash ^= YieldEndIndex.GetHashCode();
      if (HasScore) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Score);
      if (HasSentiment) hash ^= Sentiment.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      child_.WriteTo(output, _repeated_child_codec);
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (HasYieldBeginIndex) {
        output.WriteRawTag(24);
        output.WriteUInt32(YieldBeginIndex);
      }
      if (HasYieldEndIndex) {
        output.WriteRawTag(32);
        output.WriteUInt32(YieldEndIndex);
      }
      if (HasScore) {
        output.WriteRawTag(41);
        output.WriteDouble(Score);
      }
      if (HasSentiment) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Sentiment);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += child_.CalculateSize(_repeated_child_codec);
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (HasYieldBeginIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(YieldBeginIndex);
      }
      if (HasYieldEndIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(YieldEndIndex);
      }
      if (HasScore) {
        size += 1 + 8;
      }
      if (HasSentiment) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Sentiment);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ParseTree other) {
      if (other == null) {
        return;
      }
      child_.Add(other.child_);
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasYieldBeginIndex) {
        YieldBeginIndex = other.YieldBeginIndex;
      }
      if (other.HasYieldEndIndex) {
        YieldEndIndex = other.YieldEndIndex;
      }
      if (other.HasScore) {
        Score = other.Score;
      }
      if (other.HasSentiment) {
        Sentiment = other.Sentiment;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            child_.AddEntriesFrom(input, _repeated_child_codec);
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
          case 24: {
            YieldBeginIndex = input.ReadUInt32();
            break;
          }
          case 32: {
            YieldEndIndex = input.ReadUInt32();
            break;
          }
          case 41: {
            Score = input.ReadDouble();
            break;
          }
          case 48: {
            Sentiment = (global::Edu.Stanford.Nlp.Pipeline.Sentiment) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A dependency graph representation.
  /// </summary>
  public sealed partial class DependencyGraph : pb::IMessage<DependencyGraph> {
    private static readonly pb::MessageParser<DependencyGraph> _parser = new pb::MessageParser<DependencyGraph>(() => new DependencyGraph());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DependencyGraph> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DependencyGraph() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DependencyGraph(DependencyGraph other) : this() {
      node_ = other.node_.Clone();
      edge_ = other.edge_.Clone();
      root_ = other.root_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DependencyGraph Clone() {
      return new DependencyGraph(this);
    }

    /// <summary>Field number for the "node" field.</summary>
    public const int NodeFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Node> _repeated_node_codec
        = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Node.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Node> node_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Node>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Node> Node {
      get { return node_; }
    }

    /// <summary>Field number for the "edge" field.</summary>
    public const int EdgeFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Edge> _repeated_edge_codec
        = pb::FieldCodec.ForMessage(18, global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Edge.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Edge> edge_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Edge>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Types.Edge> Edge {
      get { return edge_; }
    }

    /// <summary>Field number for the "root" field.</summary>
    public const int RootFieldNumber = 3;
    private static readonly pb::FieldCodec<uint> _repeated_root_codec
        = pb::FieldCodec.ForUInt32(26);
    private readonly pbc::RepeatedField<uint> root_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> Root {
      get { return root_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DependencyGraph);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DependencyGraph other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!node_.Equals(other.node_)) return false;
      if(!edge_.Equals(other.edge_)) return false;
      if(!root_.Equals(other.root_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= node_.GetHashCode();
      hash ^= edge_.GetHashCode();
      hash ^= root_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      node_.WriteTo(output, _repeated_node_codec);
      edge_.WriteTo(output, _repeated_edge_codec);
      root_.WriteTo(output, _repeated_root_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += node_.CalculateSize(_repeated_node_codec);
      size += edge_.CalculateSize(_repeated_edge_codec);
      size += root_.CalculateSize(_repeated_root_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DependencyGraph other) {
      if (other == null) {
        return;
      }
      node_.Add(other.node_);
      edge_.Add(other.edge_);
      root_.Add(other.root_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            node_.AddEntriesFrom(input, _repeated_node_codec);
            break;
          }
          case 18: {
            edge_.AddEntriesFrom(input, _repeated_edge_codec);
            break;
          }
          case 26:
          case 24: {
            root_.AddEntriesFrom(input, _repeated_root_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the DependencyGraph message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Node : pb::IMessage<Node> {
        private static readonly pb::MessageParser<Node> _parser = new pb::MessageParser<Node>(() => new Node());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Node> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Node() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Node(Node other) : this() {
          _hasBits0 = other._hasBits0;
          sentenceIndex_ = other.sentenceIndex_;
          index_ = other.index_;
          copyAnnotation_ = other.copyAnnotation_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Node Clone() {
          return new Node(this);
        }

        /// <summary>Field number for the "sentenceIndex" field.</summary>
        public const int SentenceIndexFieldNumber = 1;
        private readonly static uint SentenceIndexDefaultValue = 0;

        private uint sentenceIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint SentenceIndex {
          get { if ((_hasBits0 & 1) != 0) { return sentenceIndex_; } else { return SentenceIndexDefaultValue; } }
          set {
            _hasBits0 |= 1;
            sentenceIndex_ = value;
          }
        }
        /// <summary>Gets whether the "sentenceIndex" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasSentenceIndex {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "sentenceIndex" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearSentenceIndex() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "index" field.</summary>
        public const int IndexFieldNumber = 2;
        private readonly static uint IndexDefaultValue = 0;

        private uint index_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint Index {
          get { if ((_hasBits0 & 2) != 0) { return index_; } else { return IndexDefaultValue; } }
          set {
            _hasBits0 |= 2;
            index_ = value;
          }
        }
        /// <summary>Gets whether the "index" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasIndex {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "index" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearIndex() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "copyAnnotation" field.</summary>
        public const int CopyAnnotationFieldNumber = 3;
        private readonly static uint CopyAnnotationDefaultValue = 0;

        private uint copyAnnotation_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint CopyAnnotation {
          get { if ((_hasBits0 & 4) != 0) { return copyAnnotation_; } else { return CopyAnnotationDefaultValue; } }
          set {
            _hasBits0 |= 4;
            copyAnnotation_ = value;
          }
        }
        /// <summary>Gets whether the "copyAnnotation" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasCopyAnnotation {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "copyAnnotation" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearCopyAnnotation() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Node);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Node other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (SentenceIndex != other.SentenceIndex) return false;
          if (Index != other.Index) return false;
          if (CopyAnnotation != other.CopyAnnotation) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasSentenceIndex) hash ^= SentenceIndex.GetHashCode();
          if (HasIndex) hash ^= Index.GetHashCode();
          if (HasCopyAnnotation) hash ^= CopyAnnotation.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasSentenceIndex) {
            output.WriteRawTag(8);
            output.WriteUInt32(SentenceIndex);
          }
          if (HasIndex) {
            output.WriteRawTag(16);
            output.WriteUInt32(Index);
          }
          if (HasCopyAnnotation) {
            output.WriteRawTag(24);
            output.WriteUInt32(CopyAnnotation);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasSentenceIndex) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SentenceIndex);
          }
          if (HasIndex) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Index);
          }
          if (HasCopyAnnotation) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CopyAnnotation);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Node other) {
          if (other == null) {
            return;
          }
          if (other.HasSentenceIndex) {
            SentenceIndex = other.SentenceIndex;
          }
          if (other.HasIndex) {
            Index = other.Index;
          }
          if (other.HasCopyAnnotation) {
            CopyAnnotation = other.CopyAnnotation;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                SentenceIndex = input.ReadUInt32();
                break;
              }
              case 16: {
                Index = input.ReadUInt32();
                break;
              }
              case 24: {
                CopyAnnotation = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

      public sealed partial class Edge : pb::IMessage<Edge> {
        private static readonly pb::MessageParser<Edge> _parser = new pb::MessageParser<Edge>(() => new Edge());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Edge> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.DependencyGraph.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Edge() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Edge(Edge other) : this() {
          _hasBits0 = other._hasBits0;
          source_ = other.source_;
          target_ = other.target_;
          dep_ = other.dep_;
          isExtra_ = other.isExtra_;
          sourceCopy_ = other.sourceCopy_;
          targetCopy_ = other.targetCopy_;
          language_ = other.language_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Edge Clone() {
          return new Edge(this);
        }

        /// <summary>Field number for the "source" field.</summary>
        public const int SourceFieldNumber = 1;
        private readonly static uint SourceDefaultValue = 0;

        private uint source_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint Source {
          get { if ((_hasBits0 & 1) != 0) { return source_; } else { return SourceDefaultValue; } }
          set {
            _hasBits0 |= 1;
            source_ = value;
          }
        }
        /// <summary>Gets whether the "source" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasSource {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "source" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearSource() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "target" field.</summary>
        public const int TargetFieldNumber = 2;
        private readonly static uint TargetDefaultValue = 0;

        private uint target_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint Target {
          get { if ((_hasBits0 & 2) != 0) { return target_; } else { return TargetDefaultValue; } }
          set {
            _hasBits0 |= 2;
            target_ = value;
          }
        }
        /// <summary>Gets whether the "target" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasTarget {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "target" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTarget() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "dep" field.</summary>
        public const int DepFieldNumber = 3;
        private readonly static string DepDefaultValue = "";

        private string dep_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Dep {
          get { return dep_ ?? DepDefaultValue; }
          set {
            dep_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "dep" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasDep {
          get { return dep_ != null; }
        }
        /// <summary>Clears the value of the "dep" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearDep() {
          dep_ = null;
        }

        /// <summary>Field number for the "isExtra" field.</summary>
        public const int IsExtraFieldNumber = 4;
        private readonly static bool IsExtraDefaultValue = false;

        private bool isExtra_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsExtra {
          get { if ((_hasBits0 & 4) != 0) { return isExtra_; } else { return IsExtraDefaultValue; } }
          set {
            _hasBits0 |= 4;
            isExtra_ = value;
          }
        }
        /// <summary>Gets whether the "isExtra" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasIsExtra {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "isExtra" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearIsExtra() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "sourceCopy" field.</summary>
        public const int SourceCopyFieldNumber = 5;
        private readonly static uint SourceCopyDefaultValue = 0;

        private uint sourceCopy_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint SourceCopy {
          get { if ((_hasBits0 & 8) != 0) { return sourceCopy_; } else { return SourceCopyDefaultValue; } }
          set {
            _hasBits0 |= 8;
            sourceCopy_ = value;
          }
        }
        /// <summary>Gets whether the "sourceCopy" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasSourceCopy {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "sourceCopy" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearSourceCopy() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "targetCopy" field.</summary>
        public const int TargetCopyFieldNumber = 6;
        private readonly static uint TargetCopyDefaultValue = 0;

        private uint targetCopy_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint TargetCopy {
          get { if ((_hasBits0 & 16) != 0) { return targetCopy_; } else { return TargetCopyDefaultValue; } }
          set {
            _hasBits0 |= 16;
            targetCopy_ = value;
          }
        }
        /// <summary>Gets whether the "targetCopy" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasTargetCopy {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "targetCopy" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearTargetCopy() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "language" field.</summary>
        public const int LanguageFieldNumber = 7;
        private readonly static global::Edu.Stanford.Nlp.Pipeline.Language LanguageDefaultValue = global::Edu.Stanford.Nlp.Pipeline.Language.Unknown;

        private global::Edu.Stanford.Nlp.Pipeline.Language language_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Edu.Stanford.Nlp.Pipeline.Language Language {
          get { if ((_hasBits0 & 32) != 0) { return language_; } else { return LanguageDefaultValue; } }
          set {
            _hasBits0 |= 32;
            language_ = value;
          }
        }
        /// <summary>Gets whether the "language" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasLanguage {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "language" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearLanguage() {
          _hasBits0 &= ~32;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Edge);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Edge other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Source != other.Source) return false;
          if (Target != other.Target) return false;
          if (Dep != other.Dep) return false;
          if (IsExtra != other.IsExtra) return false;
          if (SourceCopy != other.SourceCopy) return false;
          if (TargetCopy != other.TargetCopy) return false;
          if (Language != other.Language) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasSource) hash ^= Source.GetHashCode();
          if (HasTarget) hash ^= Target.GetHashCode();
          if (HasDep) hash ^= Dep.GetHashCode();
          if (HasIsExtra) hash ^= IsExtra.GetHashCode();
          if (HasSourceCopy) hash ^= SourceCopy.GetHashCode();
          if (HasTargetCopy) hash ^= TargetCopy.GetHashCode();
          if (HasLanguage) hash ^= Language.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasSource) {
            output.WriteRawTag(8);
            output.WriteUInt32(Source);
          }
          if (HasTarget) {
            output.WriteRawTag(16);
            output.WriteUInt32(Target);
          }
          if (HasDep) {
            output.WriteRawTag(26);
            output.WriteString(Dep);
          }
          if (HasIsExtra) {
            output.WriteRawTag(32);
            output.WriteBool(IsExtra);
          }
          if (HasSourceCopy) {
            output.WriteRawTag(40);
            output.WriteUInt32(SourceCopy);
          }
          if (HasTargetCopy) {
            output.WriteRawTag(48);
            output.WriteUInt32(TargetCopy);
          }
          if (HasLanguage) {
            output.WriteRawTag(56);
            output.WriteEnum((int) Language);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasSource) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Source);
          }
          if (HasTarget) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Target);
          }
          if (HasDep) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Dep);
          }
          if (HasIsExtra) {
            size += 1 + 1;
          }
          if (HasSourceCopy) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SourceCopy);
          }
          if (HasTargetCopy) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TargetCopy);
          }
          if (HasLanguage) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Language);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Edge other) {
          if (other == null) {
            return;
          }
          if (other.HasSource) {
            Source = other.Source;
          }
          if (other.HasTarget) {
            Target = other.Target;
          }
          if (other.HasDep) {
            Dep = other.Dep;
          }
          if (other.HasIsExtra) {
            IsExtra = other.IsExtra;
          }
          if (other.HasSourceCopy) {
            SourceCopy = other.SourceCopy;
          }
          if (other.HasTargetCopy) {
            TargetCopy = other.TargetCopy;
          }
          if (other.HasLanguage) {
            Language = other.Language;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Source = input.ReadUInt32();
                break;
              }
              case 16: {
                Target = input.ReadUInt32();
                break;
              }
              case 26: {
                Dep = input.ReadString();
                break;
              }
              case 32: {
                IsExtra = input.ReadBool();
                break;
              }
              case 40: {
                SourceCopy = input.ReadUInt32();
                break;
              }
              case 48: {
                TargetCopy = input.ReadUInt32();
                break;
              }
              case 56: {
                Language = (global::Edu.Stanford.Nlp.Pipeline.Language) input.ReadEnum();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///
  /// A coreference chain.
  /// These fields are not *really* optional. CoreNLP will crash without them.
  /// </summary>
  public sealed partial class CorefChain : pb::IMessage<CorefChain> {
    private static readonly pb::MessageParser<CorefChain> _parser = new pb::MessageParser<CorefChain>(() => new CorefChain());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CorefChain> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorefChain() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorefChain(CorefChain other) : this() {
      _hasBits0 = other._hasBits0;
      chainID_ = other.chainID_;
      mention_ = other.mention_.Clone();
      representative_ = other.representative_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorefChain Clone() {
      return new CorefChain(this);
    }

    /// <summary>Field number for the "chainID" field.</summary>
    public const int ChainIDFieldNumber = 1;
    private readonly static int ChainIDDefaultValue = 0;

    private int chainID_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ChainID {
      get { if ((_hasBits0 & 1) != 0) { return chainID_; } else { return ChainIDDefaultValue; } }
      set {
        _hasBits0 |= 1;
        chainID_ = value;
      }
    }
    /// <summary>Gets whether the "chainID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasChainID {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "chainID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearChainID() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "mention" field.</summary>
    public const int MentionFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.CorefChain.Types.CorefMention> _repeated_mention_codec
        = pb::FieldCodec.ForMessage(18, global::Edu.Stanford.Nlp.Pipeline.CorefChain.Types.CorefMention.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.CorefChain.Types.CorefMention> mention_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.CorefChain.Types.CorefMention>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.CorefChain.Types.CorefMention> Mention {
      get { return mention_; }
    }

    /// <summary>Field number for the "representative" field.</summary>
    public const int RepresentativeFieldNumber = 3;
    private readonly static uint RepresentativeDefaultValue = 0;

    private uint representative_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Representative {
      get { if ((_hasBits0 & 2) != 0) { return representative_; } else { return RepresentativeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        representative_ = value;
      }
    }
    /// <summary>Gets whether the "representative" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRepresentative {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "representative" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRepresentative() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CorefChain);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CorefChain other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ChainID != other.ChainID) return false;
      if(!mention_.Equals(other.mention_)) return false;
      if (Representative != other.Representative) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasChainID) hash ^= ChainID.GetHashCode();
      hash ^= mention_.GetHashCode();
      if (HasRepresentative) hash ^= Representative.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasChainID) {
        output.WriteRawTag(8);
        output.WriteInt32(ChainID);
      }
      mention_.WriteTo(output, _repeated_mention_codec);
      if (HasRepresentative) {
        output.WriteRawTag(24);
        output.WriteUInt32(Representative);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasChainID) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ChainID);
      }
      size += mention_.CalculateSize(_repeated_mention_codec);
      if (HasRepresentative) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Representative);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CorefChain other) {
      if (other == null) {
        return;
      }
      if (other.HasChainID) {
        ChainID = other.ChainID;
      }
      mention_.Add(other.mention_);
      if (other.HasRepresentative) {
        Representative = other.Representative;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ChainID = input.ReadInt32();
            break;
          }
          case 18: {
            mention_.AddEntriesFrom(input, _repeated_mention_codec);
            break;
          }
          case 24: {
            Representative = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CorefChain message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class CorefMention : pb::IMessage<CorefMention> {
        private static readonly pb::MessageParser<CorefMention> _parser = new pb::MessageParser<CorefMention>(() => new CorefMention());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CorefMention> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.CorefChain.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CorefMention() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CorefMention(CorefMention other) : this() {
          _hasBits0 = other._hasBits0;
          mentionID_ = other.mentionID_;
          mentionType_ = other.mentionType_;
          number_ = other.number_;
          gender_ = other.gender_;
          animacy_ = other.animacy_;
          beginIndex_ = other.beginIndex_;
          endIndex_ = other.endIndex_;
          headIndex_ = other.headIndex_;
          sentenceIndex_ = other.sentenceIndex_;
          position_ = other.position_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CorefMention Clone() {
          return new CorefMention(this);
        }

        /// <summary>Field number for the "mentionID" field.</summary>
        public const int MentionIDFieldNumber = 1;
        private readonly static int MentionIDDefaultValue = 0;

        private int mentionID_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MentionID {
          get { if ((_hasBits0 & 1) != 0) { return mentionID_; } else { return MentionIDDefaultValue; } }
          set {
            _hasBits0 |= 1;
            mentionID_ = value;
          }
        }
        /// <summary>Gets whether the "mentionID" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMentionID {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "mentionID" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMentionID() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "mentionType" field.</summary>
        public const int MentionTypeFieldNumber = 2;
        private readonly static string MentionTypeDefaultValue = "";

        private string mentionType_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string MentionType {
          get { return mentionType_ ?? MentionTypeDefaultValue; }
          set {
            mentionType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "mentionType" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMentionType {
          get { return mentionType_ != null; }
        }
        /// <summary>Clears the value of the "mentionType" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMentionType() {
          mentionType_ = null;
        }

        /// <summary>Field number for the "number" field.</summary>
        public const int NumberFieldNumber = 3;
        private readonly static string NumberDefaultValue = "";

        private string number_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Number {
          get { return number_ ?? NumberDefaultValue; }
          set {
            number_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "number" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasNumber {
          get { return number_ != null; }
        }
        /// <summary>Clears the value of the "number" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearNumber() {
          number_ = null;
        }

        /// <summary>Field number for the "gender" field.</summary>
        public const int GenderFieldNumber = 4;
        private readonly static string GenderDefaultValue = "";

        private string gender_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Gender {
          get { return gender_ ?? GenderDefaultValue; }
          set {
            gender_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "gender" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasGender {
          get { return gender_ != null; }
        }
        /// <summary>Clears the value of the "gender" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearGender() {
          gender_ = null;
        }

        /// <summary>Field number for the "animacy" field.</summary>
        public const int AnimacyFieldNumber = 5;
        private readonly static string AnimacyDefaultValue = "";

        private string animacy_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Animacy {
          get { return animacy_ ?? AnimacyDefaultValue; }
          set {
            animacy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "animacy" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasAnimacy {
          get { return animacy_ != null; }
        }
        /// <summary>Clears the value of the "animacy" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearAnimacy() {
          animacy_ = null;
        }

        /// <summary>Field number for the "beginIndex" field.</summary>
        public const int BeginIndexFieldNumber = 6;
        private readonly static uint BeginIndexDefaultValue = 0;

        private uint beginIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint BeginIndex {
          get { if ((_hasBits0 & 2) != 0) { return beginIndex_; } else { return BeginIndexDefaultValue; } }
          set {
            _hasBits0 |= 2;
            beginIndex_ = value;
          }
        }
        /// <summary>Gets whether the "beginIndex" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasBeginIndex {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "beginIndex" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearBeginIndex() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "endIndex" field.</summary>
        public const int EndIndexFieldNumber = 7;
        private readonly static uint EndIndexDefaultValue = 0;

        private uint endIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint EndIndex {
          get { if ((_hasBits0 & 4) != 0) { return endIndex_; } else { return EndIndexDefaultValue; } }
          set {
            _hasBits0 |= 4;
            endIndex_ = value;
          }
        }
        /// <summary>Gets whether the "endIndex" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasEndIndex {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "endIndex" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearEndIndex() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "headIndex" field.</summary>
        public const int HeadIndexFieldNumber = 9;
        private readonly static uint HeadIndexDefaultValue = 0;

        private uint headIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint HeadIndex {
          get { if ((_hasBits0 & 8) != 0) { return headIndex_; } else { return HeadIndexDefaultValue; } }
          set {
            _hasBits0 |= 8;
            headIndex_ = value;
          }
        }
        /// <summary>Gets whether the "headIndex" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasHeadIndex {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "headIndex" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearHeadIndex() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "sentenceIndex" field.</summary>
        public const int SentenceIndexFieldNumber = 10;
        private readonly static uint SentenceIndexDefaultValue = 0;

        private uint sentenceIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint SentenceIndex {
          get { if ((_hasBits0 & 16) != 0) { return sentenceIndex_; } else { return SentenceIndexDefaultValue; } }
          set {
            _hasBits0 |= 16;
            sentenceIndex_ = value;
          }
        }
        /// <summary>Gets whether the "sentenceIndex" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasSentenceIndex {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "sentenceIndex" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearSentenceIndex() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "position" field.</summary>
        public const int PositionFieldNumber = 11;
        private readonly static uint PositionDefaultValue = 0;

        private uint position_;
        /// <summary>
        /// the second element of position
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint Position {
          get { if ((_hasBits0 & 32) != 0) { return position_; } else { return PositionDefaultValue; } }
          set {
            _hasBits0 |= 32;
            position_ = value;
          }
        }
        /// <summary>Gets whether the "position" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasPosition {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "position" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearPosition() {
          _hasBits0 &= ~32;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CorefMention);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CorefMention other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MentionID != other.MentionID) return false;
          if (MentionType != other.MentionType) return false;
          if (Number != other.Number) return false;
          if (Gender != other.Gender) return false;
          if (Animacy != other.Animacy) return false;
          if (BeginIndex != other.BeginIndex) return false;
          if (EndIndex != other.EndIndex) return false;
          if (HeadIndex != other.HeadIndex) return false;
          if (SentenceIndex != other.SentenceIndex) return false;
          if (Position != other.Position) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasMentionID) hash ^= MentionID.GetHashCode();
          if (HasMentionType) hash ^= MentionType.GetHashCode();
          if (HasNumber) hash ^= Number.GetHashCode();
          if (HasGender) hash ^= Gender.GetHashCode();
          if (HasAnimacy) hash ^= Animacy.GetHashCode();
          if (HasBeginIndex) hash ^= BeginIndex.GetHashCode();
          if (HasEndIndex) hash ^= EndIndex.GetHashCode();
          if (HasHeadIndex) hash ^= HeadIndex.GetHashCode();
          if (HasSentenceIndex) hash ^= SentenceIndex.GetHashCode();
          if (HasPosition) hash ^= Position.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasMentionID) {
            output.WriteRawTag(8);
            output.WriteInt32(MentionID);
          }
          if (HasMentionType) {
            output.WriteRawTag(18);
            output.WriteString(MentionType);
          }
          if (HasNumber) {
            output.WriteRawTag(26);
            output.WriteString(Number);
          }
          if (HasGender) {
            output.WriteRawTag(34);
            output.WriteString(Gender);
          }
          if (HasAnimacy) {
            output.WriteRawTag(42);
            output.WriteString(Animacy);
          }
          if (HasBeginIndex) {
            output.WriteRawTag(48);
            output.WriteUInt32(BeginIndex);
          }
          if (HasEndIndex) {
            output.WriteRawTag(56);
            output.WriteUInt32(EndIndex);
          }
          if (HasHeadIndex) {
            output.WriteRawTag(72);
            output.WriteUInt32(HeadIndex);
          }
          if (HasSentenceIndex) {
            output.WriteRawTag(80);
            output.WriteUInt32(SentenceIndex);
          }
          if (HasPosition) {
            output.WriteRawTag(88);
            output.WriteUInt32(Position);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasMentionID) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MentionID);
          }
          if (HasMentionType) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(MentionType);
          }
          if (HasNumber) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Number);
          }
          if (HasGender) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Gender);
          }
          if (HasAnimacy) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Animacy);
          }
          if (HasBeginIndex) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BeginIndex);
          }
          if (HasEndIndex) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EndIndex);
          }
          if (HasHeadIndex) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HeadIndex);
          }
          if (HasSentenceIndex) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SentenceIndex);
          }
          if (HasPosition) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Position);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CorefMention other) {
          if (other == null) {
            return;
          }
          if (other.HasMentionID) {
            MentionID = other.MentionID;
          }
          if (other.HasMentionType) {
            MentionType = other.MentionType;
          }
          if (other.HasNumber) {
            Number = other.Number;
          }
          if (other.HasGender) {
            Gender = other.Gender;
          }
          if (other.HasAnimacy) {
            Animacy = other.Animacy;
          }
          if (other.HasBeginIndex) {
            BeginIndex = other.BeginIndex;
          }
          if (other.HasEndIndex) {
            EndIndex = other.EndIndex;
          }
          if (other.HasHeadIndex) {
            HeadIndex = other.HeadIndex;
          }
          if (other.HasSentenceIndex) {
            SentenceIndex = other.SentenceIndex;
          }
          if (other.HasPosition) {
            Position = other.Position;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MentionID = input.ReadInt32();
                break;
              }
              case 18: {
                MentionType = input.ReadString();
                break;
              }
              case 26: {
                Number = input.ReadString();
                break;
              }
              case 34: {
                Gender = input.ReadString();
                break;
              }
              case 42: {
                Animacy = input.ReadString();
                break;
              }
              case 48: {
                BeginIndex = input.ReadUInt32();
                break;
              }
              case 56: {
                EndIndex = input.ReadUInt32();
                break;
              }
              case 72: {
                HeadIndex = input.ReadUInt32();
                break;
              }
              case 80: {
                SentenceIndex = input.ReadUInt32();
                break;
              }
              case 88: {
                Position = input.ReadUInt32();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class Mention : pb::IMessage<Mention> {
    private static readonly pb::MessageParser<Mention> _parser = new pb::MessageParser<Mention>(() => new Mention());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Mention> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mention() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mention(Mention other) : this() {
      _hasBits0 = other._hasBits0;
      mentionID_ = other.mentionID_;
      mentionType_ = other.mentionType_;
      number_ = other.number_;
      gender_ = other.gender_;
      animacy_ = other.animacy_;
      person_ = other.person_;
      startIndex_ = other.startIndex_;
      endIndex_ = other.endIndex_;
      headIndex_ = other.headIndex_;
      headString_ = other.headString_;
      nerString_ = other.nerString_;
      originalRef_ = other.originalRef_;
      goldCorefClusterID_ = other.goldCorefClusterID_;
      corefClusterID_ = other.corefClusterID_;
      mentionNum_ = other.mentionNum_;
      sentNum_ = other.sentNum_;
      utter_ = other.utter_;
      paragraph_ = other.paragraph_;
      isSubject_ = other.isSubject_;
      isDirectObject_ = other.isDirectObject_;
      isIndirectObject_ = other.isIndirectObject_;
      isPrepositionObject_ = other.isPrepositionObject_;
      hasTwin_ = other.hasTwin_;
      generic_ = other.generic_;
      isSingleton_ = other.isSingleton_;
      hasBasicDependency_ = other.hasBasicDependency_;
      hasEnhancedDepenedncy_ = other.hasEnhancedDepenedncy_;
      hasContextParseTree_ = other.hasContextParseTree_;
      headIndexedWord_ = other.headIndexedWord_ != null ? other.headIndexedWord_.Clone() : null;
      dependingVerb_ = other.dependingVerb_ != null ? other.dependingVerb_.Clone() : null;
      headWord_ = other.headWord_ != null ? other.headWord_.Clone() : null;
      speakerInfo_ = other.speakerInfo_ != null ? other.speakerInfo_.Clone() : null;
      sentenceWords_ = other.sentenceWords_.Clone();
      originalSpan_ = other.originalSpan_.Clone();
      dependents_ = other.dependents_.Clone();
      preprocessedTerms_ = other.preprocessedTerms_.Clone();
      appositions_ = other.appositions_.Clone();
      predicateNominatives_ = other.predicateNominatives_.Clone();
      relativePronouns_ = other.relativePronouns_.Clone();
      listMembers_ = other.listMembers_.Clone();
      belongToLists_ = other.belongToLists_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mention Clone() {
      return new Mention(this);
    }

    /// <summary>Field number for the "mentionID" field.</summary>
    public const int MentionIDFieldNumber = 1;
    private readonly static int MentionIDDefaultValue = 0;

    private int mentionID_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MentionID {
      get { if ((_hasBits0 & 1) != 0) { return mentionID_; } else { return MentionIDDefaultValue; } }
      set {
        _hasBits0 |= 1;
        mentionID_ = value;
      }
    }
    /// <summary>Gets whether the "mentionID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMentionID {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "mentionID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMentionID() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "mentionType" field.</summary>
    public const int MentionTypeFieldNumber = 2;
    private readonly static string MentionTypeDefaultValue = "";

    private string mentionType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MentionType {
      get { return mentionType_ ?? MentionTypeDefaultValue; }
      set {
        mentionType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mentionType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMentionType {
      get { return mentionType_ != null; }
    }
    /// <summary>Clears the value of the "mentionType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMentionType() {
      mentionType_ = null;
    }

    /// <summary>Field number for the "number" field.</summary>
    public const int NumberFieldNumber = 3;
    private readonly static string NumberDefaultValue = "";

    private string number_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Number {
      get { return number_ ?? NumberDefaultValue; }
      set {
        number_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNumber {
      get { return number_ != null; }
    }
    /// <summary>Clears the value of the "number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNumber() {
      number_ = null;
    }

    /// <summary>Field number for the "gender" field.</summary>
    public const int GenderFieldNumber = 4;
    private readonly static string GenderDefaultValue = "";

    private string gender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Gender {
      get { return gender_ ?? GenderDefaultValue; }
      set {
        gender_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gender" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGender {
      get { return gender_ != null; }
    }
    /// <summary>Clears the value of the "gender" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGender() {
      gender_ = null;
    }

    /// <summary>Field number for the "animacy" field.</summary>
    public const int AnimacyFieldNumber = 5;
    private readonly static string AnimacyDefaultValue = "";

    private string animacy_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Animacy {
      get { return animacy_ ?? AnimacyDefaultValue; }
      set {
        animacy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "animacy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAnimacy {
      get { return animacy_ != null; }
    }
    /// <summary>Clears the value of the "animacy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAnimacy() {
      animacy_ = null;
    }

    /// <summary>Field number for the "person" field.</summary>
    public const int PersonFieldNumber = 6;
    private readonly static string PersonDefaultValue = "";

    private string person_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Person {
      get { return person_ ?? PersonDefaultValue; }
      set {
        person_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "person" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPerson {
      get { return person_ != null; }
    }
    /// <summary>Clears the value of the "person" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPerson() {
      person_ = null;
    }

    /// <summary>Field number for the "startIndex" field.</summary>
    public const int StartIndexFieldNumber = 7;
    private readonly static uint StartIndexDefaultValue = 0;

    private uint startIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint StartIndex {
      get { if ((_hasBits0 & 2) != 0) { return startIndex_; } else { return StartIndexDefaultValue; } }
      set {
        _hasBits0 |= 2;
        startIndex_ = value;
      }
    }
    /// <summary>Gets whether the "startIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStartIndex {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "startIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStartIndex() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "endIndex" field.</summary>
    public const int EndIndexFieldNumber = 9;
    private readonly static uint EndIndexDefaultValue = 0;

    private uint endIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EndIndex {
      get { if ((_hasBits0 & 4) != 0) { return endIndex_; } else { return EndIndexDefaultValue; } }
      set {
        _hasBits0 |= 4;
        endIndex_ = value;
      }
    }
    /// <summary>Gets whether the "endIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEndIndex {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "endIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEndIndex() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "headIndex" field.</summary>
    public const int HeadIndexFieldNumber = 10;
    private readonly static int HeadIndexDefaultValue = 0;

    private int headIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int HeadIndex {
      get { if ((_hasBits0 & 8) != 0) { return headIndex_; } else { return HeadIndexDefaultValue; } }
      set {
        _hasBits0 |= 8;
        headIndex_ = value;
      }
    }
    /// <summary>Gets whether the "headIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadIndex {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "headIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadIndex() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "headString" field.</summary>
    public const int HeadStringFieldNumber = 11;
    private readonly static string HeadStringDefaultValue = "";

    private string headString_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HeadString {
      get { return headString_ ?? HeadStringDefaultValue; }
      set {
        headString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "headString" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadString {
      get { return headString_ != null; }
    }
    /// <summary>Clears the value of the "headString" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadString() {
      headString_ = null;
    }

    /// <summary>Field number for the "nerString" field.</summary>
    public const int NerStringFieldNumber = 12;
    private readonly static string NerStringDefaultValue = "";

    private string nerString_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NerString {
      get { return nerString_ ?? NerStringDefaultValue; }
      set {
        nerString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "nerString" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNerString {
      get { return nerString_ != null; }
    }
    /// <summary>Clears the value of the "nerString" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNerString() {
      nerString_ = null;
    }

    /// <summary>Field number for the "originalRef" field.</summary>
    public const int OriginalRefFieldNumber = 13;
    private readonly static int OriginalRefDefaultValue = 0;

    private int originalRef_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int OriginalRef {
      get { if ((_hasBits0 & 16) != 0) { return originalRef_; } else { return OriginalRefDefaultValue; } }
      set {
        _hasBits0 |= 16;
        originalRef_ = value;
      }
    }
    /// <summary>Gets whether the "originalRef" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasOriginalRef {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "originalRef" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearOriginalRef() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "goldCorefClusterID" field.</summary>
    public const int GoldCorefClusterIDFieldNumber = 14;
    private readonly static int GoldCorefClusterIDDefaultValue = 0;

    private int goldCorefClusterID_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int GoldCorefClusterID {
      get { if ((_hasBits0 & 32) != 0) { return goldCorefClusterID_; } else { return GoldCorefClusterIDDefaultValue; } }
      set {
        _hasBits0 |= 32;
        goldCorefClusterID_ = value;
      }
    }
    /// <summary>Gets whether the "goldCorefClusterID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGoldCorefClusterID {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "goldCorefClusterID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGoldCorefClusterID() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "corefClusterID" field.</summary>
    public const int CorefClusterIDFieldNumber = 15;
    private readonly static int CorefClusterIDDefaultValue = 0;

    private int corefClusterID_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CorefClusterID {
      get { if ((_hasBits0 & 64) != 0) { return corefClusterID_; } else { return CorefClusterIDDefaultValue; } }
      set {
        _hasBits0 |= 64;
        corefClusterID_ = value;
      }
    }
    /// <summary>Gets whether the "corefClusterID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCorefClusterID {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "corefClusterID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCorefClusterID() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "mentionNum" field.</summary>
    public const int MentionNumFieldNumber = 16;
    private readonly static int MentionNumDefaultValue = 0;

    private int mentionNum_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MentionNum {
      get { if ((_hasBits0 & 128) != 0) { return mentionNum_; } else { return MentionNumDefaultValue; } }
      set {
        _hasBits0 |= 128;
        mentionNum_ = value;
      }
    }
    /// <summary>Gets whether the "mentionNum" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMentionNum {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "mentionNum" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMentionNum() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "sentNum" field.</summary>
    public const int SentNumFieldNumber = 17;
    private readonly static int SentNumDefaultValue = 0;

    private int sentNum_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SentNum {
      get { if ((_hasBits0 & 256) != 0) { return sentNum_; } else { return SentNumDefaultValue; } }
      set {
        _hasBits0 |= 256;
        sentNum_ = value;
      }
    }
    /// <summary>Gets whether the "sentNum" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentNum {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "sentNum" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentNum() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "utter" field.</summary>
    public const int UtterFieldNumber = 18;
    private readonly static int UtterDefaultValue = 0;

    private int utter_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Utter {
      get { if ((_hasBits0 & 512) != 0) { return utter_; } else { return UtterDefaultValue; } }
      set {
        _hasBits0 |= 512;
        utter_ = value;
      }
    }
    /// <summary>Gets whether the "utter" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUtter {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "utter" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUtter() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "paragraph" field.</summary>
    public const int ParagraphFieldNumber = 19;
    private readonly static int ParagraphDefaultValue = 0;

    private int paragraph_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Paragraph {
      get { if ((_hasBits0 & 1024) != 0) { return paragraph_; } else { return ParagraphDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        paragraph_ = value;
      }
    }
    /// <summary>Gets whether the "paragraph" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasParagraph {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "paragraph" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearParagraph() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "isSubject" field.</summary>
    public const int IsSubjectFieldNumber = 20;
    private readonly static bool IsSubjectDefaultValue = false;

    private bool isSubject_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSubject {
      get { if ((_hasBits0 & 2048) != 0) { return isSubject_; } else { return IsSubjectDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        isSubject_ = value;
      }
    }
    /// <summary>Gets whether the "isSubject" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsSubject {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "isSubject" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsSubject() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "isDirectObject" field.</summary>
    public const int IsDirectObjectFieldNumber = 21;
    private readonly static bool IsDirectObjectDefaultValue = false;

    private bool isDirectObject_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDirectObject {
      get { if ((_hasBits0 & 4096) != 0) { return isDirectObject_; } else { return IsDirectObjectDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        isDirectObject_ = value;
      }
    }
    /// <summary>Gets whether the "isDirectObject" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsDirectObject {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "isDirectObject" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsDirectObject() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "isIndirectObject" field.</summary>
    public const int IsIndirectObjectFieldNumber = 22;
    private readonly static bool IsIndirectObjectDefaultValue = false;

    private bool isIndirectObject_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsIndirectObject {
      get { if ((_hasBits0 & 8192) != 0) { return isIndirectObject_; } else { return IsIndirectObjectDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        isIndirectObject_ = value;
      }
    }
    /// <summary>Gets whether the "isIndirectObject" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsIndirectObject {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "isIndirectObject" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsIndirectObject() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "isPrepositionObject" field.</summary>
    public const int IsPrepositionObjectFieldNumber = 23;
    private readonly static bool IsPrepositionObjectDefaultValue = false;

    private bool isPrepositionObject_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsPrepositionObject {
      get { if ((_hasBits0 & 16384) != 0) { return isPrepositionObject_; } else { return IsPrepositionObjectDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        isPrepositionObject_ = value;
      }
    }
    /// <summary>Gets whether the "isPrepositionObject" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsPrepositionObject {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "isPrepositionObject" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsPrepositionObject() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "hasTwin" field.</summary>
    public const int HasTwinFieldNumber = 24;
    private readonly static bool HasTwinDefaultValue = false;

    private bool hasTwin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTwin {
      get { if ((_hasBits0 & 32768) != 0) { return hasTwin_; } else { return HasTwinDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        hasTwin_ = value;
      }
    }
    /// <summary>Gets whether the "hasTwin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasTwin {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "hasTwin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasTwin() {
      _hasBits0 &= ~32768;
    }

    /// <summary>Field number for the "generic" field.</summary>
    public const int GenericFieldNumber = 25;
    private readonly static bool GenericDefaultValue = false;

    private bool generic_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Generic {
      get { if ((_hasBits0 & 65536) != 0) { return generic_; } else { return GenericDefaultValue; } }
      set {
        _hasBits0 |= 65536;
        generic_ = value;
      }
    }
    /// <summary>Gets whether the "generic" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGeneric {
      get { return (_hasBits0 & 65536) != 0; }
    }
    /// <summary>Clears the value of the "generic" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGeneric() {
      _hasBits0 &= ~65536;
    }

    /// <summary>Field number for the "isSingleton" field.</summary>
    public const int IsSingletonFieldNumber = 26;
    private readonly static bool IsSingletonDefaultValue = false;

    private bool isSingleton_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsSingleton {
      get { if ((_hasBits0 & 131072) != 0) { return isSingleton_; } else { return IsSingletonDefaultValue; } }
      set {
        _hasBits0 |= 131072;
        isSingleton_ = value;
      }
    }
    /// <summary>Gets whether the "isSingleton" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsSingleton {
      get { return (_hasBits0 & 131072) != 0; }
    }
    /// <summary>Clears the value of the "isSingleton" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsSingleton() {
      _hasBits0 &= ~131072;
    }

    /// <summary>Field number for the "hasBasicDependency" field.</summary>
    public const int HasBasicDependencyFieldNumber = 27;
    private readonly static bool HasBasicDependencyDefaultValue = false;

    private bool hasBasicDependency_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBasicDependency {
      get { if ((_hasBits0 & 262144) != 0) { return hasBasicDependency_; } else { return HasBasicDependencyDefaultValue; } }
      set {
        _hasBits0 |= 262144;
        hasBasicDependency_ = value;
      }
    }
    /// <summary>Gets whether the "hasBasicDependency" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasBasicDependency {
      get { return (_hasBits0 & 262144) != 0; }
    }
    /// <summary>Clears the value of the "hasBasicDependency" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasBasicDependency() {
      _hasBits0 &= ~262144;
    }

    /// <summary>Field number for the "hasEnhancedDepenedncy" field.</summary>
    public const int HasEnhancedDepenedncyFieldNumber = 28;
    private readonly static bool HasEnhancedDepenedncyDefaultValue = false;

    private bool hasEnhancedDepenedncy_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEnhancedDepenedncy {
      get { if ((_hasBits0 & 524288) != 0) { return hasEnhancedDepenedncy_; } else { return HasEnhancedDepenedncyDefaultValue; } }
      set {
        _hasBits0 |= 524288;
        hasEnhancedDepenedncy_ = value;
      }
    }
    /// <summary>Gets whether the "hasEnhancedDepenedncy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasEnhancedDepenedncy {
      get { return (_hasBits0 & 524288) != 0; }
    }
    /// <summary>Clears the value of the "hasEnhancedDepenedncy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasEnhancedDepenedncy() {
      _hasBits0 &= ~524288;
    }

    /// <summary>Field number for the "hasContextParseTree" field.</summary>
    public const int HasContextParseTreeFieldNumber = 29;
    private readonly static bool HasContextParseTreeDefaultValue = false;

    private bool hasContextParseTree_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasContextParseTree {
      get { if ((_hasBits0 & 1048576) != 0) { return hasContextParseTree_; } else { return HasContextParseTreeDefaultValue; } }
      set {
        _hasBits0 |= 1048576;
        hasContextParseTree_ = value;
      }
    }
    /// <summary>Gets whether the "hasContextParseTree" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHasContextParseTree {
      get { return (_hasBits0 & 1048576) != 0; }
    }
    /// <summary>Clears the value of the "hasContextParseTree" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHasContextParseTree() {
      _hasBits0 &= ~1048576;
    }

    /// <summary>Field number for the "headIndexedWord" field.</summary>
    public const int HeadIndexedWordFieldNumber = 30;
    private global::Edu.Stanford.Nlp.Pipeline.IndexedWord headIndexedWord_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.IndexedWord HeadIndexedWord {
      get { return headIndexedWord_; }
      set {
        headIndexedWord_ = value;
      }
    }

    /// <summary>Field number for the "dependingVerb" field.</summary>
    public const int DependingVerbFieldNumber = 31;
    private global::Edu.Stanford.Nlp.Pipeline.IndexedWord dependingVerb_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.IndexedWord DependingVerb {
      get { return dependingVerb_; }
      set {
        dependingVerb_ = value;
      }
    }

    /// <summary>Field number for the "headWord" field.</summary>
    public const int HeadWordFieldNumber = 32;
    private global::Edu.Stanford.Nlp.Pipeline.IndexedWord headWord_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.IndexedWord HeadWord {
      get { return headWord_; }
      set {
        headWord_ = value;
      }
    }

    /// <summary>Field number for the "speakerInfo" field.</summary>
    public const int SpeakerInfoFieldNumber = 33;
    private global::Edu.Stanford.Nlp.Pipeline.SpeakerInfo speakerInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.SpeakerInfo SpeakerInfo {
      get { return speakerInfo_; }
      set {
        speakerInfo_ = value;
      }
    }

    /// <summary>Field number for the "sentenceWords" field.</summary>
    public const int SentenceWordsFieldNumber = 50;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.IndexedWord> _repeated_sentenceWords_codec
        = pb::FieldCodec.ForMessage(402, global::Edu.Stanford.Nlp.Pipeline.IndexedWord.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.IndexedWord> sentenceWords_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.IndexedWord>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.IndexedWord> SentenceWords {
      get { return sentenceWords_; }
    }

    /// <summary>Field number for the "originalSpan" field.</summary>
    public const int OriginalSpanFieldNumber = 51;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.IndexedWord> _repeated_originalSpan_codec
        = pb::FieldCodec.ForMessage(410, global::Edu.Stanford.Nlp.Pipeline.IndexedWord.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.IndexedWord> originalSpan_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.IndexedWord>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.IndexedWord> OriginalSpan {
      get { return originalSpan_; }
    }

    /// <summary>Field number for the "dependents" field.</summary>
    public const int DependentsFieldNumber = 52;
    private static readonly pb::FieldCodec<string> _repeated_dependents_codec
        = pb::FieldCodec.ForString(418);
    private readonly pbc::RepeatedField<string> dependents_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Dependents {
      get { return dependents_; }
    }

    /// <summary>Field number for the "preprocessedTerms" field.</summary>
    public const int PreprocessedTermsFieldNumber = 53;
    private static readonly pb::FieldCodec<string> _repeated_preprocessedTerms_codec
        = pb::FieldCodec.ForString(426);
    private readonly pbc::RepeatedField<string> preprocessedTerms_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> PreprocessedTerms {
      get { return preprocessedTerms_; }
    }

    /// <summary>Field number for the "appositions" field.</summary>
    public const int AppositionsFieldNumber = 54;
    private static readonly pb::FieldCodec<int> _repeated_appositions_codec
        = pb::FieldCodec.ForInt32(432);
    private readonly pbc::RepeatedField<int> appositions_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> Appositions {
      get { return appositions_; }
    }

    /// <summary>Field number for the "predicateNominatives" field.</summary>
    public const int PredicateNominativesFieldNumber = 55;
    private static readonly pb::FieldCodec<int> _repeated_predicateNominatives_codec
        = pb::FieldCodec.ForInt32(440);
    private readonly pbc::RepeatedField<int> predicateNominatives_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> PredicateNominatives {
      get { return predicateNominatives_; }
    }

    /// <summary>Field number for the "relativePronouns" field.</summary>
    public const int RelativePronounsFieldNumber = 56;
    private static readonly pb::FieldCodec<int> _repeated_relativePronouns_codec
        = pb::FieldCodec.ForInt32(448);
    private readonly pbc::RepeatedField<int> relativePronouns_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> RelativePronouns {
      get { return relativePronouns_; }
    }

    /// <summary>Field number for the "listMembers" field.</summary>
    public const int ListMembersFieldNumber = 57;
    private static readonly pb::FieldCodec<int> _repeated_listMembers_codec
        = pb::FieldCodec.ForInt32(456);
    private readonly pbc::RepeatedField<int> listMembers_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> ListMembers {
      get { return listMembers_; }
    }

    /// <summary>Field number for the "belongToLists" field.</summary>
    public const int BelongToListsFieldNumber = 58;
    private static readonly pb::FieldCodec<int> _repeated_belongToLists_codec
        = pb::FieldCodec.ForInt32(464);
    private readonly pbc::RepeatedField<int> belongToLists_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> BelongToLists {
      get { return belongToLists_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Mention);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Mention other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MentionID != other.MentionID) return false;
      if (MentionType != other.MentionType) return false;
      if (Number != other.Number) return false;
      if (Gender != other.Gender) return false;
      if (Animacy != other.Animacy) return false;
      if (Person != other.Person) return false;
      if (StartIndex != other.StartIndex) return false;
      if (EndIndex != other.EndIndex) return false;
      if (HeadIndex != other.HeadIndex) return false;
      if (HeadString != other.HeadString) return false;
      if (NerString != other.NerString) return false;
      if (OriginalRef != other.OriginalRef) return false;
      if (GoldCorefClusterID != other.GoldCorefClusterID) return false;
      if (CorefClusterID != other.CorefClusterID) return false;
      if (MentionNum != other.MentionNum) return false;
      if (SentNum != other.SentNum) return false;
      if (Utter != other.Utter) return false;
      if (Paragraph != other.Paragraph) return false;
      if (IsSubject != other.IsSubject) return false;
      if (IsDirectObject != other.IsDirectObject) return false;
      if (IsIndirectObject != other.IsIndirectObject) return false;
      if (IsPrepositionObject != other.IsPrepositionObject) return false;
      if (HasTwin != other.HasTwin) return false;
      if (Generic != other.Generic) return false;
      if (IsSingleton != other.IsSingleton) return false;
      if (HasBasicDependency != other.HasBasicDependency) return false;
      if (HasEnhancedDepenedncy != other.HasEnhancedDepenedncy) return false;
      if (HasContextParseTree != other.HasContextParseTree) return false;
      if (!object.Equals(HeadIndexedWord, other.HeadIndexedWord)) return false;
      if (!object.Equals(DependingVerb, other.DependingVerb)) return false;
      if (!object.Equals(HeadWord, other.HeadWord)) return false;
      if (!object.Equals(SpeakerInfo, other.SpeakerInfo)) return false;
      if(!sentenceWords_.Equals(other.sentenceWords_)) return false;
      if(!originalSpan_.Equals(other.originalSpan_)) return false;
      if(!dependents_.Equals(other.dependents_)) return false;
      if(!preprocessedTerms_.Equals(other.preprocessedTerms_)) return false;
      if(!appositions_.Equals(other.appositions_)) return false;
      if(!predicateNominatives_.Equals(other.predicateNominatives_)) return false;
      if(!relativePronouns_.Equals(other.relativePronouns_)) return false;
      if(!listMembers_.Equals(other.listMembers_)) return false;
      if(!belongToLists_.Equals(other.belongToLists_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMentionID) hash ^= MentionID.GetHashCode();
      if (HasMentionType) hash ^= MentionType.GetHashCode();
      if (HasNumber) hash ^= Number.GetHashCode();
      if (HasGender) hash ^= Gender.GetHashCode();
      if (HasAnimacy) hash ^= Animacy.GetHashCode();
      if (HasPerson) hash ^= Person.GetHashCode();
      if (HasStartIndex) hash ^= StartIndex.GetHashCode();
      if (HasEndIndex) hash ^= EndIndex.GetHashCode();
      if (HasHeadIndex) hash ^= HeadIndex.GetHashCode();
      if (HasHeadString) hash ^= HeadString.GetHashCode();
      if (HasNerString) hash ^= NerString.GetHashCode();
      if (HasOriginalRef) hash ^= OriginalRef.GetHashCode();
      if (HasGoldCorefClusterID) hash ^= GoldCorefClusterID.GetHashCode();
      if (HasCorefClusterID) hash ^= CorefClusterID.GetHashCode();
      if (HasMentionNum) hash ^= MentionNum.GetHashCode();
      if (HasSentNum) hash ^= SentNum.GetHashCode();
      if (HasUtter) hash ^= Utter.GetHashCode();
      if (HasParagraph) hash ^= Paragraph.GetHashCode();
      if (HasIsSubject) hash ^= IsSubject.GetHashCode();
      if (HasIsDirectObject) hash ^= IsDirectObject.GetHashCode();
      if (HasIsIndirectObject) hash ^= IsIndirectObject.GetHashCode();
      if (HasIsPrepositionObject) hash ^= IsPrepositionObject.GetHashCode();
      if (HasHasTwin) hash ^= HasTwin.GetHashCode();
      if (HasGeneric) hash ^= Generic.GetHashCode();
      if (HasIsSingleton) hash ^= IsSingleton.GetHashCode();
      if (HasHasBasicDependency) hash ^= HasBasicDependency.GetHashCode();
      if (HasHasEnhancedDepenedncy) hash ^= HasEnhancedDepenedncy.GetHashCode();
      if (HasHasContextParseTree) hash ^= HasContextParseTree.GetHashCode();
      if (headIndexedWord_ != null) hash ^= HeadIndexedWord.GetHashCode();
      if (dependingVerb_ != null) hash ^= DependingVerb.GetHashCode();
      if (headWord_ != null) hash ^= HeadWord.GetHashCode();
      if (speakerInfo_ != null) hash ^= SpeakerInfo.GetHashCode();
      hash ^= sentenceWords_.GetHashCode();
      hash ^= originalSpan_.GetHashCode();
      hash ^= dependents_.GetHashCode();
      hash ^= preprocessedTerms_.GetHashCode();
      hash ^= appositions_.GetHashCode();
      hash ^= predicateNominatives_.GetHashCode();
      hash ^= relativePronouns_.GetHashCode();
      hash ^= listMembers_.GetHashCode();
      hash ^= belongToLists_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasMentionID) {
        output.WriteRawTag(8);
        output.WriteInt32(MentionID);
      }
      if (HasMentionType) {
        output.WriteRawTag(18);
        output.WriteString(MentionType);
      }
      if (HasNumber) {
        output.WriteRawTag(26);
        output.WriteString(Number);
      }
      if (HasGender) {
        output.WriteRawTag(34);
        output.WriteString(Gender);
      }
      if (HasAnimacy) {
        output.WriteRawTag(42);
        output.WriteString(Animacy);
      }
      if (HasPerson) {
        output.WriteRawTag(50);
        output.WriteString(Person);
      }
      if (HasStartIndex) {
        output.WriteRawTag(56);
        output.WriteUInt32(StartIndex);
      }
      if (HasEndIndex) {
        output.WriteRawTag(72);
        output.WriteUInt32(EndIndex);
      }
      if (HasHeadIndex) {
        output.WriteRawTag(80);
        output.WriteInt32(HeadIndex);
      }
      if (HasHeadString) {
        output.WriteRawTag(90);
        output.WriteString(HeadString);
      }
      if (HasNerString) {
        output.WriteRawTag(98);
        output.WriteString(NerString);
      }
      if (HasOriginalRef) {
        output.WriteRawTag(104);
        output.WriteInt32(OriginalRef);
      }
      if (HasGoldCorefClusterID) {
        output.WriteRawTag(112);
        output.WriteInt32(GoldCorefClusterID);
      }
      if (HasCorefClusterID) {
        output.WriteRawTag(120);
        output.WriteInt32(CorefClusterID);
      }
      if (HasMentionNum) {
        output.WriteRawTag(128, 1);
        output.WriteInt32(MentionNum);
      }
      if (HasSentNum) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(SentNum);
      }
      if (HasUtter) {
        output.WriteRawTag(144, 1);
        output.WriteInt32(Utter);
      }
      if (HasParagraph) {
        output.WriteRawTag(152, 1);
        output.WriteInt32(Paragraph);
      }
      if (HasIsSubject) {
        output.WriteRawTag(160, 1);
        output.WriteBool(IsSubject);
      }
      if (HasIsDirectObject) {
        output.WriteRawTag(168, 1);
        output.WriteBool(IsDirectObject);
      }
      if (HasIsIndirectObject) {
        output.WriteRawTag(176, 1);
        output.WriteBool(IsIndirectObject);
      }
      if (HasIsPrepositionObject) {
        output.WriteRawTag(184, 1);
        output.WriteBool(IsPrepositionObject);
      }
      if (HasHasTwin) {
        output.WriteRawTag(192, 1);
        output.WriteBool(HasTwin);
      }
      if (HasGeneric) {
        output.WriteRawTag(200, 1);
        output.WriteBool(Generic);
      }
      if (HasIsSingleton) {
        output.WriteRawTag(208, 1);
        output.WriteBool(IsSingleton);
      }
      if (HasHasBasicDependency) {
        output.WriteRawTag(216, 1);
        output.WriteBool(HasBasicDependency);
      }
      if (HasHasEnhancedDepenedncy) {
        output.WriteRawTag(224, 1);
        output.WriteBool(HasEnhancedDepenedncy);
      }
      if (HasHasContextParseTree) {
        output.WriteRawTag(232, 1);
        output.WriteBool(HasContextParseTree);
      }
      if (headIndexedWord_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(HeadIndexedWord);
      }
      if (dependingVerb_ != null) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(DependingVerb);
      }
      if (headWord_ != null) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(HeadWord);
      }
      if (speakerInfo_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(SpeakerInfo);
      }
      sentenceWords_.WriteTo(output, _repeated_sentenceWords_codec);
      originalSpan_.WriteTo(output, _repeated_originalSpan_codec);
      dependents_.WriteTo(output, _repeated_dependents_codec);
      preprocessedTerms_.WriteTo(output, _repeated_preprocessedTerms_codec);
      appositions_.WriteTo(output, _repeated_appositions_codec);
      predicateNominatives_.WriteTo(output, _repeated_predicateNominatives_codec);
      relativePronouns_.WriteTo(output, _repeated_relativePronouns_codec);
      listMembers_.WriteTo(output, _repeated_listMembers_codec);
      belongToLists_.WriteTo(output, _repeated_belongToLists_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasMentionID) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MentionID);
      }
      if (HasMentionType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MentionType);
      }
      if (HasNumber) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Number);
      }
      if (HasGender) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Gender);
      }
      if (HasAnimacy) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Animacy);
      }
      if (HasPerson) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Person);
      }
      if (HasStartIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(StartIndex);
      }
      if (HasEndIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EndIndex);
      }
      if (HasHeadIndex) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(HeadIndex);
      }
      if (HasHeadString) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HeadString);
      }
      if (HasNerString) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NerString);
      }
      if (HasOriginalRef) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(OriginalRef);
      }
      if (HasGoldCorefClusterID) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(GoldCorefClusterID);
      }
      if (HasCorefClusterID) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CorefClusterID);
      }
      if (HasMentionNum) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MentionNum);
      }
      if (HasSentNum) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(SentNum);
      }
      if (HasUtter) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Utter);
      }
      if (HasParagraph) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Paragraph);
      }
      if (HasIsSubject) {
        size += 2 + 1;
      }
      if (HasIsDirectObject) {
        size += 2 + 1;
      }
      if (HasIsIndirectObject) {
        size += 2 + 1;
      }
      if (HasIsPrepositionObject) {
        size += 2 + 1;
      }
      if (HasHasTwin) {
        size += 2 + 1;
      }
      if (HasGeneric) {
        size += 2 + 1;
      }
      if (HasIsSingleton) {
        size += 2 + 1;
      }
      if (HasHasBasicDependency) {
        size += 2 + 1;
      }
      if (HasHasEnhancedDepenedncy) {
        size += 2 + 1;
      }
      if (HasHasContextParseTree) {
        size += 2 + 1;
      }
      if (headIndexedWord_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HeadIndexedWord);
      }
      if (dependingVerb_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DependingVerb);
      }
      if (headWord_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HeadWord);
      }
      if (speakerInfo_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SpeakerInfo);
      }
      size += sentenceWords_.CalculateSize(_repeated_sentenceWords_codec);
      size += originalSpan_.CalculateSize(_repeated_originalSpan_codec);
      size += dependents_.CalculateSize(_repeated_dependents_codec);
      size += preprocessedTerms_.CalculateSize(_repeated_preprocessedTerms_codec);
      size += appositions_.CalculateSize(_repeated_appositions_codec);
      size += predicateNominatives_.CalculateSize(_repeated_predicateNominatives_codec);
      size += relativePronouns_.CalculateSize(_repeated_relativePronouns_codec);
      size += listMembers_.CalculateSize(_repeated_listMembers_codec);
      size += belongToLists_.CalculateSize(_repeated_belongToLists_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Mention other) {
      if (other == null) {
        return;
      }
      if (other.HasMentionID) {
        MentionID = other.MentionID;
      }
      if (other.HasMentionType) {
        MentionType = other.MentionType;
      }
      if (other.HasNumber) {
        Number = other.Number;
      }
      if (other.HasGender) {
        Gender = other.Gender;
      }
      if (other.HasAnimacy) {
        Animacy = other.Animacy;
      }
      if (other.HasPerson) {
        Person = other.Person;
      }
      if (other.HasStartIndex) {
        StartIndex = other.StartIndex;
      }
      if (other.HasEndIndex) {
        EndIndex = other.EndIndex;
      }
      if (other.HasHeadIndex) {
        HeadIndex = other.HeadIndex;
      }
      if (other.HasHeadString) {
        HeadString = other.HeadString;
      }
      if (other.HasNerString) {
        NerString = other.NerString;
      }
      if (other.HasOriginalRef) {
        OriginalRef = other.OriginalRef;
      }
      if (other.HasGoldCorefClusterID) {
        GoldCorefClusterID = other.GoldCorefClusterID;
      }
      if (other.HasCorefClusterID) {
        CorefClusterID = other.CorefClusterID;
      }
      if (other.HasMentionNum) {
        MentionNum = other.MentionNum;
      }
      if (other.HasSentNum) {
        SentNum = other.SentNum;
      }
      if (other.HasUtter) {
        Utter = other.Utter;
      }
      if (other.HasParagraph) {
        Paragraph = other.Paragraph;
      }
      if (other.HasIsSubject) {
        IsSubject = other.IsSubject;
      }
      if (other.HasIsDirectObject) {
        IsDirectObject = other.IsDirectObject;
      }
      if (other.HasIsIndirectObject) {
        IsIndirectObject = other.IsIndirectObject;
      }
      if (other.HasIsPrepositionObject) {
        IsPrepositionObject = other.IsPrepositionObject;
      }
      if (other.HasHasTwin) {
        HasTwin = other.HasTwin;
      }
      if (other.HasGeneric) {
        Generic = other.Generic;
      }
      if (other.HasIsSingleton) {
        IsSingleton = other.IsSingleton;
      }
      if (other.HasHasBasicDependency) {
        HasBasicDependency = other.HasBasicDependency;
      }
      if (other.HasHasEnhancedDepenedncy) {
        HasEnhancedDepenedncy = other.HasEnhancedDepenedncy;
      }
      if (other.HasHasContextParseTree) {
        HasContextParseTree = other.HasContextParseTree;
      }
      if (other.headIndexedWord_ != null) {
        if (headIndexedWord_ == null) {
          HeadIndexedWord = new global::Edu.Stanford.Nlp.Pipeline.IndexedWord();
        }
        HeadIndexedWord.MergeFrom(other.HeadIndexedWord);
      }
      if (other.dependingVerb_ != null) {
        if (dependingVerb_ == null) {
          DependingVerb = new global::Edu.Stanford.Nlp.Pipeline.IndexedWord();
        }
        DependingVerb.MergeFrom(other.DependingVerb);
      }
      if (other.headWord_ != null) {
        if (headWord_ == null) {
          HeadWord = new global::Edu.Stanford.Nlp.Pipeline.IndexedWord();
        }
        HeadWord.MergeFrom(other.HeadWord);
      }
      if (other.speakerInfo_ != null) {
        if (speakerInfo_ == null) {
          SpeakerInfo = new global::Edu.Stanford.Nlp.Pipeline.SpeakerInfo();
        }
        SpeakerInfo.MergeFrom(other.SpeakerInfo);
      }
      sentenceWords_.Add(other.sentenceWords_);
      originalSpan_.Add(other.originalSpan_);
      dependents_.Add(other.dependents_);
      preprocessedTerms_.Add(other.preprocessedTerms_);
      appositions_.Add(other.appositions_);
      predicateNominatives_.Add(other.predicateNominatives_);
      relativePronouns_.Add(other.relativePronouns_);
      listMembers_.Add(other.listMembers_);
      belongToLists_.Add(other.belongToLists_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MentionID = input.ReadInt32();
            break;
          }
          case 18: {
            MentionType = input.ReadString();
            break;
          }
          case 26: {
            Number = input.ReadString();
            break;
          }
          case 34: {
            Gender = input.ReadString();
            break;
          }
          case 42: {
            Animacy = input.ReadString();
            break;
          }
          case 50: {
            Person = input.ReadString();
            break;
          }
          case 56: {
            StartIndex = input.ReadUInt32();
            break;
          }
          case 72: {
            EndIndex = input.ReadUInt32();
            break;
          }
          case 80: {
            HeadIndex = input.ReadInt32();
            break;
          }
          case 90: {
            HeadString = input.ReadString();
            break;
          }
          case 98: {
            NerString = input.ReadString();
            break;
          }
          case 104: {
            OriginalRef = input.ReadInt32();
            break;
          }
          case 112: {
            GoldCorefClusterID = input.ReadInt32();
            break;
          }
          case 120: {
            CorefClusterID = input.ReadInt32();
            break;
          }
          case 128: {
            MentionNum = input.ReadInt32();
            break;
          }
          case 136: {
            SentNum = input.ReadInt32();
            break;
          }
          case 144: {
            Utter = input.ReadInt32();
            break;
          }
          case 152: {
            Paragraph = input.ReadInt32();
            break;
          }
          case 160: {
            IsSubject = input.ReadBool();
            break;
          }
          case 168: {
            IsDirectObject = input.ReadBool();
            break;
          }
          case 176: {
            IsIndirectObject = input.ReadBool();
            break;
          }
          case 184: {
            IsPrepositionObject = input.ReadBool();
            break;
          }
          case 192: {
            HasTwin = input.ReadBool();
            break;
          }
          case 200: {
            Generic = input.ReadBool();
            break;
          }
          case 208: {
            IsSingleton = input.ReadBool();
            break;
          }
          case 216: {
            HasBasicDependency = input.ReadBool();
            break;
          }
          case 224: {
            HasEnhancedDepenedncy = input.ReadBool();
            break;
          }
          case 232: {
            HasContextParseTree = input.ReadBool();
            break;
          }
          case 242: {
            if (headIndexedWord_ == null) {
              HeadIndexedWord = new global::Edu.Stanford.Nlp.Pipeline.IndexedWord();
            }
            input.ReadMessage(HeadIndexedWord);
            break;
          }
          case 250: {
            if (dependingVerb_ == null) {
              DependingVerb = new global::Edu.Stanford.Nlp.Pipeline.IndexedWord();
            }
            input.ReadMessage(DependingVerb);
            break;
          }
          case 258: {
            if (headWord_ == null) {
              HeadWord = new global::Edu.Stanford.Nlp.Pipeline.IndexedWord();
            }
            input.ReadMessage(HeadWord);
            break;
          }
          case 266: {
            if (speakerInfo_ == null) {
              SpeakerInfo = new global::Edu.Stanford.Nlp.Pipeline.SpeakerInfo();
            }
            input.ReadMessage(SpeakerInfo);
            break;
          }
          case 402: {
            sentenceWords_.AddEntriesFrom(input, _repeated_sentenceWords_codec);
            break;
          }
          case 410: {
            originalSpan_.AddEntriesFrom(input, _repeated_originalSpan_codec);
            break;
          }
          case 418: {
            dependents_.AddEntriesFrom(input, _repeated_dependents_codec);
            break;
          }
          case 426: {
            preprocessedTerms_.AddEntriesFrom(input, _repeated_preprocessedTerms_codec);
            break;
          }
          case 434:
          case 432: {
            appositions_.AddEntriesFrom(input, _repeated_appositions_codec);
            break;
          }
          case 442:
          case 440: {
            predicateNominatives_.AddEntriesFrom(input, _repeated_predicateNominatives_codec);
            break;
          }
          case 450:
          case 448: {
            relativePronouns_.AddEntriesFrom(input, _repeated_relativePronouns_codec);
            break;
          }
          case 458:
          case 456: {
            listMembers_.AddEntriesFrom(input, _repeated_listMembers_codec);
            break;
          }
          case 466:
          case 464: {
            belongToLists_.AddEntriesFrom(input, _repeated_belongToLists_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class IndexedWord : pb::IMessage<IndexedWord> {
    private static readonly pb::MessageParser<IndexedWord> _parser = new pb::MessageParser<IndexedWord>(() => new IndexedWord());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<IndexedWord> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IndexedWord() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IndexedWord(IndexedWord other) : this() {
      _hasBits0 = other._hasBits0;
      sentenceNum_ = other.sentenceNum_;
      tokenIndex_ = other.tokenIndex_;
      docID_ = other.docID_;
      copyCount_ = other.copyCount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IndexedWord Clone() {
      return new IndexedWord(this);
    }

    /// <summary>Field number for the "sentenceNum" field.</summary>
    public const int SentenceNumFieldNumber = 1;
    private readonly static int SentenceNumDefaultValue = 0;

    private int sentenceNum_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SentenceNum {
      get { if ((_hasBits0 & 1) != 0) { return sentenceNum_; } else { return SentenceNumDefaultValue; } }
      set {
        _hasBits0 |= 1;
        sentenceNum_ = value;
      }
    }
    /// <summary>Gets whether the "sentenceNum" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentenceNum {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "sentenceNum" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentenceNum() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "tokenIndex" field.</summary>
    public const int TokenIndexFieldNumber = 2;
    private readonly static int TokenIndexDefaultValue = 0;

    private int tokenIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int TokenIndex {
      get { if ((_hasBits0 & 2) != 0) { return tokenIndex_; } else { return TokenIndexDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tokenIndex_ = value;
      }
    }
    /// <summary>Gets whether the "tokenIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenIndex {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tokenIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenIndex() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "docID" field.</summary>
    public const int DocIDFieldNumber = 3;
    private readonly static int DocIDDefaultValue = 0;

    private int docID_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int DocID {
      get { if ((_hasBits0 & 4) != 0) { return docID_; } else { return DocIDDefaultValue; } }
      set {
        _hasBits0 |= 4;
        docID_ = value;
      }
    }
    /// <summary>Gets whether the "docID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDocID {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "docID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDocID() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "copyCount" field.</summary>
    public const int CopyCountFieldNumber = 4;
    private readonly static uint CopyCountDefaultValue = 0;

    private uint copyCount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CopyCount {
      get { if ((_hasBits0 & 8) != 0) { return copyCount_; } else { return CopyCountDefaultValue; } }
      set {
        _hasBits0 |= 8;
        copyCount_ = value;
      }
    }
    /// <summary>Gets whether the "copyCount" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCopyCount {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "copyCount" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCopyCount() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as IndexedWord);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(IndexedWord other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SentenceNum != other.SentenceNum) return false;
      if (TokenIndex != other.TokenIndex) return false;
      if (DocID != other.DocID) return false;
      if (CopyCount != other.CopyCount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSentenceNum) hash ^= SentenceNum.GetHashCode();
      if (HasTokenIndex) hash ^= TokenIndex.GetHashCode();
      if (HasDocID) hash ^= DocID.GetHashCode();
      if (HasCopyCount) hash ^= CopyCount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasSentenceNum) {
        output.WriteRawTag(8);
        output.WriteInt32(SentenceNum);
      }
      if (HasTokenIndex) {
        output.WriteRawTag(16);
        output.WriteInt32(TokenIndex);
      }
      if (HasDocID) {
        output.WriteRawTag(24);
        output.WriteInt32(DocID);
      }
      if (HasCopyCount) {
        output.WriteRawTag(32);
        output.WriteUInt32(CopyCount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasSentenceNum) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SentenceNum);
      }
      if (HasTokenIndex) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TokenIndex);
      }
      if (HasDocID) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DocID);
      }
      if (HasCopyCount) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CopyCount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(IndexedWord other) {
      if (other == null) {
        return;
      }
      if (other.HasSentenceNum) {
        SentenceNum = other.SentenceNum;
      }
      if (other.HasTokenIndex) {
        TokenIndex = other.TokenIndex;
      }
      if (other.HasDocID) {
        DocID = other.DocID;
      }
      if (other.HasCopyCount) {
        CopyCount = other.CopyCount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SentenceNum = input.ReadInt32();
            break;
          }
          case 16: {
            TokenIndex = input.ReadInt32();
            break;
          }
          case 24: {
            DocID = input.ReadInt32();
            break;
          }
          case 32: {
            CopyCount = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SpeakerInfo : pb::IMessage<SpeakerInfo> {
    private static readonly pb::MessageParser<SpeakerInfo> _parser = new pb::MessageParser<SpeakerInfo>(() => new SpeakerInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SpeakerInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SpeakerInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SpeakerInfo(SpeakerInfo other) : this() {
      speakerName_ = other.speakerName_;
      mentions_ = other.mentions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SpeakerInfo Clone() {
      return new SpeakerInfo(this);
    }

    /// <summary>Field number for the "speakerName" field.</summary>
    public const int SpeakerNameFieldNumber = 1;
    private readonly static string SpeakerNameDefaultValue = "";

    private string speakerName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SpeakerName {
      get { return speakerName_ ?? SpeakerNameDefaultValue; }
      set {
        speakerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "speakerName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSpeakerName {
      get { return speakerName_ != null; }
    }
    /// <summary>Clears the value of the "speakerName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSpeakerName() {
      speakerName_ = null;
    }

    /// <summary>Field number for the "mentions" field.</summary>
    public const int MentionsFieldNumber = 2;
    private static readonly pb::FieldCodec<int> _repeated_mentions_codec
        = pb::FieldCodec.ForInt32(16);
    private readonly pbc::RepeatedField<int> mentions_ = new pbc::RepeatedField<int>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> Mentions {
      get { return mentions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SpeakerInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SpeakerInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SpeakerName != other.SpeakerName) return false;
      if(!mentions_.Equals(other.mentions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSpeakerName) hash ^= SpeakerName.GetHashCode();
      hash ^= mentions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasSpeakerName) {
        output.WriteRawTag(10);
        output.WriteString(SpeakerName);
      }
      mentions_.WriteTo(output, _repeated_mentions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasSpeakerName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SpeakerName);
      }
      size += mentions_.CalculateSize(_repeated_mentions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SpeakerInfo other) {
      if (other == null) {
        return;
      }
      if (other.HasSpeakerName) {
        SpeakerName = other.SpeakerName;
      }
      mentions_.Add(other.mentions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SpeakerName = input.ReadString();
            break;
          }
          case 18:
          case 16: {
            mentions_.AddEntriesFrom(input, _repeated_mentions_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A Span of text
  /// </summary>
  public sealed partial class Span : pb::IMessage<Span> {
    private static readonly pb::MessageParser<Span> _parser = new pb::MessageParser<Span>(() => new Span());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Span> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span(Span other) : this() {
      _hasBits0 = other._hasBits0;
      begin_ = other.begin_;
      end_ = other.end_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span Clone() {
      return new Span(this);
    }

    /// <summary>Field number for the "begin" field.</summary>
    public const int BeginFieldNumber = 1;
    private readonly static uint BeginDefaultValue = 0;

    private uint begin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Begin {
      get { if ((_hasBits0 & 1) != 0) { return begin_; } else { return BeginDefaultValue; } }
      set {
        _hasBits0 |= 1;
        begin_ = value;
      }
    }
    /// <summary>Gets whether the "begin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBegin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "begin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBegin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "end" field.</summary>
    public const int EndFieldNumber = 2;
    private readonly static uint EndDefaultValue = 0;

    private uint end_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint End {
      get { if ((_hasBits0 & 2) != 0) { return end_; } else { return EndDefaultValue; } }
      set {
        _hasBits0 |= 2;
        end_ = value;
      }
    }
    /// <summary>Gets whether the "end" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEnd {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "end" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEnd() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Span);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Span other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Begin != other.Begin) return false;
      if (End != other.End) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasBegin) hash ^= Begin.GetHashCode();
      if (HasEnd) hash ^= End.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasBegin) {
        output.WriteRawTag(8);
        output.WriteUInt32(Begin);
      }
      if (HasEnd) {
        output.WriteRawTag(16);
        output.WriteUInt32(End);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Begin);
      }
      if (HasEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(End);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Span other) {
      if (other == null) {
        return;
      }
      if (other.HasBegin) {
        Begin = other.Begin;
      }
      if (other.HasEnd) {
        End = other.End;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Begin = input.ReadUInt32();
            break;
          }
          case 16: {
            End = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A Timex object, representing a temporal expression (TIMe EXpression)
  /// These fields are not *really* optional. CoreNLP will crash without them.
  /// </summary>
  public sealed partial class Timex : pb::IMessage<Timex> {
    private static readonly pb::MessageParser<Timex> _parser = new pb::MessageParser<Timex>(() => new Timex());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Timex> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Timex() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Timex(Timex other) : this() {
      _hasBits0 = other._hasBits0;
      value_ = other.value_;
      altValue_ = other.altValue_;
      text_ = other.text_;
      type_ = other.type_;
      tid_ = other.tid_;
      beginPoint_ = other.beginPoint_;
      endPoint_ = other.endPoint_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Timex Clone() {
      return new Timex(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      value_ = null;
    }

    /// <summary>Field number for the "altValue" field.</summary>
    public const int AltValueFieldNumber = 2;
    private readonly static string AltValueDefaultValue = "";

    private string altValue_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AltValue {
      get { return altValue_ ?? AltValueDefaultValue; }
      set {
        altValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "altValue" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAltValue {
      get { return altValue_ != null; }
    }
    /// <summary>Clears the value of the "altValue" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAltValue() {
      altValue_ = null;
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 3;
    private readonly static string TextDefaultValue = "";

    private string text_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Text {
      get { return text_ ?? TextDefaultValue; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "text" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasText {
      get { return text_ != null; }
    }
    /// <summary>Clears the value of the "text" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearText() {
      text_ = null;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 4;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "tid" field.</summary>
    public const int TidFieldNumber = 5;
    private readonly static string TidDefaultValue = "";

    private string tid_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Tid {
      get { return tid_ ?? TidDefaultValue; }
      set {
        tid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "tid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTid {
      get { return tid_ != null; }
    }
    /// <summary>Clears the value of the "tid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTid() {
      tid_ = null;
    }

    /// <summary>Field number for the "beginPoint" field.</summary>
    public const int BeginPointFieldNumber = 6;
    private readonly static uint BeginPointDefaultValue = 0;

    private uint beginPoint_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BeginPoint {
      get { if ((_hasBits0 & 1) != 0) { return beginPoint_; } else { return BeginPointDefaultValue; } }
      set {
        _hasBits0 |= 1;
        beginPoint_ = value;
      }
    }
    /// <summary>Gets whether the "beginPoint" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBeginPoint {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "beginPoint" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBeginPoint() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "endPoint" field.</summary>
    public const int EndPointFieldNumber = 7;
    private readonly static uint EndPointDefaultValue = 0;

    private uint endPoint_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EndPoint {
      get { if ((_hasBits0 & 2) != 0) { return endPoint_; } else { return EndPointDefaultValue; } }
      set {
        _hasBits0 |= 2;
        endPoint_ = value;
      }
    }
    /// <summary>Gets whether the "endPoint" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEndPoint {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "endPoint" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEndPoint() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Timex);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Timex other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Value != other.Value) return false;
      if (AltValue != other.AltValue) return false;
      if (Text != other.Text) return false;
      if (Type != other.Type) return false;
      if (Tid != other.Tid) return false;
      if (BeginPoint != other.BeginPoint) return false;
      if (EndPoint != other.EndPoint) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasValue) hash ^= Value.GetHashCode();
      if (HasAltValue) hash ^= AltValue.GetHashCode();
      if (HasText) hash ^= Text.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasTid) hash ^= Tid.GetHashCode();
      if (HasBeginPoint) hash ^= BeginPoint.GetHashCode();
      if (HasEndPoint) hash ^= EndPoint.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasValue) {
        output.WriteRawTag(10);
        output.WriteString(Value);
      }
      if (HasAltValue) {
        output.WriteRawTag(18);
        output.WriteString(AltValue);
      }
      if (HasText) {
        output.WriteRawTag(26);
        output.WriteString(Text);
      }
      if (HasType) {
        output.WriteRawTag(34);
        output.WriteString(Type);
      }
      if (HasTid) {
        output.WriteRawTag(42);
        output.WriteString(Tid);
      }
      if (HasBeginPoint) {
        output.WriteRawTag(48);
        output.WriteUInt32(BeginPoint);
      }
      if (HasEndPoint) {
        output.WriteRawTag(56);
        output.WriteUInt32(EndPoint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (HasAltValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AltValue);
      }
      if (HasText) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasTid) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Tid);
      }
      if (HasBeginPoint) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BeginPoint);
      }
      if (HasEndPoint) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EndPoint);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Timex other) {
      if (other == null) {
        return;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasAltValue) {
        AltValue = other.AltValue;
      }
      if (other.HasText) {
        Text = other.Text;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasTid) {
        Tid = other.Tid;
      }
      if (other.HasBeginPoint) {
        BeginPoint = other.BeginPoint;
      }
      if (other.HasEndPoint) {
        EndPoint = other.EndPoint;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Value = input.ReadString();
            break;
          }
          case 18: {
            AltValue = input.ReadString();
            break;
          }
          case 26: {
            Text = input.ReadString();
            break;
          }
          case 34: {
            Type = input.ReadString();
            break;
          }
          case 42: {
            Tid = input.ReadString();
            break;
          }
          case 48: {
            BeginPoint = input.ReadUInt32();
            break;
          }
          case 56: {
            EndPoint = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A representation of an entity in a relation.
  /// This corresponds to the EntityMention, and more broadly the
  /// ExtractionObject classes.
  /// </summary>
  public sealed partial class Entity : pb::IMessage<Entity> {
    private static readonly pb::MessageParser<Entity> _parser = new pb::MessageParser<Entity>(() => new Entity());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Entity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Entity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Entity(Entity other) : this() {
      _hasBits0 = other._hasBits0;
      headStart_ = other.headStart_;
      headEnd_ = other.headEnd_;
      mentionType_ = other.mentionType_;
      normalizedName_ = other.normalizedName_;
      headTokenIndex_ = other.headTokenIndex_;
      corefID_ = other.corefID_;
      objectID_ = other.objectID_;
      extentStart_ = other.extentStart_;
      extentEnd_ = other.extentEnd_;
      type_ = other.type_;
      subtype_ = other.subtype_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Entity Clone() {
      return new Entity(this);
    }

    /// <summary>Field number for the "headStart" field.</summary>
    public const int HeadStartFieldNumber = 6;
    private readonly static uint HeadStartDefaultValue = 0;

    private uint headStart_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint HeadStart {
      get { if ((_hasBits0 & 4) != 0) { return headStart_; } else { return HeadStartDefaultValue; } }
      set {
        _hasBits0 |= 4;
        headStart_ = value;
      }
    }
    /// <summary>Gets whether the "headStart" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadStart {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "headStart" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadStart() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "headEnd" field.</summary>
    public const int HeadEndFieldNumber = 7;
    private readonly static uint HeadEndDefaultValue = 0;

    private uint headEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint HeadEnd {
      get { if ((_hasBits0 & 8) != 0) { return headEnd_; } else { return HeadEndDefaultValue; } }
      set {
        _hasBits0 |= 8;
        headEnd_ = value;
      }
    }
    /// <summary>Gets whether the "headEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadEnd {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "headEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadEnd() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "mentionType" field.</summary>
    public const int MentionTypeFieldNumber = 8;
    private readonly static string MentionTypeDefaultValue = "";

    private string mentionType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MentionType {
      get { return mentionType_ ?? MentionTypeDefaultValue; }
      set {
        mentionType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mentionType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMentionType {
      get { return mentionType_ != null; }
    }
    /// <summary>Clears the value of the "mentionType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMentionType() {
      mentionType_ = null;
    }

    /// <summary>Field number for the "normalizedName" field.</summary>
    public const int NormalizedNameFieldNumber = 9;
    private readonly static string NormalizedNameDefaultValue = "";

    private string normalizedName_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NormalizedName {
      get { return normalizedName_ ?? NormalizedNameDefaultValue; }
      set {
        normalizedName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "normalizedName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNormalizedName {
      get { return normalizedName_ != null; }
    }
    /// <summary>Clears the value of the "normalizedName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNormalizedName() {
      normalizedName_ = null;
    }

    /// <summary>Field number for the "headTokenIndex" field.</summary>
    public const int HeadTokenIndexFieldNumber = 10;
    private readonly static uint HeadTokenIndexDefaultValue = 0;

    private uint headTokenIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint HeadTokenIndex {
      get { if ((_hasBits0 & 16) != 0) { return headTokenIndex_; } else { return HeadTokenIndexDefaultValue; } }
      set {
        _hasBits0 |= 16;
        headTokenIndex_ = value;
      }
    }
    /// <summary>Gets whether the "headTokenIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHeadTokenIndex {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "headTokenIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeadTokenIndex() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "corefID" field.</summary>
    public const int CorefIDFieldNumber = 11;
    private readonly static string CorefIDDefaultValue = "";

    private string corefID_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CorefID {
      get { return corefID_ ?? CorefIDDefaultValue; }
      set {
        corefID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "corefID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCorefID {
      get { return corefID_ != null; }
    }
    /// <summary>Clears the value of the "corefID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCorefID() {
      corefID_ = null;
    }

    /// <summary>Field number for the "objectID" field.</summary>
    public const int ObjectIDFieldNumber = 1;
    private readonly static string ObjectIDDefaultValue = "";

    private string objectID_;
    /// <summary>
    /// inherited from ExtractionObject
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ObjectID {
      get { return objectID_ ?? ObjectIDDefaultValue; }
      set {
        objectID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "objectID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasObjectID {
      get { return objectID_ != null; }
    }
    /// <summary>Clears the value of the "objectID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearObjectID() {
      objectID_ = null;
    }

    /// <summary>Field number for the "extentStart" field.</summary>
    public const int ExtentStartFieldNumber = 2;
    private readonly static uint ExtentStartDefaultValue = 0;

    private uint extentStart_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ExtentStart {
      get { if ((_hasBits0 & 1) != 0) { return extentStart_; } else { return ExtentStartDefaultValue; } }
      set {
        _hasBits0 |= 1;
        extentStart_ = value;
      }
    }
    /// <summary>Gets whether the "extentStart" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExtentStart {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "extentStart" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExtentStart() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "extentEnd" field.</summary>
    public const int ExtentEndFieldNumber = 3;
    private readonly static uint ExtentEndDefaultValue = 0;

    private uint extentEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ExtentEnd {
      get { if ((_hasBits0 & 2) != 0) { return extentEnd_; } else { return ExtentEndDefaultValue; } }
      set {
        _hasBits0 |= 2;
        extentEnd_ = value;
      }
    }
    /// <summary>Gets whether the "extentEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExtentEnd {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "extentEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExtentEnd() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 4;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "subtype" field.</summary>
    public const int SubtypeFieldNumber = 5;
    private readonly static string SubtypeDefaultValue = "";

    private string subtype_;
    /// <summary>
    /// Implicit
    ///       uint32 sentence       @see implicit in sentence
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Subtype {
      get { return subtype_ ?? SubtypeDefaultValue; }
      set {
        subtype_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "subtype" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubtype {
      get { return subtype_ != null; }
    }
    /// <summary>Clears the value of the "subtype" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubtype() {
      subtype_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Entity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Entity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HeadStart != other.HeadStart) return false;
      if (HeadEnd != other.HeadEnd) return false;
      if (MentionType != other.MentionType) return false;
      if (NormalizedName != other.NormalizedName) return false;
      if (HeadTokenIndex != other.HeadTokenIndex) return false;
      if (CorefID != other.CorefID) return false;
      if (ObjectID != other.ObjectID) return false;
      if (ExtentStart != other.ExtentStart) return false;
      if (ExtentEnd != other.ExtentEnd) return false;
      if (Type != other.Type) return false;
      if (Subtype != other.Subtype) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasHeadStart) hash ^= HeadStart.GetHashCode();
      if (HasHeadEnd) hash ^= HeadEnd.GetHashCode();
      if (HasMentionType) hash ^= MentionType.GetHashCode();
      if (HasNormalizedName) hash ^= NormalizedName.GetHashCode();
      if (HasHeadTokenIndex) hash ^= HeadTokenIndex.GetHashCode();
      if (HasCorefID) hash ^= CorefID.GetHashCode();
      if (HasObjectID) hash ^= ObjectID.GetHashCode();
      if (HasExtentStart) hash ^= ExtentStart.GetHashCode();
      if (HasExtentEnd) hash ^= ExtentEnd.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasSubtype) hash ^= Subtype.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasObjectID) {
        output.WriteRawTag(10);
        output.WriteString(ObjectID);
      }
      if (HasExtentStart) {
        output.WriteRawTag(16);
        output.WriteUInt32(ExtentStart);
      }
      if (HasExtentEnd) {
        output.WriteRawTag(24);
        output.WriteUInt32(ExtentEnd);
      }
      if (HasType) {
        output.WriteRawTag(34);
        output.WriteString(Type);
      }
      if (HasSubtype) {
        output.WriteRawTag(42);
        output.WriteString(Subtype);
      }
      if (HasHeadStart) {
        output.WriteRawTag(48);
        output.WriteUInt32(HeadStart);
      }
      if (HasHeadEnd) {
        output.WriteRawTag(56);
        output.WriteUInt32(HeadEnd);
      }
      if (HasMentionType) {
        output.WriteRawTag(66);
        output.WriteString(MentionType);
      }
      if (HasNormalizedName) {
        output.WriteRawTag(74);
        output.WriteString(NormalizedName);
      }
      if (HasHeadTokenIndex) {
        output.WriteRawTag(80);
        output.WriteUInt32(HeadTokenIndex);
      }
      if (HasCorefID) {
        output.WriteRawTag(90);
        output.WriteString(CorefID);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasHeadStart) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HeadStart);
      }
      if (HasHeadEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HeadEnd);
      }
      if (HasMentionType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MentionType);
      }
      if (HasNormalizedName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NormalizedName);
      }
      if (HasHeadTokenIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(HeadTokenIndex);
      }
      if (HasCorefID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CorefID);
      }
      if (HasObjectID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ObjectID);
      }
      if (HasExtentStart) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExtentStart);
      }
      if (HasExtentEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExtentEnd);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasSubtype) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Subtype);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Entity other) {
      if (other == null) {
        return;
      }
      if (other.HasHeadStart) {
        HeadStart = other.HeadStart;
      }
      if (other.HasHeadEnd) {
        HeadEnd = other.HeadEnd;
      }
      if (other.HasMentionType) {
        MentionType = other.MentionType;
      }
      if (other.HasNormalizedName) {
        NormalizedName = other.NormalizedName;
      }
      if (other.HasHeadTokenIndex) {
        HeadTokenIndex = other.HeadTokenIndex;
      }
      if (other.HasCorefID) {
        CorefID = other.CorefID;
      }
      if (other.HasObjectID) {
        ObjectID = other.ObjectID;
      }
      if (other.HasExtentStart) {
        ExtentStart = other.ExtentStart;
      }
      if (other.HasExtentEnd) {
        ExtentEnd = other.ExtentEnd;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasSubtype) {
        Subtype = other.Subtype;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ObjectID = input.ReadString();
            break;
          }
          case 16: {
            ExtentStart = input.ReadUInt32();
            break;
          }
          case 24: {
            ExtentEnd = input.ReadUInt32();
            break;
          }
          case 34: {
            Type = input.ReadString();
            break;
          }
          case 42: {
            Subtype = input.ReadString();
            break;
          }
          case 48: {
            HeadStart = input.ReadUInt32();
            break;
          }
          case 56: {
            HeadEnd = input.ReadUInt32();
            break;
          }
          case 66: {
            MentionType = input.ReadString();
            break;
          }
          case 74: {
            NormalizedName = input.ReadString();
            break;
          }
          case 80: {
            HeadTokenIndex = input.ReadUInt32();
            break;
          }
          case 90: {
            CorefID = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A representation of a relation, mirroring RelationMention
  /// </summary>
  public sealed partial class Relation : pb::IMessage<Relation> {
    private static readonly pb::MessageParser<Relation> _parser = new pb::MessageParser<Relation>(() => new Relation());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Relation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Relation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Relation(Relation other) : this() {
      _hasBits0 = other._hasBits0;
      argName_ = other.argName_.Clone();
      arg_ = other.arg_.Clone();
      signature_ = other.signature_;
      objectID_ = other.objectID_;
      extentStart_ = other.extentStart_;
      extentEnd_ = other.extentEnd_;
      type_ = other.type_;
      subtype_ = other.subtype_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Relation Clone() {
      return new Relation(this);
    }

    /// <summary>Field number for the "argName" field.</summary>
    public const int ArgNameFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_argName_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> argName_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ArgName {
      get { return argName_; }
    }

    /// <summary>Field number for the "arg" field.</summary>
    public const int ArgFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Entity> _repeated_arg_codec
        = pb::FieldCodec.ForMessage(58, global::Edu.Stanford.Nlp.Pipeline.Entity.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Entity> arg_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Entity>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Entity> Arg {
      get { return arg_; }
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 8;
    private readonly static string SignatureDefaultValue = "";

    private string signature_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Signature {
      get { return signature_ ?? SignatureDefaultValue; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "signature" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSignature {
      get { return signature_ != null; }
    }
    /// <summary>Clears the value of the "signature" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSignature() {
      signature_ = null;
    }

    /// <summary>Field number for the "objectID" field.</summary>
    public const int ObjectIDFieldNumber = 1;
    private readonly static string ObjectIDDefaultValue = "";

    private string objectID_;
    /// <summary>
    /// inherited from ExtractionObject
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ObjectID {
      get { return objectID_ ?? ObjectIDDefaultValue; }
      set {
        objectID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "objectID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasObjectID {
      get { return objectID_ != null; }
    }
    /// <summary>Clears the value of the "objectID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearObjectID() {
      objectID_ = null;
    }

    /// <summary>Field number for the "extentStart" field.</summary>
    public const int ExtentStartFieldNumber = 2;
    private readonly static uint ExtentStartDefaultValue = 0;

    private uint extentStart_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ExtentStart {
      get { if ((_hasBits0 & 1) != 0) { return extentStart_; } else { return ExtentStartDefaultValue; } }
      set {
        _hasBits0 |= 1;
        extentStart_ = value;
      }
    }
    /// <summary>Gets whether the "extentStart" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExtentStart {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "extentStart" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExtentStart() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "extentEnd" field.</summary>
    public const int ExtentEndFieldNumber = 3;
    private readonly static uint ExtentEndDefaultValue = 0;

    private uint extentEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ExtentEnd {
      get { if ((_hasBits0 & 2) != 0) { return extentEnd_; } else { return ExtentEndDefaultValue; } }
      set {
        _hasBits0 |= 2;
        extentEnd_ = value;
      }
    }
    /// <summary>Gets whether the "extentEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasExtentEnd {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "extentEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExtentEnd() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 4;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "subtype" field.</summary>
    public const int SubtypeFieldNumber = 5;
    private readonly static string SubtypeDefaultValue = "";

    private string subtype_;
    /// <summary>
    /// Implicit
    ///       uint32 sentence       @see implicit in sentence
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Subtype {
      get { return subtype_ ?? SubtypeDefaultValue; }
      set {
        subtype_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "subtype" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubtype {
      get { return subtype_ != null; }
    }
    /// <summary>Clears the value of the "subtype" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubtype() {
      subtype_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Relation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Relation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!argName_.Equals(other.argName_)) return false;
      if(!arg_.Equals(other.arg_)) return false;
      if (Signature != other.Signature) return false;
      if (ObjectID != other.ObjectID) return false;
      if (ExtentStart != other.ExtentStart) return false;
      if (ExtentEnd != other.ExtentEnd) return false;
      if (Type != other.Type) return false;
      if (Subtype != other.Subtype) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= argName_.GetHashCode();
      hash ^= arg_.GetHashCode();
      if (HasSignature) hash ^= Signature.GetHashCode();
      if (HasObjectID) hash ^= ObjectID.GetHashCode();
      if (HasExtentStart) hash ^= ExtentStart.GetHashCode();
      if (HasExtentEnd) hash ^= ExtentEnd.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasSubtype) hash ^= Subtype.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasObjectID) {
        output.WriteRawTag(10);
        output.WriteString(ObjectID);
      }
      if (HasExtentStart) {
        output.WriteRawTag(16);
        output.WriteUInt32(ExtentStart);
      }
      if (HasExtentEnd) {
        output.WriteRawTag(24);
        output.WriteUInt32(ExtentEnd);
      }
      if (HasType) {
        output.WriteRawTag(34);
        output.WriteString(Type);
      }
      if (HasSubtype) {
        output.WriteRawTag(42);
        output.WriteString(Subtype);
      }
      argName_.WriteTo(output, _repeated_argName_codec);
      arg_.WriteTo(output, _repeated_arg_codec);
      if (HasSignature) {
        output.WriteRawTag(66);
        output.WriteString(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += argName_.CalculateSize(_repeated_argName_codec);
      size += arg_.CalculateSize(_repeated_arg_codec);
      if (HasSignature) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Signature);
      }
      if (HasObjectID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ObjectID);
      }
      if (HasExtentStart) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExtentStart);
      }
      if (HasExtentEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExtentEnd);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasSubtype) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Subtype);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Relation other) {
      if (other == null) {
        return;
      }
      argName_.Add(other.argName_);
      arg_.Add(other.arg_);
      if (other.HasSignature) {
        Signature = other.Signature;
      }
      if (other.HasObjectID) {
        ObjectID = other.ObjectID;
      }
      if (other.HasExtentStart) {
        ExtentStart = other.ExtentStart;
      }
      if (other.HasExtentEnd) {
        ExtentEnd = other.ExtentEnd;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasSubtype) {
        Subtype = other.Subtype;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ObjectID = input.ReadString();
            break;
          }
          case 16: {
            ExtentStart = input.ReadUInt32();
            break;
          }
          case 24: {
            ExtentEnd = input.ReadUInt32();
            break;
          }
          case 34: {
            Type = input.ReadString();
            break;
          }
          case 42: {
            Subtype = input.ReadString();
            break;
          }
          case 50: {
            argName_.AddEntriesFrom(input, _repeated_argName_codec);
            break;
          }
          case 58: {
            arg_.AddEntriesFrom(input, _repeated_arg_codec);
            break;
          }
          case 66: {
            Signature = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A Natural Logic operator
  /// </summary>
  public sealed partial class Operator : pb::IMessage<Operator> {
    private static readonly pb::MessageParser<Operator> _parser = new pb::MessageParser<Operator>(() => new Operator());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Operator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Operator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Operator(Operator other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      quantifierSpanBegin_ = other.quantifierSpanBegin_;
      quantifierSpanEnd_ = other.quantifierSpanEnd_;
      subjectSpanBegin_ = other.subjectSpanBegin_;
      subjectSpanEnd_ = other.subjectSpanEnd_;
      objectSpanBegin_ = other.objectSpanBegin_;
      objectSpanEnd_ = other.objectSpanEnd_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Operator Clone() {
      return new Operator(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "quantifierSpanBegin" field.</summary>
    public const int QuantifierSpanBeginFieldNumber = 2;
    private readonly static int QuantifierSpanBeginDefaultValue = 0;

    private int quantifierSpanBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int QuantifierSpanBegin {
      get { if ((_hasBits0 & 1) != 0) { return quantifierSpanBegin_; } else { return QuantifierSpanBeginDefaultValue; } }
      set {
        _hasBits0 |= 1;
        quantifierSpanBegin_ = value;
      }
    }
    /// <summary>Gets whether the "quantifierSpanBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasQuantifierSpanBegin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "quantifierSpanBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearQuantifierSpanBegin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "quantifierSpanEnd" field.</summary>
    public const int QuantifierSpanEndFieldNumber = 3;
    private readonly static int QuantifierSpanEndDefaultValue = 0;

    private int quantifierSpanEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int QuantifierSpanEnd {
      get { if ((_hasBits0 & 2) != 0) { return quantifierSpanEnd_; } else { return QuantifierSpanEndDefaultValue; } }
      set {
        _hasBits0 |= 2;
        quantifierSpanEnd_ = value;
      }
    }
    /// <summary>Gets whether the "quantifierSpanEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasQuantifierSpanEnd {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "quantifierSpanEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearQuantifierSpanEnd() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "subjectSpanBegin" field.</summary>
    public const int SubjectSpanBeginFieldNumber = 4;
    private readonly static int SubjectSpanBeginDefaultValue = 0;

    private int subjectSpanBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SubjectSpanBegin {
      get { if ((_hasBits0 & 4) != 0) { return subjectSpanBegin_; } else { return SubjectSpanBeginDefaultValue; } }
      set {
        _hasBits0 |= 4;
        subjectSpanBegin_ = value;
      }
    }
    /// <summary>Gets whether the "subjectSpanBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubjectSpanBegin {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "subjectSpanBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubjectSpanBegin() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "subjectSpanEnd" field.</summary>
    public const int SubjectSpanEndFieldNumber = 5;
    private readonly static int SubjectSpanEndDefaultValue = 0;

    private int subjectSpanEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int SubjectSpanEnd {
      get { if ((_hasBits0 & 8) != 0) { return subjectSpanEnd_; } else { return SubjectSpanEndDefaultValue; } }
      set {
        _hasBits0 |= 8;
        subjectSpanEnd_ = value;
      }
    }
    /// <summary>Gets whether the "subjectSpanEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubjectSpanEnd {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "subjectSpanEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubjectSpanEnd() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "objectSpanBegin" field.</summary>
    public const int ObjectSpanBeginFieldNumber = 6;
    private readonly static int ObjectSpanBeginDefaultValue = 0;

    private int objectSpanBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ObjectSpanBegin {
      get { if ((_hasBits0 & 16) != 0) { return objectSpanBegin_; } else { return ObjectSpanBeginDefaultValue; } }
      set {
        _hasBits0 |= 16;
        objectSpanBegin_ = value;
      }
    }
    /// <summary>Gets whether the "objectSpanBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasObjectSpanBegin {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "objectSpanBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearObjectSpanBegin() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "objectSpanEnd" field.</summary>
    public const int ObjectSpanEndFieldNumber = 7;
    private readonly static int ObjectSpanEndDefaultValue = 0;

    private int objectSpanEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ObjectSpanEnd {
      get { if ((_hasBits0 & 32) != 0) { return objectSpanEnd_; } else { return ObjectSpanEndDefaultValue; } }
      set {
        _hasBits0 |= 32;
        objectSpanEnd_ = value;
      }
    }
    /// <summary>Gets whether the "objectSpanEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasObjectSpanEnd {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "objectSpanEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearObjectSpanEnd() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Operator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Operator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (QuantifierSpanBegin != other.QuantifierSpanBegin) return false;
      if (QuantifierSpanEnd != other.QuantifierSpanEnd) return false;
      if (SubjectSpanBegin != other.SubjectSpanBegin) return false;
      if (SubjectSpanEnd != other.SubjectSpanEnd) return false;
      if (ObjectSpanBegin != other.ObjectSpanBegin) return false;
      if (ObjectSpanEnd != other.ObjectSpanEnd) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasQuantifierSpanBegin) hash ^= QuantifierSpanBegin.GetHashCode();
      if (HasQuantifierSpanEnd) hash ^= QuantifierSpanEnd.GetHashCode();
      if (HasSubjectSpanBegin) hash ^= SubjectSpanBegin.GetHashCode();
      if (HasSubjectSpanEnd) hash ^= SubjectSpanEnd.GetHashCode();
      if (HasObjectSpanBegin) hash ^= ObjectSpanBegin.GetHashCode();
      if (HasObjectSpanEnd) hash ^= ObjectSpanEnd.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasQuantifierSpanBegin) {
        output.WriteRawTag(16);
        output.WriteInt32(QuantifierSpanBegin);
      }
      if (HasQuantifierSpanEnd) {
        output.WriteRawTag(24);
        output.WriteInt32(QuantifierSpanEnd);
      }
      if (HasSubjectSpanBegin) {
        output.WriteRawTag(32);
        output.WriteInt32(SubjectSpanBegin);
      }
      if (HasSubjectSpanEnd) {
        output.WriteRawTag(40);
        output.WriteInt32(SubjectSpanEnd);
      }
      if (HasObjectSpanBegin) {
        output.WriteRawTag(48);
        output.WriteInt32(ObjectSpanBegin);
      }
      if (HasObjectSpanEnd) {
        output.WriteRawTag(56);
        output.WriteInt32(ObjectSpanEnd);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasQuantifierSpanBegin) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(QuantifierSpanBegin);
      }
      if (HasQuantifierSpanEnd) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(QuantifierSpanEnd);
      }
      if (HasSubjectSpanBegin) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SubjectSpanBegin);
      }
      if (HasSubjectSpanEnd) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SubjectSpanEnd);
      }
      if (HasObjectSpanBegin) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ObjectSpanBegin);
      }
      if (HasObjectSpanEnd) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ObjectSpanEnd);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Operator other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasQuantifierSpanBegin) {
        QuantifierSpanBegin = other.QuantifierSpanBegin;
      }
      if (other.HasQuantifierSpanEnd) {
        QuantifierSpanEnd = other.QuantifierSpanEnd;
      }
      if (other.HasSubjectSpanBegin) {
        SubjectSpanBegin = other.SubjectSpanBegin;
      }
      if (other.HasSubjectSpanEnd) {
        SubjectSpanEnd = other.SubjectSpanEnd;
      }
      if (other.HasObjectSpanBegin) {
        ObjectSpanBegin = other.ObjectSpanBegin;
      }
      if (other.HasObjectSpanEnd) {
        ObjectSpanEnd = other.ObjectSpanEnd;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            QuantifierSpanBegin = input.ReadInt32();
            break;
          }
          case 24: {
            QuantifierSpanEnd = input.ReadInt32();
            break;
          }
          case 32: {
            SubjectSpanBegin = input.ReadInt32();
            break;
          }
          case 40: {
            SubjectSpanEnd = input.ReadInt32();
            break;
          }
          case 48: {
            ObjectSpanBegin = input.ReadInt32();
            break;
          }
          case 56: {
            ObjectSpanEnd = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// The polarity of a word, according to Natural Logic
  /// </summary>
  public sealed partial class Polarity : pb::IMessage<Polarity> {
    private static readonly pb::MessageParser<Polarity> _parser = new pb::MessageParser<Polarity>(() => new Polarity());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Polarity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Polarity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Polarity(Polarity other) : this() {
      _hasBits0 = other._hasBits0;
      projectEquivalence_ = other.projectEquivalence_;
      projectForwardEntailment_ = other.projectForwardEntailment_;
      projectReverseEntailment_ = other.projectReverseEntailment_;
      projectNegation_ = other.projectNegation_;
      projectAlternation_ = other.projectAlternation_;
      projectCover_ = other.projectCover_;
      projectIndependence_ = other.projectIndependence_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Polarity Clone() {
      return new Polarity(this);
    }

    /// <summary>Field number for the "projectEquivalence" field.</summary>
    public const int ProjectEquivalenceFieldNumber = 1;
    private readonly static global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectEquivalenceDefaultValue = global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation.Equivalence;

    private global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation projectEquivalence_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectEquivalence {
      get { if ((_hasBits0 & 1) != 0) { return projectEquivalence_; } else { return ProjectEquivalenceDefaultValue; } }
      set {
        _hasBits0 |= 1;
        projectEquivalence_ = value;
      }
    }
    /// <summary>Gets whether the "projectEquivalence" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasProjectEquivalence {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "projectEquivalence" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearProjectEquivalence() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "projectForwardEntailment" field.</summary>
    public const int ProjectForwardEntailmentFieldNumber = 2;
    private readonly static global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectForwardEntailmentDefaultValue = global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation.Equivalence;

    private global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation projectForwardEntailment_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectForwardEntailment {
      get { if ((_hasBits0 & 2) != 0) { return projectForwardEntailment_; } else { return ProjectForwardEntailmentDefaultValue; } }
      set {
        _hasBits0 |= 2;
        projectForwardEntailment_ = value;
      }
    }
    /// <summary>Gets whether the "projectForwardEntailment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasProjectForwardEntailment {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "projectForwardEntailment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearProjectForwardEntailment() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "projectReverseEntailment" field.</summary>
    public const int ProjectReverseEntailmentFieldNumber = 3;
    private readonly static global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectReverseEntailmentDefaultValue = global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation.Equivalence;

    private global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation projectReverseEntailment_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectReverseEntailment {
      get { if ((_hasBits0 & 4) != 0) { return projectReverseEntailment_; } else { return ProjectReverseEntailmentDefaultValue; } }
      set {
        _hasBits0 |= 4;
        projectReverseEntailment_ = value;
      }
    }
    /// <summary>Gets whether the "projectReverseEntailment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasProjectReverseEntailment {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "projectReverseEntailment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearProjectReverseEntailment() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "projectNegation" field.</summary>
    public const int ProjectNegationFieldNumber = 4;
    private readonly static global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectNegationDefaultValue = global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation.Equivalence;

    private global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation projectNegation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectNegation {
      get { if ((_hasBits0 & 8) != 0) { return projectNegation_; } else { return ProjectNegationDefaultValue; } }
      set {
        _hasBits0 |= 8;
        projectNegation_ = value;
      }
    }
    /// <summary>Gets whether the "projectNegation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasProjectNegation {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "projectNegation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearProjectNegation() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "projectAlternation" field.</summary>
    public const int ProjectAlternationFieldNumber = 5;
    private readonly static global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectAlternationDefaultValue = global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation.Equivalence;

    private global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation projectAlternation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectAlternation {
      get { if ((_hasBits0 & 16) != 0) { return projectAlternation_; } else { return ProjectAlternationDefaultValue; } }
      set {
        _hasBits0 |= 16;
        projectAlternation_ = value;
      }
    }
    /// <summary>Gets whether the "projectAlternation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasProjectAlternation {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "projectAlternation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearProjectAlternation() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "projectCover" field.</summary>
    public const int ProjectCoverFieldNumber = 6;
    private readonly static global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectCoverDefaultValue = global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation.Equivalence;

    private global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation projectCover_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectCover {
      get { if ((_hasBits0 & 32) != 0) { return projectCover_; } else { return ProjectCoverDefaultValue; } }
      set {
        _hasBits0 |= 32;
        projectCover_ = value;
      }
    }
    /// <summary>Gets whether the "projectCover" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasProjectCover {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "projectCover" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearProjectCover() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "projectIndependence" field.</summary>
    public const int ProjectIndependenceFieldNumber = 7;
    private readonly static global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectIndependenceDefaultValue = global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation.Equivalence;

    private global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation projectIndependence_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation ProjectIndependence {
      get { if ((_hasBits0 & 64) != 0) { return projectIndependence_; } else { return ProjectIndependenceDefaultValue; } }
      set {
        _hasBits0 |= 64;
        projectIndependence_ = value;
      }
    }
    /// <summary>Gets whether the "projectIndependence" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasProjectIndependence {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "projectIndependence" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearProjectIndependence() {
      _hasBits0 &= ~64;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Polarity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Polarity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ProjectEquivalence != other.ProjectEquivalence) return false;
      if (ProjectForwardEntailment != other.ProjectForwardEntailment) return false;
      if (ProjectReverseEntailment != other.ProjectReverseEntailment) return false;
      if (ProjectNegation != other.ProjectNegation) return false;
      if (ProjectAlternation != other.ProjectAlternation) return false;
      if (ProjectCover != other.ProjectCover) return false;
      if (ProjectIndependence != other.ProjectIndependence) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasProjectEquivalence) hash ^= ProjectEquivalence.GetHashCode();
      if (HasProjectForwardEntailment) hash ^= ProjectForwardEntailment.GetHashCode();
      if (HasProjectReverseEntailment) hash ^= ProjectReverseEntailment.GetHashCode();
      if (HasProjectNegation) hash ^= ProjectNegation.GetHashCode();
      if (HasProjectAlternation) hash ^= ProjectAlternation.GetHashCode();
      if (HasProjectCover) hash ^= ProjectCover.GetHashCode();
      if (HasProjectIndependence) hash ^= ProjectIndependence.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasProjectEquivalence) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ProjectEquivalence);
      }
      if (HasProjectForwardEntailment) {
        output.WriteRawTag(16);
        output.WriteEnum((int) ProjectForwardEntailment);
      }
      if (HasProjectReverseEntailment) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ProjectReverseEntailment);
      }
      if (HasProjectNegation) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ProjectNegation);
      }
      if (HasProjectAlternation) {
        output.WriteRawTag(40);
        output.WriteEnum((int) ProjectAlternation);
      }
      if (HasProjectCover) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ProjectCover);
      }
      if (HasProjectIndependence) {
        output.WriteRawTag(56);
        output.WriteEnum((int) ProjectIndependence);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasProjectEquivalence) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProjectEquivalence);
      }
      if (HasProjectForwardEntailment) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProjectForwardEntailment);
      }
      if (HasProjectReverseEntailment) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProjectReverseEntailment);
      }
      if (HasProjectNegation) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProjectNegation);
      }
      if (HasProjectAlternation) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProjectAlternation);
      }
      if (HasProjectCover) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProjectCover);
      }
      if (HasProjectIndependence) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProjectIndependence);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Polarity other) {
      if (other == null) {
        return;
      }
      if (other.HasProjectEquivalence) {
        ProjectEquivalence = other.ProjectEquivalence;
      }
      if (other.HasProjectForwardEntailment) {
        ProjectForwardEntailment = other.ProjectForwardEntailment;
      }
      if (other.HasProjectReverseEntailment) {
        ProjectReverseEntailment = other.ProjectReverseEntailment;
      }
      if (other.HasProjectNegation) {
        ProjectNegation = other.ProjectNegation;
      }
      if (other.HasProjectAlternation) {
        ProjectAlternation = other.ProjectAlternation;
      }
      if (other.HasProjectCover) {
        ProjectCover = other.ProjectCover;
      }
      if (other.HasProjectIndependence) {
        ProjectIndependence = other.ProjectIndependence;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ProjectEquivalence = (global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation) input.ReadEnum();
            break;
          }
          case 16: {
            ProjectForwardEntailment = (global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation) input.ReadEnum();
            break;
          }
          case 24: {
            ProjectReverseEntailment = (global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation) input.ReadEnum();
            break;
          }
          case 32: {
            ProjectNegation = (global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation) input.ReadEnum();
            break;
          }
          case 40: {
            ProjectAlternation = (global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation) input.ReadEnum();
            break;
          }
          case 48: {
            ProjectCover = (global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation) input.ReadEnum();
            break;
          }
          case 56: {
            ProjectIndependence = (global::Edu.Stanford.Nlp.Pipeline.NaturalLogicRelation) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// An NER mention in the text
  /// </summary>
  public sealed partial class NERMention : pb::IMessage<NERMention> {
    private static readonly pb::MessageParser<NERMention> _parser = new pb::MessageParser<NERMention>(() => new NERMention());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NERMention> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NERMention() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NERMention(NERMention other) : this() {
      _hasBits0 = other._hasBits0;
      sentenceIndex_ = other.sentenceIndex_;
      tokenStartInSentenceInclusive_ = other.tokenStartInSentenceInclusive_;
      tokenEndInSentenceExclusive_ = other.tokenEndInSentenceExclusive_;
      ner_ = other.ner_;
      normalizedNER_ = other.normalizedNER_;
      entityType_ = other.entityType_;
      timex_ = other.timex_ != null ? other.timex_.Clone() : null;
      wikipediaEntity_ = other.wikipediaEntity_;
      gender_ = other.gender_;
      entityMentionIndex_ = other.entityMentionIndex_;
      canonicalEntityMentionIndex_ = other.canonicalEntityMentionIndex_;
      entityMentionText_ = other.entityMentionText_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NERMention Clone() {
      return new NERMention(this);
    }

    /// <summary>Field number for the "sentenceIndex" field.</summary>
    public const int SentenceIndexFieldNumber = 1;
    private readonly static uint SentenceIndexDefaultValue = 0;

    private uint sentenceIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SentenceIndex {
      get { if ((_hasBits0 & 1) != 0) { return sentenceIndex_; } else { return SentenceIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        sentenceIndex_ = value;
      }
    }
    /// <summary>Gets whether the "sentenceIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentenceIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "sentenceIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentenceIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "tokenStartInSentenceInclusive" field.</summary>
    public const int TokenStartInSentenceInclusiveFieldNumber = 2;
    private readonly static uint TokenStartInSentenceInclusiveDefaultValue = 0;

    private uint tokenStartInSentenceInclusive_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenStartInSentenceInclusive {
      get { if ((_hasBits0 & 2) != 0) { return tokenStartInSentenceInclusive_; } else { return TokenStartInSentenceInclusiveDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tokenStartInSentenceInclusive_ = value;
      }
    }
    /// <summary>Gets whether the "tokenStartInSentenceInclusive" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenStartInSentenceInclusive {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tokenStartInSentenceInclusive" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenStartInSentenceInclusive() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "tokenEndInSentenceExclusive" field.</summary>
    public const int TokenEndInSentenceExclusiveFieldNumber = 3;
    private readonly static uint TokenEndInSentenceExclusiveDefaultValue = 0;

    private uint tokenEndInSentenceExclusive_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenEndInSentenceExclusive {
      get { if ((_hasBits0 & 4) != 0) { return tokenEndInSentenceExclusive_; } else { return TokenEndInSentenceExclusiveDefaultValue; } }
      set {
        _hasBits0 |= 4;
        tokenEndInSentenceExclusive_ = value;
      }
    }
    /// <summary>Gets whether the "tokenEndInSentenceExclusive" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenEndInSentenceExclusive {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "tokenEndInSentenceExclusive" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenEndInSentenceExclusive() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "ner" field.</summary>
    public const int NerFieldNumber = 4;
    private readonly static string NerDefaultValue = "";

    private string ner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Ner {
      get { return ner_ ?? NerDefaultValue; }
      set {
        ner_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ner" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNer {
      get { return ner_ != null; }
    }
    /// <summary>Clears the value of the "ner" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNer() {
      ner_ = null;
    }

    /// <summary>Field number for the "normalizedNER" field.</summary>
    public const int NormalizedNERFieldNumber = 5;
    private readonly static string NormalizedNERDefaultValue = "";

    private string normalizedNER_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NormalizedNER {
      get { return normalizedNER_ ?? NormalizedNERDefaultValue; }
      set {
        normalizedNER_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "normalizedNER" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNormalizedNER {
      get { return normalizedNER_ != null; }
    }
    /// <summary>Clears the value of the "normalizedNER" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNormalizedNER() {
      normalizedNER_ = null;
    }

    /// <summary>Field number for the "entityType" field.</summary>
    public const int EntityTypeFieldNumber = 6;
    private readonly static string EntityTypeDefaultValue = "";

    private string entityType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string EntityType {
      get { return entityType_ ?? EntityTypeDefaultValue; }
      set {
        entityType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "entityType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEntityType {
      get { return entityType_ != null; }
    }
    /// <summary>Clears the value of the "entityType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEntityType() {
      entityType_ = null;
    }

    /// <summary>Field number for the "timex" field.</summary>
    public const int TimexFieldNumber = 7;
    private global::Edu.Stanford.Nlp.Pipeline.Timex timex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Timex Timex {
      get { return timex_; }
      set {
        timex_ = value;
      }
    }

    /// <summary>Field number for the "wikipediaEntity" field.</summary>
    public const int WikipediaEntityFieldNumber = 8;
    private readonly static string WikipediaEntityDefaultValue = "";

    private string wikipediaEntity_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string WikipediaEntity {
      get { return wikipediaEntity_ ?? WikipediaEntityDefaultValue; }
      set {
        wikipediaEntity_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "wikipediaEntity" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasWikipediaEntity {
      get { return wikipediaEntity_ != null; }
    }
    /// <summary>Clears the value of the "wikipediaEntity" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearWikipediaEntity() {
      wikipediaEntity_ = null;
    }

    /// <summary>Field number for the "gender" field.</summary>
    public const int GenderFieldNumber = 9;
    private readonly static string GenderDefaultValue = "";

    private string gender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Gender {
      get { return gender_ ?? GenderDefaultValue; }
      set {
        gender_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gender" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasGender {
      get { return gender_ != null; }
    }
    /// <summary>Clears the value of the "gender" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearGender() {
      gender_ = null;
    }

    /// <summary>Field number for the "entityMentionIndex" field.</summary>
    public const int EntityMentionIndexFieldNumber = 10;
    private readonly static uint EntityMentionIndexDefaultValue = 0;

    private uint entityMentionIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EntityMentionIndex {
      get { if ((_hasBits0 & 8) != 0) { return entityMentionIndex_; } else { return EntityMentionIndexDefaultValue; } }
      set {
        _hasBits0 |= 8;
        entityMentionIndex_ = value;
      }
    }
    /// <summary>Gets whether the "entityMentionIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEntityMentionIndex {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "entityMentionIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEntityMentionIndex() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "canonicalEntityMentionIndex" field.</summary>
    public const int CanonicalEntityMentionIndexFieldNumber = 11;
    private readonly static uint CanonicalEntityMentionIndexDefaultValue = 0;

    private uint canonicalEntityMentionIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CanonicalEntityMentionIndex {
      get { if ((_hasBits0 & 16) != 0) { return canonicalEntityMentionIndex_; } else { return CanonicalEntityMentionIndexDefaultValue; } }
      set {
        _hasBits0 |= 16;
        canonicalEntityMentionIndex_ = value;
      }
    }
    /// <summary>Gets whether the "canonicalEntityMentionIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCanonicalEntityMentionIndex {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "canonicalEntityMentionIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCanonicalEntityMentionIndex() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "entityMentionText" field.</summary>
    public const int EntityMentionTextFieldNumber = 12;
    private readonly static string EntityMentionTextDefaultValue = "";

    private string entityMentionText_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string EntityMentionText {
      get { return entityMentionText_ ?? EntityMentionTextDefaultValue; }
      set {
        entityMentionText_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "entityMentionText" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasEntityMentionText {
      get { return entityMentionText_ != null; }
    }
    /// <summary>Clears the value of the "entityMentionText" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEntityMentionText() {
      entityMentionText_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NERMention);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NERMention other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SentenceIndex != other.SentenceIndex) return false;
      if (TokenStartInSentenceInclusive != other.TokenStartInSentenceInclusive) return false;
      if (TokenEndInSentenceExclusive != other.TokenEndInSentenceExclusive) return false;
      if (Ner != other.Ner) return false;
      if (NormalizedNER != other.NormalizedNER) return false;
      if (EntityType != other.EntityType) return false;
      if (!object.Equals(Timex, other.Timex)) return false;
      if (WikipediaEntity != other.WikipediaEntity) return false;
      if (Gender != other.Gender) return false;
      if (EntityMentionIndex != other.EntityMentionIndex) return false;
      if (CanonicalEntityMentionIndex != other.CanonicalEntityMentionIndex) return false;
      if (EntityMentionText != other.EntityMentionText) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSentenceIndex) hash ^= SentenceIndex.GetHashCode();
      if (HasTokenStartInSentenceInclusive) hash ^= TokenStartInSentenceInclusive.GetHashCode();
      if (HasTokenEndInSentenceExclusive) hash ^= TokenEndInSentenceExclusive.GetHashCode();
      if (HasNer) hash ^= Ner.GetHashCode();
      if (HasNormalizedNER) hash ^= NormalizedNER.GetHashCode();
      if (HasEntityType) hash ^= EntityType.GetHashCode();
      if (timex_ != null) hash ^= Timex.GetHashCode();
      if (HasWikipediaEntity) hash ^= WikipediaEntity.GetHashCode();
      if (HasGender) hash ^= Gender.GetHashCode();
      if (HasEntityMentionIndex) hash ^= EntityMentionIndex.GetHashCode();
      if (HasCanonicalEntityMentionIndex) hash ^= CanonicalEntityMentionIndex.GetHashCode();
      if (HasEntityMentionText) hash ^= EntityMentionText.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasSentenceIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(SentenceIndex);
      }
      if (HasTokenStartInSentenceInclusive) {
        output.WriteRawTag(16);
        output.WriteUInt32(TokenStartInSentenceInclusive);
      }
      if (HasTokenEndInSentenceExclusive) {
        output.WriteRawTag(24);
        output.WriteUInt32(TokenEndInSentenceExclusive);
      }
      if (HasNer) {
        output.WriteRawTag(34);
        output.WriteString(Ner);
      }
      if (HasNormalizedNER) {
        output.WriteRawTag(42);
        output.WriteString(NormalizedNER);
      }
      if (HasEntityType) {
        output.WriteRawTag(50);
        output.WriteString(EntityType);
      }
      if (timex_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Timex);
      }
      if (HasWikipediaEntity) {
        output.WriteRawTag(66);
        output.WriteString(WikipediaEntity);
      }
      if (HasGender) {
        output.WriteRawTag(74);
        output.WriteString(Gender);
      }
      if (HasEntityMentionIndex) {
        output.WriteRawTag(80);
        output.WriteUInt32(EntityMentionIndex);
      }
      if (HasCanonicalEntityMentionIndex) {
        output.WriteRawTag(88);
        output.WriteUInt32(CanonicalEntityMentionIndex);
      }
      if (HasEntityMentionText) {
        output.WriteRawTag(98);
        output.WriteString(EntityMentionText);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasSentenceIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SentenceIndex);
      }
      if (HasTokenStartInSentenceInclusive) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TokenStartInSentenceInclusive);
      }
      if (HasTokenEndInSentenceExclusive) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TokenEndInSentenceExclusive);
      }
      if (HasNer) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ner);
      }
      if (HasNormalizedNER) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NormalizedNER);
      }
      if (HasEntityType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EntityType);
      }
      if (timex_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timex);
      }
      if (HasWikipediaEntity) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WikipediaEntity);
      }
      if (HasGender) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Gender);
      }
      if (HasEntityMentionIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EntityMentionIndex);
      }
      if (HasCanonicalEntityMentionIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CanonicalEntityMentionIndex);
      }
      if (HasEntityMentionText) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EntityMentionText);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NERMention other) {
      if (other == null) {
        return;
      }
      if (other.HasSentenceIndex) {
        SentenceIndex = other.SentenceIndex;
      }
      if (other.HasTokenStartInSentenceInclusive) {
        TokenStartInSentenceInclusive = other.TokenStartInSentenceInclusive;
      }
      if (other.HasTokenEndInSentenceExclusive) {
        TokenEndInSentenceExclusive = other.TokenEndInSentenceExclusive;
      }
      if (other.HasNer) {
        Ner = other.Ner;
      }
      if (other.HasNormalizedNER) {
        NormalizedNER = other.NormalizedNER;
      }
      if (other.HasEntityType) {
        EntityType = other.EntityType;
      }
      if (other.timex_ != null) {
        if (timex_ == null) {
          Timex = new global::Edu.Stanford.Nlp.Pipeline.Timex();
        }
        Timex.MergeFrom(other.Timex);
      }
      if (other.HasWikipediaEntity) {
        WikipediaEntity = other.WikipediaEntity;
      }
      if (other.HasGender) {
        Gender = other.Gender;
      }
      if (other.HasEntityMentionIndex) {
        EntityMentionIndex = other.EntityMentionIndex;
      }
      if (other.HasCanonicalEntityMentionIndex) {
        CanonicalEntityMentionIndex = other.CanonicalEntityMentionIndex;
      }
      if (other.HasEntityMentionText) {
        EntityMentionText = other.EntityMentionText;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SentenceIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            TokenStartInSentenceInclusive = input.ReadUInt32();
            break;
          }
          case 24: {
            TokenEndInSentenceExclusive = input.ReadUInt32();
            break;
          }
          case 34: {
            Ner = input.ReadString();
            break;
          }
          case 42: {
            NormalizedNER = input.ReadString();
            break;
          }
          case 50: {
            EntityType = input.ReadString();
            break;
          }
          case 58: {
            if (timex_ == null) {
              Timex = new global::Edu.Stanford.Nlp.Pipeline.Timex();
            }
            input.ReadMessage(Timex);
            break;
          }
          case 66: {
            WikipediaEntity = input.ReadString();
            break;
          }
          case 74: {
            Gender = input.ReadString();
            break;
          }
          case 80: {
            EntityMentionIndex = input.ReadUInt32();
            break;
          }
          case 88: {
            CanonicalEntityMentionIndex = input.ReadUInt32();
            break;
          }
          case 98: {
            EntityMentionText = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// An entailed sentence fragment.
  /// Created by the openie annotator.
  /// </summary>
  public sealed partial class SentenceFragment : pb::IMessage<SentenceFragment> {
    private static readonly pb::MessageParser<SentenceFragment> _parser = new pb::MessageParser<SentenceFragment>(() => new SentenceFragment());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SentenceFragment> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentenceFragment() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentenceFragment(SentenceFragment other) : this() {
      _hasBits0 = other._hasBits0;
      tokenIndex_ = other.tokenIndex_.Clone();
      root_ = other.root_;
      assumedTruth_ = other.assumedTruth_;
      score_ = other.score_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentenceFragment Clone() {
      return new SentenceFragment(this);
    }

    /// <summary>Field number for the "tokenIndex" field.</summary>
    public const int TokenIndexFieldNumber = 1;
    private static readonly pb::FieldCodec<uint> _repeated_tokenIndex_codec
        = pb::FieldCodec.ForUInt32(8);
    private readonly pbc::RepeatedField<uint> tokenIndex_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> TokenIndex {
      get { return tokenIndex_; }
    }

    /// <summary>Field number for the "root" field.</summary>
    public const int RootFieldNumber = 2;
    private readonly static uint RootDefaultValue = 0;

    private uint root_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Root {
      get { if ((_hasBits0 & 1) != 0) { return root_; } else { return RootDefaultValue; } }
      set {
        _hasBits0 |= 1;
        root_ = value;
      }
    }
    /// <summary>Gets whether the "root" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRoot {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "root" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRoot() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "assumedTruth" field.</summary>
    public const int AssumedTruthFieldNumber = 3;
    private readonly static bool AssumedTruthDefaultValue = false;

    private bool assumedTruth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AssumedTruth {
      get { if ((_hasBits0 & 2) != 0) { return assumedTruth_; } else { return AssumedTruthDefaultValue; } }
      set {
        _hasBits0 |= 2;
        assumedTruth_ = value;
      }
    }
    /// <summary>Gets whether the "assumedTruth" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAssumedTruth {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "assumedTruth" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAssumedTruth() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "score" field.</summary>
    public const int ScoreFieldNumber = 4;
    private readonly static double ScoreDefaultValue = 0D;

    private double score_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Score {
      get { if ((_hasBits0 & 4) != 0) { return score_; } else { return ScoreDefaultValue; } }
      set {
        _hasBits0 |= 4;
        score_ = value;
      }
    }
    /// <summary>Gets whether the "score" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScore {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "score" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScore() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SentenceFragment);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SentenceFragment other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!tokenIndex_.Equals(other.tokenIndex_)) return false;
      if (Root != other.Root) return false;
      if (AssumedTruth != other.AssumedTruth) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Score, other.Score)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= tokenIndex_.GetHashCode();
      if (HasRoot) hash ^= Root.GetHashCode();
      if (HasAssumedTruth) hash ^= AssumedTruth.GetHashCode();
      if (HasScore) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Score);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      tokenIndex_.WriteTo(output, _repeated_tokenIndex_codec);
      if (HasRoot) {
        output.WriteRawTag(16);
        output.WriteUInt32(Root);
      }
      if (HasAssumedTruth) {
        output.WriteRawTag(24);
        output.WriteBool(AssumedTruth);
      }
      if (HasScore) {
        output.WriteRawTag(33);
        output.WriteDouble(Score);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += tokenIndex_.CalculateSize(_repeated_tokenIndex_codec);
      if (HasRoot) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Root);
      }
      if (HasAssumedTruth) {
        size += 1 + 1;
      }
      if (HasScore) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SentenceFragment other) {
      if (other == null) {
        return;
      }
      tokenIndex_.Add(other.tokenIndex_);
      if (other.HasRoot) {
        Root = other.Root;
      }
      if (other.HasAssumedTruth) {
        AssumedTruth = other.AssumedTruth;
      }
      if (other.HasScore) {
        Score = other.Score;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            tokenIndex_.AddEntriesFrom(input, _repeated_tokenIndex_codec);
            break;
          }
          case 16: {
            Root = input.ReadUInt32();
            break;
          }
          case 24: {
            AssumedTruth = input.ReadBool();
            break;
          }
          case 33: {
            Score = input.ReadDouble();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// The index of a token in a document, including the sentence
  /// index and the offset.
  /// </summary>
  public sealed partial class TokenLocation : pb::IMessage<TokenLocation> {
    private static readonly pb::MessageParser<TokenLocation> _parser = new pb::MessageParser<TokenLocation>(() => new TokenLocation());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TokenLocation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokenLocation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokenLocation(TokenLocation other) : this() {
      _hasBits0 = other._hasBits0;
      sentenceIndex_ = other.sentenceIndex_;
      tokenIndex_ = other.tokenIndex_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokenLocation Clone() {
      return new TokenLocation(this);
    }

    /// <summary>Field number for the "sentenceIndex" field.</summary>
    public const int SentenceIndexFieldNumber = 1;
    private readonly static uint SentenceIndexDefaultValue = 0;

    private uint sentenceIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SentenceIndex {
      get { if ((_hasBits0 & 1) != 0) { return sentenceIndex_; } else { return SentenceIndexDefaultValue; } }
      set {
        _hasBits0 |= 1;
        sentenceIndex_ = value;
      }
    }
    /// <summary>Gets whether the "sentenceIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSentenceIndex {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "sentenceIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSentenceIndex() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "tokenIndex" field.</summary>
    public const int TokenIndexFieldNumber = 2;
    private readonly static uint TokenIndexDefaultValue = 0;

    private uint tokenIndex_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint TokenIndex {
      get { if ((_hasBits0 & 2) != 0) { return tokenIndex_; } else { return TokenIndexDefaultValue; } }
      set {
        _hasBits0 |= 2;
        tokenIndex_ = value;
      }
    }
    /// <summary>Gets whether the "tokenIndex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTokenIndex {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "tokenIndex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTokenIndex() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TokenLocation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TokenLocation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SentenceIndex != other.SentenceIndex) return false;
      if (TokenIndex != other.TokenIndex) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSentenceIndex) hash ^= SentenceIndex.GetHashCode();
      if (HasTokenIndex) hash ^= TokenIndex.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasSentenceIndex) {
        output.WriteRawTag(8);
        output.WriteUInt32(SentenceIndex);
      }
      if (HasTokenIndex) {
        output.WriteRawTag(16);
        output.WriteUInt32(TokenIndex);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasSentenceIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SentenceIndex);
      }
      if (HasTokenIndex) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(TokenIndex);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TokenLocation other) {
      if (other == null) {
        return;
      }
      if (other.HasSentenceIndex) {
        SentenceIndex = other.SentenceIndex;
      }
      if (other.HasTokenIndex) {
        TokenIndex = other.TokenIndex;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SentenceIndex = input.ReadUInt32();
            break;
          }
          case 16: {
            TokenIndex = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// An OpenIE relation triple.
  /// Created by the openie annotator.
  /// </summary>
  public sealed partial class RelationTriple : pb::IMessage<RelationTriple> {
    private static readonly pb::MessageParser<RelationTriple> _parser = new pb::MessageParser<RelationTriple>(() => new RelationTriple());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RelationTriple> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RelationTriple() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RelationTriple(RelationTriple other) : this() {
      _hasBits0 = other._hasBits0;
      subject_ = other.subject_;
      relation_ = other.relation_;
      object_ = other.object_;
      confidence_ = other.confidence_;
      subjectTokens_ = other.subjectTokens_.Clone();
      relationTokens_ = other.relationTokens_.Clone();
      objectTokens_ = other.objectTokens_.Clone();
      tree_ = other.tree_ != null ? other.tree_.Clone() : null;
      istmod_ = other.istmod_;
      prefixBe_ = other.prefixBe_;
      suffixBe_ = other.suffixBe_;
      suffixOf_ = other.suffixOf_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RelationTriple Clone() {
      return new RelationTriple(this);
    }

    /// <summary>Field number for the "subject" field.</summary>
    public const int SubjectFieldNumber = 1;
    private readonly static string SubjectDefaultValue = "";

    private string subject_;
    /// <summary>
    /// The surface form of the subject
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Subject {
      get { return subject_ ?? SubjectDefaultValue; }
      set {
        subject_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "subject" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSubject {
      get { return subject_ != null; }
    }
    /// <summary>Clears the value of the "subject" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSubject() {
      subject_ = null;
    }

    /// <summary>Field number for the "relation" field.</summary>
    public const int RelationFieldNumber = 2;
    private readonly static string RelationDefaultValue = "";

    private string relation_;
    /// <summary>
    /// The surface form of the relation (required)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Relation {
      get { return relation_ ?? RelationDefaultValue; }
      set {
        relation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "relation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRelation {
      get { return relation_ != null; }
    }
    /// <summary>Clears the value of the "relation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRelation() {
      relation_ = null;
    }

    /// <summary>Field number for the "object" field.</summary>
    public const int ObjectFieldNumber = 3;
    private readonly static string ObjectDefaultValue = "";

    private string object_;
    /// <summary>
    /// The surface form of the object
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Object {
      get { return object_ ?? ObjectDefaultValue; }
      set {
        object_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "object" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasObject {
      get { return object_ != null; }
    }
    /// <summary>Clears the value of the "object" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearObject() {
      object_ = null;
    }

    /// <summary>Field number for the "confidence" field.</summary>
    public const int ConfidenceFieldNumber = 4;
    private readonly static double ConfidenceDefaultValue = 0D;

    private double confidence_;
    /// <summary>
    /// The [optional] confidence of the extraction
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Confidence {
      get { if ((_hasBits0 & 1) != 0) { return confidence_; } else { return ConfidenceDefaultValue; } }
      set {
        _hasBits0 |= 1;
        confidence_ = value;
      }
    }
    /// <summary>Gets whether the "confidence" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasConfidence {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "confidence" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConfidence() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "subjectTokens" field.</summary>
    public const int SubjectTokensFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> _repeated_subjectTokens_codec
        = pb::FieldCodec.ForMessage(106, global::Edu.Stanford.Nlp.Pipeline.TokenLocation.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> subjectTokens_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation>();
    /// <summary>
    /// The tokens comprising the subject of the triple
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> SubjectTokens {
      get { return subjectTokens_; }
    }

    /// <summary>Field number for the "relationTokens" field.</summary>
    public const int RelationTokensFieldNumber = 14;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> _repeated_relationTokens_codec
        = pb::FieldCodec.ForMessage(114, global::Edu.Stanford.Nlp.Pipeline.TokenLocation.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> relationTokens_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation>();
    /// <summary>
    /// The tokens comprising the relation of the triple
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> RelationTokens {
      get { return relationTokens_; }
    }

    /// <summary>Field number for the "objectTokens" field.</summary>
    public const int ObjectTokensFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> _repeated_objectTokens_codec
        = pb::FieldCodec.ForMessage(122, global::Edu.Stanford.Nlp.Pipeline.TokenLocation.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> objectTokens_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation>();
    /// <summary>
    /// The tokens comprising the object of the triple
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokenLocation> ObjectTokens {
      get { return objectTokens_; }
    }

    /// <summary>Field number for the "tree" field.</summary>
    public const int TreeFieldNumber = 8;
    private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph tree_;
    /// <summary>
    /// The dependency graph fragment for this triple
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph Tree {
      get { return tree_; }
      set {
        tree_ = value;
      }
    }

    /// <summary>Field number for the "istmod" field.</summary>
    public const int IstmodFieldNumber = 9;
    private readonly static bool IstmodDefaultValue = false;

    private bool istmod_;
    /// <summary>
    /// If true, this expresses an implicit tmod relation
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Istmod {
      get { if ((_hasBits0 & 2) != 0) { return istmod_; } else { return IstmodDefaultValue; } }
      set {
        _hasBits0 |= 2;
        istmod_ = value;
      }
    }
    /// <summary>Gets whether the "istmod" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIstmod {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "istmod" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIstmod() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "prefixBe" field.</summary>
    public const int PrefixBeFieldNumber = 10;
    private readonly static bool PrefixBeDefaultValue = false;

    private bool prefixBe_;
    /// <summary>
    /// If true, this relation string is missing a 'be' prefix
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PrefixBe {
      get { if ((_hasBits0 & 4) != 0) { return prefixBe_; } else { return PrefixBeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        prefixBe_ = value;
      }
    }
    /// <summary>Gets whether the "prefixBe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPrefixBe {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "prefixBe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPrefixBe() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "suffixBe" field.</summary>
    public const int SuffixBeFieldNumber = 11;
    private readonly static bool SuffixBeDefaultValue = false;

    private bool suffixBe_;
    /// <summary>
    /// If true, this relation string is missing a 'be' suffix
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SuffixBe {
      get { if ((_hasBits0 & 8) != 0) { return suffixBe_; } else { return SuffixBeDefaultValue; } }
      set {
        _hasBits0 |= 8;
        suffixBe_ = value;
      }
    }
    /// <summary>Gets whether the "suffixBe" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSuffixBe {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "suffixBe" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSuffixBe() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "suffixOf" field.</summary>
    public const int SuffixOfFieldNumber = 12;
    private readonly static bool SuffixOfDefaultValue = false;

    private bool suffixOf_;
    /// <summary>
    /// If true, this relation string is missing a 'of' prefix
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SuffixOf {
      get { if ((_hasBits0 & 16) != 0) { return suffixOf_; } else { return SuffixOfDefaultValue; } }
      set {
        _hasBits0 |= 16;
        suffixOf_ = value;
      }
    }
    /// <summary>Gets whether the "suffixOf" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSuffixOf {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "suffixOf" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSuffixOf() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RelationTriple);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RelationTriple other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Subject != other.Subject) return false;
      if (Relation != other.Relation) return false;
      if (Object != other.Object) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Confidence, other.Confidence)) return false;
      if(!subjectTokens_.Equals(other.subjectTokens_)) return false;
      if(!relationTokens_.Equals(other.relationTokens_)) return false;
      if(!objectTokens_.Equals(other.objectTokens_)) return false;
      if (!object.Equals(Tree, other.Tree)) return false;
      if (Istmod != other.Istmod) return false;
      if (PrefixBe != other.PrefixBe) return false;
      if (SuffixBe != other.SuffixBe) return false;
      if (SuffixOf != other.SuffixOf) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSubject) hash ^= Subject.GetHashCode();
      if (HasRelation) hash ^= Relation.GetHashCode();
      if (HasObject) hash ^= Object.GetHashCode();
      if (HasConfidence) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Confidence);
      hash ^= subjectTokens_.GetHashCode();
      hash ^= relationTokens_.GetHashCode();
      hash ^= objectTokens_.GetHashCode();
      if (tree_ != null) hash ^= Tree.GetHashCode();
      if (HasIstmod) hash ^= Istmod.GetHashCode();
      if (HasPrefixBe) hash ^= PrefixBe.GetHashCode();
      if (HasSuffixBe) hash ^= SuffixBe.GetHashCode();
      if (HasSuffixOf) hash ^= SuffixOf.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasSubject) {
        output.WriteRawTag(10);
        output.WriteString(Subject);
      }
      if (HasRelation) {
        output.WriteRawTag(18);
        output.WriteString(Relation);
      }
      if (HasObject) {
        output.WriteRawTag(26);
        output.WriteString(Object);
      }
      if (HasConfidence) {
        output.WriteRawTag(33);
        output.WriteDouble(Confidence);
      }
      if (tree_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Tree);
      }
      if (HasIstmod) {
        output.WriteRawTag(72);
        output.WriteBool(Istmod);
      }
      if (HasPrefixBe) {
        output.WriteRawTag(80);
        output.WriteBool(PrefixBe);
      }
      if (HasSuffixBe) {
        output.WriteRawTag(88);
        output.WriteBool(SuffixBe);
      }
      if (HasSuffixOf) {
        output.WriteRawTag(96);
        output.WriteBool(SuffixOf);
      }
      subjectTokens_.WriteTo(output, _repeated_subjectTokens_codec);
      relationTokens_.WriteTo(output, _repeated_relationTokens_codec);
      objectTokens_.WriteTo(output, _repeated_objectTokens_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasSubject) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Subject);
      }
      if (HasRelation) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Relation);
      }
      if (HasObject) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Object);
      }
      if (HasConfidence) {
        size += 1 + 8;
      }
      size += subjectTokens_.CalculateSize(_repeated_subjectTokens_codec);
      size += relationTokens_.CalculateSize(_repeated_relationTokens_codec);
      size += objectTokens_.CalculateSize(_repeated_objectTokens_codec);
      if (tree_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tree);
      }
      if (HasIstmod) {
        size += 1 + 1;
      }
      if (HasPrefixBe) {
        size += 1 + 1;
      }
      if (HasSuffixBe) {
        size += 1 + 1;
      }
      if (HasSuffixOf) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RelationTriple other) {
      if (other == null) {
        return;
      }
      if (other.HasSubject) {
        Subject = other.Subject;
      }
      if (other.HasRelation) {
        Relation = other.Relation;
      }
      if (other.HasObject) {
        Object = other.Object;
      }
      if (other.HasConfidence) {
        Confidence = other.Confidence;
      }
      subjectTokens_.Add(other.subjectTokens_);
      relationTokens_.Add(other.relationTokens_);
      objectTokens_.Add(other.objectTokens_);
      if (other.tree_ != null) {
        if (tree_ == null) {
          Tree = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
        }
        Tree.MergeFrom(other.Tree);
      }
      if (other.HasIstmod) {
        Istmod = other.Istmod;
      }
      if (other.HasPrefixBe) {
        PrefixBe = other.PrefixBe;
      }
      if (other.HasSuffixBe) {
        SuffixBe = other.SuffixBe;
      }
      if (other.HasSuffixOf) {
        SuffixOf = other.SuffixOf;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Subject = input.ReadString();
            break;
          }
          case 18: {
            Relation = input.ReadString();
            break;
          }
          case 26: {
            Object = input.ReadString();
            break;
          }
          case 33: {
            Confidence = input.ReadDouble();
            break;
          }
          case 66: {
            if (tree_ == null) {
              Tree = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            input.ReadMessage(Tree);
            break;
          }
          case 72: {
            Istmod = input.ReadBool();
            break;
          }
          case 80: {
            PrefixBe = input.ReadBool();
            break;
          }
          case 88: {
            SuffixBe = input.ReadBool();
            break;
          }
          case 96: {
            SuffixOf = input.ReadBool();
            break;
          }
          case 106: {
            subjectTokens_.AddEntriesFrom(input, _repeated_subjectTokens_codec);
            break;
          }
          case 114: {
            relationTokens_.AddEntriesFrom(input, _repeated_relationTokens_codec);
            break;
          }
          case 122: {
            objectTokens_.AddEntriesFrom(input, _repeated_objectTokens_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A map from strings to strings.
  /// Used, minimally, in the CoNLLU featurizer
  /// </summary>
  public sealed partial class MapStringString : pb::IMessage<MapStringString> {
    private static readonly pb::MessageParser<MapStringString> _parser = new pb::MessageParser<MapStringString>(() => new MapStringString());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MapStringString> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MapStringString() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MapStringString(MapStringString other) : this() {
      key_ = other.key_.Clone();
      value_ = other.value_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MapStringString Clone() {
      return new MapStringString(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_key_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> key_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Key {
      get { return key_; }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_value_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> value_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Value {
      get { return value_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MapStringString);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MapStringString other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!key_.Equals(other.key_)) return false;
      if(!value_.Equals(other.value_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= key_.GetHashCode();
      hash ^= value_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      key_.WriteTo(output, _repeated_key_codec);
      value_.WriteTo(output, _repeated_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += key_.CalculateSize(_repeated_key_codec);
      size += value_.CalculateSize(_repeated_value_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MapStringString other) {
      if (other == null) {
        return;
      }
      key_.Add(other.key_);
      value_.Add(other.value_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            key_.AddEntriesFrom(input, _repeated_key_codec);
            break;
          }
          case 18: {
            value_.AddEntriesFrom(input, _repeated_value_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// A map from integers to strings.
  /// Used, minimally, in the CoNLLU featurizer
  /// </summary>
  public sealed partial class MapIntString : pb::IMessage<MapIntString> {
    private static readonly pb::MessageParser<MapIntString> _parser = new pb::MessageParser<MapIntString>(() => new MapIntString());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MapIntString> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MapIntString() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MapIntString(MapIntString other) : this() {
      key_ = other.key_.Clone();
      value_ = other.value_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MapIntString Clone() {
      return new MapIntString(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private static readonly pb::FieldCodec<uint> _repeated_key_codec
        = pb::FieldCodec.ForUInt32(8);
    private readonly pbc::RepeatedField<uint> key_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> Key {
      get { return key_; }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_value_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> value_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Value {
      get { return value_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MapIntString);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MapIntString other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!key_.Equals(other.key_)) return false;
      if(!value_.Equals(other.value_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= key_.GetHashCode();
      hash ^= value_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      key_.WriteTo(output, _repeated_key_codec);
      value_.WriteTo(output, _repeated_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += key_.CalculateSize(_repeated_key_codec);
      size += value_.CalculateSize(_repeated_value_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MapIntString other) {
      if (other == null) {
        return;
      }
      key_.Add(other.key_);
      value_.Add(other.value_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            key_.AddEntriesFrom(input, _repeated_key_codec);
            break;
          }
          case 18: {
            value_.AddEntriesFrom(input, _repeated_value_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class Section : pb::IMessage<Section> {
    private static readonly pb::MessageParser<Section> _parser = new pb::MessageParser<Section>(() => new Section());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Section> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Section() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Section(Section other) : this() {
      _hasBits0 = other._hasBits0;
      charBegin_ = other.charBegin_;
      charEnd_ = other.charEnd_;
      author_ = other.author_;
      sentenceIndexes_ = other.sentenceIndexes_.Clone();
      datetime_ = other.datetime_;
      quotes_ = other.quotes_.Clone();
      authorCharBegin_ = other.authorCharBegin_;
      authorCharEnd_ = other.authorCharEnd_;
      xmlTag_ = other.xmlTag_ != null ? other.xmlTag_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Section Clone() {
      return new Section(this);
    }

    /// <summary>Field number for the "charBegin" field.</summary>
    public const int CharBeginFieldNumber = 1;
    private readonly static uint CharBeginDefaultValue = 0;

    private uint charBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CharBegin {
      get { if ((_hasBits0 & 1) != 0) { return charBegin_; } else { return CharBeginDefaultValue; } }
      set {
        _hasBits0 |= 1;
        charBegin_ = value;
      }
    }
    /// <summary>Gets whether the "charBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCharBegin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "charBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCharBegin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "charEnd" field.</summary>
    public const int CharEndFieldNumber = 2;
    private readonly static uint CharEndDefaultValue = 0;

    private uint charEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CharEnd {
      get { if ((_hasBits0 & 2) != 0) { return charEnd_; } else { return CharEndDefaultValue; } }
      set {
        _hasBits0 |= 2;
        charEnd_ = value;
      }
    }
    /// <summary>Gets whether the "charEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasCharEnd {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "charEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearCharEnd() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "author" field.</summary>
    public const int AuthorFieldNumber = 3;
    private readonly static string AuthorDefaultValue = "";

    private string author_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Author {
      get { return author_ ?? AuthorDefaultValue; }
      set {
        author_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "author" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAuthor {
      get { return author_ != null; }
    }
    /// <summary>Clears the value of the "author" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAuthor() {
      author_ = null;
    }

    /// <summary>Field number for the "sentenceIndexes" field.</summary>
    public const int SentenceIndexesFieldNumber = 4;
    private static readonly pb::FieldCodec<uint> _repeated_sentenceIndexes_codec
        = pb::FieldCodec.ForUInt32(32);
    private readonly pbc::RepeatedField<uint> sentenceIndexes_ = new pbc::RepeatedField<uint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> SentenceIndexes {
      get { return sentenceIndexes_; }
    }

    /// <summary>Field number for the "datetime" field.</summary>
    public const int DatetimeFieldNumber = 5;
    private readonly static string DatetimeDefaultValue = "";

    private string datetime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Datetime {
      get { return datetime_ ?? DatetimeDefaultValue; }
      set {
        datetime_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "datetime" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDatetime {
      get { return datetime_ != null; }
    }
    /// <summary>Clears the value of the "datetime" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDatetime() {
      datetime_ = null;
    }

    /// <summary>Field number for the "quotes" field.</summary>
    public const int QuotesFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Quote> _repeated_quotes_codec
        = pb::FieldCodec.ForMessage(50, global::Edu.Stanford.Nlp.Pipeline.Quote.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Quote> quotes_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Quote>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Quote> Quotes {
      get { return quotes_; }
    }

    /// <summary>Field number for the "authorCharBegin" field.</summary>
    public const int AuthorCharBeginFieldNumber = 7;
    private readonly static uint AuthorCharBeginDefaultValue = 0;

    private uint authorCharBegin_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint AuthorCharBegin {
      get { if ((_hasBits0 & 4) != 0) { return authorCharBegin_; } else { return AuthorCharBeginDefaultValue; } }
      set {
        _hasBits0 |= 4;
        authorCharBegin_ = value;
      }
    }
    /// <summary>Gets whether the "authorCharBegin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAuthorCharBegin {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "authorCharBegin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAuthorCharBegin() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "authorCharEnd" field.</summary>
    public const int AuthorCharEndFieldNumber = 8;
    private readonly static uint AuthorCharEndDefaultValue = 0;

    private uint authorCharEnd_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint AuthorCharEnd {
      get { if ((_hasBits0 & 8) != 0) { return authorCharEnd_; } else { return AuthorCharEndDefaultValue; } }
      set {
        _hasBits0 |= 8;
        authorCharEnd_ = value;
      }
    }
    /// <summary>Gets whether the "authorCharEnd" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasAuthorCharEnd {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "authorCharEnd" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAuthorCharEnd() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "xmlTag" field.</summary>
    public const int XmlTagFieldNumber = 9;
    private global::Edu.Stanford.Nlp.Pipeline.Token xmlTag_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Token XmlTag {
      get { return xmlTag_; }
      set {
        xmlTag_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Section);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Section other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CharBegin != other.CharBegin) return false;
      if (CharEnd != other.CharEnd) return false;
      if (Author != other.Author) return false;
      if(!sentenceIndexes_.Equals(other.sentenceIndexes_)) return false;
      if (Datetime != other.Datetime) return false;
      if(!quotes_.Equals(other.quotes_)) return false;
      if (AuthorCharBegin != other.AuthorCharBegin) return false;
      if (AuthorCharEnd != other.AuthorCharEnd) return false;
      if (!object.Equals(XmlTag, other.XmlTag)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCharBegin) hash ^= CharBegin.GetHashCode();
      if (HasCharEnd) hash ^= CharEnd.GetHashCode();
      if (HasAuthor) hash ^= Author.GetHashCode();
      hash ^= sentenceIndexes_.GetHashCode();
      if (HasDatetime) hash ^= Datetime.GetHashCode();
      hash ^= quotes_.GetHashCode();
      if (HasAuthorCharBegin) hash ^= AuthorCharBegin.GetHashCode();
      if (HasAuthorCharEnd) hash ^= AuthorCharEnd.GetHashCode();
      if (xmlTag_ != null) hash ^= XmlTag.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasCharBegin) {
        output.WriteRawTag(8);
        output.WriteUInt32(CharBegin);
      }
      if (HasCharEnd) {
        output.WriteRawTag(16);
        output.WriteUInt32(CharEnd);
      }
      if (HasAuthor) {
        output.WriteRawTag(26);
        output.WriteString(Author);
      }
      sentenceIndexes_.WriteTo(output, _repeated_sentenceIndexes_codec);
      if (HasDatetime) {
        output.WriteRawTag(42);
        output.WriteString(Datetime);
      }
      quotes_.WriteTo(output, _repeated_quotes_codec);
      if (HasAuthorCharBegin) {
        output.WriteRawTag(56);
        output.WriteUInt32(AuthorCharBegin);
      }
      if (HasAuthorCharEnd) {
        output.WriteRawTag(64);
        output.WriteUInt32(AuthorCharEnd);
      }
      if (xmlTag_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(XmlTag);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasCharBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CharBegin);
      }
      if (HasCharEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CharEnd);
      }
      if (HasAuthor) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Author);
      }
      size += sentenceIndexes_.CalculateSize(_repeated_sentenceIndexes_codec);
      if (HasDatetime) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Datetime);
      }
      size += quotes_.CalculateSize(_repeated_quotes_codec);
      if (HasAuthorCharBegin) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AuthorCharBegin);
      }
      if (HasAuthorCharEnd) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(AuthorCharEnd);
      }
      if (xmlTag_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(XmlTag);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Section other) {
      if (other == null) {
        return;
      }
      if (other.HasCharBegin) {
        CharBegin = other.CharBegin;
      }
      if (other.HasCharEnd) {
        CharEnd = other.CharEnd;
      }
      if (other.HasAuthor) {
        Author = other.Author;
      }
      sentenceIndexes_.Add(other.sentenceIndexes_);
      if (other.HasDatetime) {
        Datetime = other.Datetime;
      }
      quotes_.Add(other.quotes_);
      if (other.HasAuthorCharBegin) {
        AuthorCharBegin = other.AuthorCharBegin;
      }
      if (other.HasAuthorCharEnd) {
        AuthorCharEnd = other.AuthorCharEnd;
      }
      if (other.xmlTag_ != null) {
        if (xmlTag_ == null) {
          XmlTag = new global::Edu.Stanford.Nlp.Pipeline.Token();
        }
        XmlTag.MergeFrom(other.XmlTag);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CharBegin = input.ReadUInt32();
            break;
          }
          case 16: {
            CharEnd = input.ReadUInt32();
            break;
          }
          case 26: {
            Author = input.ReadString();
            break;
          }
          case 34:
          case 32: {
            sentenceIndexes_.AddEntriesFrom(input, _repeated_sentenceIndexes_codec);
            break;
          }
          case 42: {
            Datetime = input.ReadString();
            break;
          }
          case 50: {
            quotes_.AddEntriesFrom(input, _repeated_quotes_codec);
            break;
          }
          case 56: {
            AuthorCharBegin = input.ReadUInt32();
            break;
          }
          case 64: {
            AuthorCharEnd = input.ReadUInt32();
            break;
          }
          case 74: {
            if (xmlTag_ == null) {
              XmlTag = new global::Edu.Stanford.Nlp.Pipeline.Token();
            }
            input.ReadMessage(XmlTag);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A message for requesting a semgrex
  /// Each sentence stores information about the tokens making up the
  /// corresponding graph
  /// An alternative would have been to use the existing Document or
  /// Sentence classes, but the problem with that is it would be
  /// ambiguous which dependency object to use.
  /// </summary>
  public sealed partial class SemgrexRequest : pb::IMessage<SemgrexRequest> {
    private static readonly pb::MessageParser<SemgrexRequest> _parser = new pb::MessageParser<SemgrexRequest>(() => new SemgrexRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SemgrexRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SemgrexRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SemgrexRequest(SemgrexRequest other) : this() {
      semgrex_ = other.semgrex_.Clone();
      query_ = other.query_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SemgrexRequest Clone() {
      return new SemgrexRequest(this);
    }

    /// <summary>Field number for the "semgrex" field.</summary>
    public const int SemgrexFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_semgrex_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> semgrex_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Semgrex {
      get { return semgrex_; }
    }

    /// <summary>Field number for the "query" field.</summary>
    public const int QueryFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Types.Dependencies> _repeated_query_codec
        = pb::FieldCodec.ForMessage(18, global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Types.Dependencies.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Types.Dependencies> query_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Types.Dependencies>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Types.Dependencies> Query {
      get { return query_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SemgrexRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SemgrexRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!semgrex_.Equals(other.semgrex_)) return false;
      if(!query_.Equals(other.query_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= semgrex_.GetHashCode();
      hash ^= query_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      semgrex_.WriteTo(output, _repeated_semgrex_codec);
      query_.WriteTo(output, _repeated_query_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += semgrex_.CalculateSize(_repeated_semgrex_codec);
      size += query_.CalculateSize(_repeated_query_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SemgrexRequest other) {
      if (other == null) {
        return;
      }
      semgrex_.Add(other.semgrex_);
      query_.Add(other.query_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            semgrex_.AddEntriesFrom(input, _repeated_semgrex_codec);
            break;
          }
          case 18: {
            query_.AddEntriesFrom(input, _repeated_query_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SemgrexRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Dependencies : pb::IMessage<Dependencies> {
        private static readonly pb::MessageParser<Dependencies> _parser = new pb::MessageParser<Dependencies>(() => new Dependencies());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Dependencies> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.SemgrexRequest.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Dependencies() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Dependencies(Dependencies other) : this() {
          token_ = other.token_.Clone();
          graph_ = other.graph_ != null ? other.graph_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Dependencies Clone() {
          return new Dependencies(this);
        }

        /// <summary>Field number for the "token" field.</summary>
        public const int TokenFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.Token> _repeated_token_codec
            = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.Token.Parser);
        private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> token_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.Token> Token {
          get { return token_; }
        }

        /// <summary>Field number for the "graph" field.</summary>
        public const int GraphFieldNumber = 2;
        private global::Edu.Stanford.Nlp.Pipeline.DependencyGraph graph_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Edu.Stanford.Nlp.Pipeline.DependencyGraph Graph {
          get { return graph_; }
          set {
            graph_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Dependencies);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Dependencies other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!token_.Equals(other.token_)) return false;
          if (!object.Equals(Graph, other.Graph)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= token_.GetHashCode();
          if (graph_ != null) hash ^= Graph.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          token_.WriteTo(output, _repeated_token_codec);
          if (graph_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Graph);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += token_.CalculateSize(_repeated_token_codec);
          if (graph_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Graph);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Dependencies other) {
          if (other == null) {
            return;
          }
          token_.Add(other.token_);
          if (other.graph_ != null) {
            if (graph_ == null) {
              Graph = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
            }
            Graph.MergeFrom(other.Graph);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                token_.AddEntriesFrom(input, _repeated_token_codec);
                break;
              }
              case 18: {
                if (graph_ == null) {
                  Graph = new global::Edu.Stanford.Nlp.Pipeline.DependencyGraph();
                }
                input.ReadMessage(Graph);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// The response from running a semgrex
  /// If you pass in M semgrex expressions and N dependency graphs,
  /// this returns MxN nested results.  Each SemgrexResult can match
  /// multiple times in one graph
  /// </summary>
  public sealed partial class SemgrexResponse : pb::IMessage<SemgrexResponse> {
    private static readonly pb::MessageParser<SemgrexResponse> _parser = new pb::MessageParser<SemgrexResponse>(() => new SemgrexResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SemgrexResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SemgrexResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SemgrexResponse(SemgrexResponse other) : this() {
      result_ = other.result_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SemgrexResponse Clone() {
      return new SemgrexResponse(this);
    }

    /// <summary>Field number for the "result" field.</summary>
    public const int ResultFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.GraphResult> _repeated_result_codec
        = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.GraphResult.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.GraphResult> result_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.GraphResult>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.GraphResult> Result {
      get { return result_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SemgrexResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SemgrexResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!result_.Equals(other.result_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= result_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      result_.WriteTo(output, _repeated_result_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += result_.CalculateSize(_repeated_result_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SemgrexResponse other) {
      if (other == null) {
        return;
      }
      result_.Add(other.result_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            result_.AddEntriesFrom(input, _repeated_result_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SemgrexResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class NamedNode : pb::IMessage<NamedNode> {
        private static readonly pb::MessageParser<NamedNode> _parser = new pb::MessageParser<NamedNode>(() => new NamedNode());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<NamedNode> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedNode() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedNode(NamedNode other) : this() {
          _hasBits0 = other._hasBits0;
          name_ = other.name_;
          matchIndex_ = other.matchIndex_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedNode Clone() {
          return new NamedNode(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_ ?? NameDefaultValue; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName {
          get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName() {
          name_ = null;
        }

        /// <summary>Field number for the "matchIndex" field.</summary>
        public const int MatchIndexFieldNumber = 2;
        private readonly static int MatchIndexDefaultValue = 0;

        private int matchIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MatchIndex {
          get { if ((_hasBits0 & 1) != 0) { return matchIndex_; } else { return MatchIndexDefaultValue; } }
          set {
            _hasBits0 |= 1;
            matchIndex_ = value;
          }
        }
        /// <summary>Gets whether the "matchIndex" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMatchIndex {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "matchIndex" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMatchIndex() {
          _hasBits0 &= ~1;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as NamedNode);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(NamedNode other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (MatchIndex != other.MatchIndex) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasName) hash ^= Name.GetHashCode();
          if (HasMatchIndex) hash ^= MatchIndex.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasName) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (HasMatchIndex) {
            output.WriteRawTag(16);
            output.WriteInt32(MatchIndex);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasName) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (HasMatchIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MatchIndex);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(NamedNode other) {
          if (other == null) {
            return;
          }
          if (other.HasName) {
            Name = other.Name;
          }
          if (other.HasMatchIndex) {
            MatchIndex = other.MatchIndex;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 16: {
                MatchIndex = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

      public sealed partial class NamedRelation : pb::IMessage<NamedRelation> {
        private static readonly pb::MessageParser<NamedRelation> _parser = new pb::MessageParser<NamedRelation>(() => new NamedRelation());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<NamedRelation> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedRelation() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedRelation(NamedRelation other) : this() {
          name_ = other.name_;
          reln_ = other.reln_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public NamedRelation Clone() {
          return new NamedRelation(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_ ?? NameDefaultValue; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasName {
          get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearName() {
          name_ = null;
        }

        /// <summary>Field number for the "reln" field.</summary>
        public const int RelnFieldNumber = 2;
        private readonly static string RelnDefaultValue = "";

        private string reln_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Reln {
          get { return reln_ ?? RelnDefaultValue; }
          set {
            reln_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "reln" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasReln {
          get { return reln_ != null; }
        }
        /// <summary>Clears the value of the "reln" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearReln() {
          reln_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as NamedRelation);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(NamedRelation other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Reln != other.Reln) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasName) hash ^= Name.GetHashCode();
          if (HasReln) hash ^= Reln.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasName) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (HasReln) {
            output.WriteRawTag(18);
            output.WriteString(Reln);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasName) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (HasReln) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Reln);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(NamedRelation other) {
          if (other == null) {
            return;
          }
          if (other.HasName) {
            Name = other.Name;
          }
          if (other.HasReln) {
            Reln = other.Reln;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                Reln = input.ReadString();
                break;
              }
            }
          }
        }

      }

      public sealed partial class Match : pb::IMessage<Match> {
        private static readonly pb::MessageParser<Match> _parser = new pb::MessageParser<Match>(() => new Match());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Match> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Match() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Match(Match other) : this() {
          _hasBits0 = other._hasBits0;
          matchIndex_ = other.matchIndex_;
          node_ = other.node_.Clone();
          reln_ = other.reln_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Match Clone() {
          return new Match(this);
        }

        /// <summary>Field number for the "matchIndex" field.</summary>
        public const int MatchIndexFieldNumber = 1;
        private readonly static int MatchIndexDefaultValue = 0;

        private int matchIndex_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MatchIndex {
          get { if ((_hasBits0 & 1) != 0) { return matchIndex_; } else { return MatchIndexDefaultValue; } }
          set {
            _hasBits0 |= 1;
            matchIndex_ = value;
          }
        }
        /// <summary>Gets whether the "matchIndex" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasMatchIndex {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "matchIndex" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearMatchIndex() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "node" field.</summary>
        public const int NodeFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedNode> _repeated_node_codec
            = pb::FieldCodec.ForMessage(18, global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedNode.Parser);
        private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedNode> node_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedNode>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedNode> Node {
          get { return node_; }
        }

        /// <summary>Field number for the "reln" field.</summary>
        public const int RelnFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedRelation> _repeated_reln_codec
            = pb::FieldCodec.ForMessage(26, global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedRelation.Parser);
        private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedRelation> reln_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedRelation>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.NamedRelation> Reln {
          get { return reln_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Match);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Match other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MatchIndex != other.MatchIndex) return false;
          if(!node_.Equals(other.node_)) return false;
          if(!reln_.Equals(other.reln_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasMatchIndex) hash ^= MatchIndex.GetHashCode();
          hash ^= node_.GetHashCode();
          hash ^= reln_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasMatchIndex) {
            output.WriteRawTag(8);
            output.WriteInt32(MatchIndex);
          }
          node_.WriteTo(output, _repeated_node_codec);
          reln_.WriteTo(output, _repeated_reln_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasMatchIndex) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MatchIndex);
          }
          size += node_.CalculateSize(_repeated_node_codec);
          size += reln_.CalculateSize(_repeated_reln_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Match other) {
          if (other == null) {
            return;
          }
          if (other.HasMatchIndex) {
            MatchIndex = other.MatchIndex;
          }
          node_.Add(other.node_);
          reln_.Add(other.reln_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MatchIndex = input.ReadInt32();
                break;
              }
              case 18: {
                node_.AddEntriesFrom(input, _repeated_node_codec);
                break;
              }
              case 26: {
                reln_.AddEntriesFrom(input, _repeated_reln_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class SemgrexResult : pb::IMessage<SemgrexResult> {
        private static readonly pb::MessageParser<SemgrexResult> _parser = new pb::MessageParser<SemgrexResult>(() => new SemgrexResult());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SemgrexResult> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SemgrexResult() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SemgrexResult(SemgrexResult other) : this() {
          match_ = other.match_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SemgrexResult Clone() {
          return new SemgrexResult(this);
        }

        /// <summary>Field number for the "match" field.</summary>
        public const int MatchFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.Match> _repeated_match_codec
            = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.Match.Parser);
        private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.Match> match_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.Match>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.Match> Match {
          get { return match_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SemgrexResult);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SemgrexResult other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!match_.Equals(other.match_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= match_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          match_.WriteTo(output, _repeated_match_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += match_.CalculateSize(_repeated_match_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SemgrexResult other) {
          if (other == null) {
            return;
          }
          match_.Add(other.match_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                match_.AddEntriesFrom(input, _repeated_match_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class GraphResult : pb::IMessage<GraphResult> {
        private static readonly pb::MessageParser<GraphResult> _parser = new pb::MessageParser<GraphResult>(() => new GraphResult());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<GraphResult> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GraphResult() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GraphResult(GraphResult other) : this() {
          result_ = other.result_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GraphResult Clone() {
          return new GraphResult(this);
        }

        /// <summary>Field number for the "result" field.</summary>
        public const int ResultFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.SemgrexResult> _repeated_result_codec
            = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.SemgrexResult.Parser);
        private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.SemgrexResult> result_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.SemgrexResult>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.SemgrexResponse.Types.SemgrexResult> Result {
          get { return result_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as GraphResult);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(GraphResult other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!result_.Equals(other.result_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= result_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          result_.WriteTo(output, _repeated_result_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += result_.CalculateSize(_repeated_result_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(GraphResult other) {
          if (other == null) {
            return;
          }
          result_.Add(other.result_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                result_.AddEntriesFrom(input, _repeated_result_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// It's possible to send in a whole document, but we
  /// only care about the Sentences and Tokens
  /// </summary>
  public sealed partial class TokensRegexRequest : pb::IMessage<TokensRegexRequest> {
    private static readonly pb::MessageParser<TokensRegexRequest> _parser = new pb::MessageParser<TokensRegexRequest>(() => new TokensRegexRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TokensRegexRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokensRegexRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokensRegexRequest(TokensRegexRequest other) : this() {
      doc_ = other.doc_ != null ? other.doc_.Clone() : null;
      pattern_ = other.pattern_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokensRegexRequest Clone() {
      return new TokensRegexRequest(this);
    }

    /// <summary>Field number for the "doc" field.</summary>
    public const int DocFieldNumber = 1;
    private global::Edu.Stanford.Nlp.Pipeline.Document doc_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Edu.Stanford.Nlp.Pipeline.Document Doc {
      get { return doc_; }
      set {
        doc_ = value;
      }
    }

    /// <summary>Field number for the "pattern" field.</summary>
    public const int PatternFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_pattern_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> pattern_ = new pbc::RepeatedField<string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Pattern {
      get { return pattern_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TokensRegexRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TokensRegexRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Doc, other.Doc)) return false;
      if(!pattern_.Equals(other.pattern_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (doc_ != null) hash ^= Doc.GetHashCode();
      hash ^= pattern_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (doc_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Doc);
      }
      pattern_.WriteTo(output, _repeated_pattern_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (doc_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Doc);
      }
      size += pattern_.CalculateSize(_repeated_pattern_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TokensRegexRequest other) {
      if (other == null) {
        return;
      }
      if (other.doc_ != null) {
        if (doc_ == null) {
          Doc = new global::Edu.Stanford.Nlp.Pipeline.Document();
        }
        Doc.MergeFrom(other.Doc);
      }
      pattern_.Add(other.pattern_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (doc_ == null) {
              Doc = new global::Edu.Stanford.Nlp.Pipeline.Document();
            }
            input.ReadMessage(Doc);
            break;
          }
          case 18: {
            pattern_.AddEntriesFrom(input, _repeated_pattern_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The result will be a nested structure:
  /// repeated PatternMatch, one for each pattern
  /// each PatternMatch has a repeated Match,
  ///   which tells you which sentence matched and where
  /// </summary>
  public sealed partial class TokensRegexResponse : pb::IMessage<TokensRegexResponse> {
    private static readonly pb::MessageParser<TokensRegexResponse> _parser = new pb::MessageParser<TokensRegexResponse>(() => new TokensRegexResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TokensRegexResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Edu.Stanford.Nlp.Pipeline.CoreNLPReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokensRegexResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokensRegexResponse(TokensRegexResponse other) : this() {
      match_ = other.match_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TokensRegexResponse Clone() {
      return new TokensRegexResponse(this);
    }

    /// <summary>Field number for the "match" field.</summary>
    public const int MatchFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.PatternMatch> _repeated_match_codec
        = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.PatternMatch.Parser);
    private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.PatternMatch> match_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.PatternMatch>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.PatternMatch> Match {
      get { return match_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TokensRegexResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TokensRegexResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!match_.Equals(other.match_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= match_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      match_.WriteTo(output, _repeated_match_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += match_.CalculateSize(_repeated_match_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TokensRegexResponse other) {
      if (other == null) {
        return;
      }
      match_.Add(other.match_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            match_.AddEntriesFrom(input, _repeated_match_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TokensRegexResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class MatchLocation : pb::IMessage<MatchLocation> {
        private static readonly pb::MessageParser<MatchLocation> _parser = new pb::MessageParser<MatchLocation>(() => new MatchLocation());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MatchLocation> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MatchLocation() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MatchLocation(MatchLocation other) : this() {
          _hasBits0 = other._hasBits0;
          text_ = other.text_;
          begin_ = other.begin_;
          end_ = other.end_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MatchLocation Clone() {
          return new MatchLocation(this);
        }

        /// <summary>Field number for the "text" field.</summary>
        public const int TextFieldNumber = 1;
        private readonly static string TextDefaultValue = "";

        private string text_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Text {
          get { return text_ ?? TextDefaultValue; }
          set {
            text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "text" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasText {
          get { return text_ != null; }
        }
        /// <summary>Clears the value of the "text" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearText() {
          text_ = null;
        }

        /// <summary>Field number for the "begin" field.</summary>
        public const int BeginFieldNumber = 2;
        private readonly static int BeginDefaultValue = 0;

        private int begin_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Begin {
          get { if ((_hasBits0 & 1) != 0) { return begin_; } else { return BeginDefaultValue; } }
          set {
            _hasBits0 |= 1;
            begin_ = value;
          }
        }
        /// <summary>Gets whether the "begin" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasBegin {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "begin" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearBegin() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "end" field.</summary>
        public const int EndFieldNumber = 3;
        private readonly static int EndDefaultValue = 0;

        private int end_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int End {
          get { if ((_hasBits0 & 2) != 0) { return end_; } else { return EndDefaultValue; } }
          set {
            _hasBits0 |= 2;
            end_ = value;
          }
        }
        /// <summary>Gets whether the "end" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasEnd {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "end" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearEnd() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MatchLocation);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MatchLocation other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Text != other.Text) return false;
          if (Begin != other.Begin) return false;
          if (End != other.End) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasText) hash ^= Text.GetHashCode();
          if (HasBegin) hash ^= Begin.GetHashCode();
          if (HasEnd) hash ^= End.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasText) {
            output.WriteRawTag(10);
            output.WriteString(Text);
          }
          if (HasBegin) {
            output.WriteRawTag(16);
            output.WriteInt32(Begin);
          }
          if (HasEnd) {
            output.WriteRawTag(24);
            output.WriteInt32(End);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasText) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
          }
          if (HasBegin) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Begin);
          }
          if (HasEnd) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(End);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MatchLocation other) {
          if (other == null) {
            return;
          }
          if (other.HasText) {
            Text = other.Text;
          }
          if (other.HasBegin) {
            Begin = other.Begin;
          }
          if (other.HasEnd) {
            End = other.End;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Text = input.ReadString();
                break;
              }
              case 16: {
                Begin = input.ReadInt32();
                break;
              }
              case 24: {
                End = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

      public sealed partial class Match : pb::IMessage<Match> {
        private static readonly pb::MessageParser<Match> _parser = new pb::MessageParser<Match>(() => new Match());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Match> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Match() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Match(Match other) : this() {
          _hasBits0 = other._hasBits0;
          sentence_ = other.sentence_;
          match_ = other.match_ != null ? other.match_.Clone() : null;
          group_ = other.group_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Match Clone() {
          return new Match(this);
        }

        /// <summary>Field number for the "sentence" field.</summary>
        public const int SentenceFieldNumber = 1;
        private readonly static int SentenceDefaultValue = 0;

        private int sentence_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int Sentence {
          get { if ((_hasBits0 & 1) != 0) { return sentence_; } else { return SentenceDefaultValue; } }
          set {
            _hasBits0 |= 1;
            sentence_ = value;
          }
        }
        /// <summary>Gets whether the "sentence" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasSentence {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "sentence" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearSentence() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "match" field.</summary>
        public const int Match_FieldNumber = 2;
        private global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation match_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation Match_ {
          get { return match_; }
          set {
            match_ = value;
          }
        }

        /// <summary>Field number for the "group" field.</summary>
        public const int GroupFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation> _repeated_group_codec
            = pb::FieldCodec.ForMessage(26, global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation.Parser);
        private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation> group_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation> Group {
          get { return group_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Match);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Match other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Sentence != other.Sentence) return false;
          if (!object.Equals(Match_, other.Match_)) return false;
          if(!group_.Equals(other.group_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasSentence) hash ^= Sentence.GetHashCode();
          if (match_ != null) hash ^= Match_.GetHashCode();
          hash ^= group_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasSentence) {
            output.WriteRawTag(8);
            output.WriteInt32(Sentence);
          }
          if (match_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Match_);
          }
          group_.WriteTo(output, _repeated_group_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasSentence) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Sentence);
          }
          if (match_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Match_);
          }
          size += group_.CalculateSize(_repeated_group_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Match other) {
          if (other == null) {
            return;
          }
          if (other.HasSentence) {
            Sentence = other.Sentence;
          }
          if (other.match_ != null) {
            if (match_ == null) {
              Match_ = new global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation();
            }
            Match_.MergeFrom(other.Match_);
          }
          group_.Add(other.group_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Sentence = input.ReadInt32();
                break;
              }
              case 18: {
                if (match_ == null) {
                  Match_ = new global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.MatchLocation();
                }
                input.ReadMessage(Match_);
                break;
              }
              case 26: {
                group_.AddEntriesFrom(input, _repeated_group_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class PatternMatch : pb::IMessage<PatternMatch> {
        private static readonly pb::MessageParser<PatternMatch> _parser = new pb::MessageParser<PatternMatch>(() => new PatternMatch());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PatternMatch> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PatternMatch() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PatternMatch(PatternMatch other) : this() {
          match_ = other.match_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PatternMatch Clone() {
          return new PatternMatch(this);
        }

        /// <summary>Field number for the "match" field.</summary>
        public const int MatchFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.Match> _repeated_match_codec
            = pb::FieldCodec.ForMessage(10, global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.Match.Parser);
        private readonly pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.Match> match_ = new pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.Match>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Edu.Stanford.Nlp.Pipeline.TokensRegexResponse.Types.Match> Match {
          get { return match_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as PatternMatch);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PatternMatch other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!match_.Equals(other.match_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= match_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          match_.WriteTo(output, _repeated_match_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += match_.CalculateSize(_repeated_match_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PatternMatch other) {
          if (other == null) {
            return;
          }
          match_.Add(other.match_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                match_.AddEntriesFrom(input, _repeated_match_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
